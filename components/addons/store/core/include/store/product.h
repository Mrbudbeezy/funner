#ifndef STORE_PRODUCT_HEADER
#define STORE_PRODUCT_HEADER

#include <cstddef>
#include <xtl/functional_fwd>

namespace common
{

//forward declaration
class PropertyMap;

}

namespace store
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Продукт
///////////////////////////////////////////////////////////////////////////////////////////////////
class Product
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор / копирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    Product  ();
    Product  (const Product&);
    ~Product ();

    Product& operator = (const Product&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Description    () const;
    void        SetDescription (const char* description);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Идентификатор
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Id    () const;
    void        SetId (const char* id) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Другие свойства
///////////////////////////////////////////////////////////////////////////////////////////////////
    const common::PropertyMap& Properties    () const;
          common::PropertyMap& Properties    ();
    void                       SetProperties (const common::PropertyMap& properties);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Низкоуровневый дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function <void (const void*)> ReleaseHandleFunction;

    const void* Handle    () const;
    void        SetHandle (const void* handle, const ReleaseHandleFunction& release_function = ReleaseHandleFunction ());

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (Product&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (Product&, Product&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Список продуктов
///////////////////////////////////////////////////////////////////////////////////////////////////
class ProductList
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор / копирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    ProductList ();
    ProductList (const ProductList&);
    ~ProductList ();

    ProductList& operator = (const ProductList&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество элементов / проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Size    () const;
    bool   IsEmpty () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к элементу по индексу
///////////////////////////////////////////////////////////////////////////////////////////////////
    const Product& operator [] (size_t index) const;
          Product& operator [] (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Резервирование элементов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Capacity () const;
    void   Reserve  (size_t count);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление элементов в коллекцию
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Add (const Product&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление элементов из коллекции
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Remove (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка коллекции
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Clear ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (ProductList&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (ProductList&, ProductList&);

}

#endif
