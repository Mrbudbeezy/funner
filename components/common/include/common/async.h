#ifndef COMMON_ASYNC_HEADER
#define COMMON_ASYNC_HEADER

#include <xtl/exception.h>
#include <xtl/functional_fwd>
#include <xtl/singleton_default.h>

#include <common/action_queue.h>

namespace common
{

namespace detail
{

class IAsyncAction;
class IAsyncResult;

}

//forward declaration
class AsyncResult;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип результата выполнения операции
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> struct AsyncResultType       { typedef T&   Type; };
template <>        struct AsyncResultType<void> { typedef void Type; };

///////////////////////////////////////////////////////////////////////////////////////////////////
///Выполнение асинхронной операции
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Ret> AsyncResult async_invoke (const xtl::function<Ret ()>&);
template <class Ret> AsyncResult async_invoke (const xtl::function<Ret ()>&, const xtl::function<void (AsyncResult&)>& callback);
template <class Ret> AsyncResult async_invoke (const xtl::function<Ret ()>&, ActionThread callback_thread, const xtl::function<void (AsyncResult&)>& callback);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Результат асинхронной операции (thread safe)
///////////////////////////////////////////////////////////////////////////////////////////////////
class AsyncResult
{
  template <class Ret> friend AsyncResult async_invoke (const xtl::function<Ret ()>&);
  template <class Ret> friend AsyncResult async_invoke (const xtl::function<Ret ()>&, const xtl::function<void (AsyncResult&)>& callback);
  template <class Ret> friend AsyncResult async_invoke (const xtl::function<Ret ()>&, ActionThread callback_thread, const xtl::function<void (AsyncResult&)>& callback);  
  public:
    typedef xtl::function<void (AsyncResult&)> CallbackHandler;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    AsyncResult  ();
    AsyncResult  (const AsyncResult&);
    ~AsyncResult ();

    AsyncResult& operator = (const AsyncResult&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка выполненности операции / ожидание завершения операции / результат
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsCompleted   () const;
    void WaitCompleted ();

    template <class Ret> typename AsyncResultType<Ret>::Type  Result ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (AsyncResult&);
    
  private:
    struct Impl;
  
    AsyncResult (Impl*);
    AsyncResult (detail::IAsyncAction*);
    AsyncResult (detail::IAsyncAction*, const CallbackHandler&);
    AsyncResult (detail::IAsyncAction*, ActionThread thread, const CallbackHandler&);    
    
    detail::IAsyncResult* Result ();

  private:
    Impl* impl;
};

template <>
AsyncResultType<void>::Type AsyncResult::Result<void> ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (AsyncResult&, AsyncResult&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исключение, возникающее при выполнении асинхронной операции
///////////////////////////////////////////////////////////////////////////////////////////////////
class AsyncException: virtual public xtl::exception
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    AsyncException  ();
    AsyncException  (const std::exception&);
    AsyncException  (const AsyncException&);
    ~AsyncException () throw ();
    
    AsyncException& operator = (const AsyncException&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Переопределение операций xtl::exception
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* what   () const throw ();
    void        vtouch (const char* format, va_list args) throw ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (AsyncException&);
  
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (AsyncException&, AsyncException&);

#include <common/detail/async.inl>

}

#endif
