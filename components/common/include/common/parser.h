#ifndef COMMONLIB_PARSER_HEADER
#define COMMONLIB_PARSER_HEADER

#include <cstdarg>

#include <xtl/exception.h>
#include <xtl/functional_fwd>
#include <xtl/token_iterator.h>

#include <common/parse_iterator.h>

namespace common
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исключения парсера
///////////////////////////////////////////////////////////////////////////////////////////////////
struct ParserException: virtual public xtl::exception {}; //ошибка разбора

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип сообщения протокола парсера
///////////////////////////////////////////////////////////////////////////////////////////////////
enum ParseLogMessageType
{
  ParseLogMessageType_FatalError, //критическая ошибка
  ParseLogMessageType_Error,      //ошибка
  ParseLogMessageType_Warning,    //предупреждение
  
  ParseLogMessageType_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Протокол парсера
///////////////////////////////////////////////////////////////////////////////////////////////////
class ParseLog
{
  public: 
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////  
    ParseLog  ();
    ParseLog  (const ParseLog&);
    ~ParseLog ();
    
    ParseLog& operator = (const ParseLog&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка наличия ошибок и сообщений
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool HasErrors   () const;
    bool HasWarnings () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Протоколирование ошибок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Printf   (ParseLogMessageType type, const char* format, ...);
    void VPrintf  (ParseLogMessageType type, const char* format, va_list list);
    void Error    (const char* file_name, size_t line, const char* format, ...);
    void Warning  (const char* file_name, size_t line, const char* format, ...);
    void Error    (const ParseNode& node, const char* format, ...);
    void Warning  (const ParseNode& node, const char* format, ...);
    void VError   (const char* file_name, size_t line, const char* format, va_list list);
    void VWarning (const char* file_name, size_t line, const char* format, va_list list);
    void VError   (const ParseNode& node, const char* format, va_list list);
    void VWarning (const ParseNode& node, const char* format, va_list list);

    void FatalError  (const char* format, ...);
    void VFatalError (const char* format, va_list list);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перебор сообщений
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t              MessagesCount () const;
    const char*         Message       (size_t index) const;
    ParseLogMessageType MessageType   (size_t index) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Печать сообщений
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (const char*)> LogFunction;

    void Print (const LogFunction&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (ParseLog&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (ParseLog&, ParseLog&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Парсер
///////////////////////////////////////////////////////////////////////////////////////////////////
class Parser
{
  public:
    typedef ParseIterator                        Iterator;
    typedef ParseNamesakeIterator                NamesakeIterator;
    typedef xtl::io::token_iterator<const char*> AttributeIterator;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Parser  (const char* file_name, const char* format = "auto");
    Parser  (const char* name, size_t buffer_size, const char* buffer, const char* format = "auto");
    Parser  (ParseLog& log, const char* file_name, const char* format = "auto");
    Parser  (ParseLog& log, const char* name, size_t buffer_size, const char* buffer, const char* format = "auto");    
    ~Parser ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Протокол разбора
///////////////////////////////////////////////////////////////////////////////////////////////////
    ParseLog&       Log ();
    const ParseLog& Log () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Корень дерева разбора
///////////////////////////////////////////////////////////////////////////////////////////////////
    ParseNode Root () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (Parser&);

  private:
    Parser (const Parser&); //no impl
    Parser& operator = (const Parser&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (Parser&, Parser&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер грамматического разбора
///////////////////////////////////////////////////////////////////////////////////////////////////
class ParserManager
{
  public:
    typedef xtl::function<void (ParseTreeBuilder& builder,
                                ParseLog&         log,
                                const char*       name,
                                size_t            buffer_size, //with '\0'
                                char*             buffer)>               ParseHandler; //buffer always ASCIIZ, read/write
    typedef xtl::function<bool (size_t buffer_size, const char* buffer)> CheckHandler; //buffer always ASCIIZ, read-only, buffer_size with '\0'

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация пользовательских парсеров
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void RegisterParser       (const char* type, const ParseHandler& parser);
    static void RegisterParser       (const char* type, const ParseHandler& parser, const CheckHandler& checker);
    static void UnregisterParser     (const char* type);
    static void UnregisterAllParsers ();
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение потомка с генерацией исключения в случае его отсутствия
///////////////////////////////////////////////////////////////////////////////////////////////////
ParseNode get_first_child (const ParseNode&, const char* name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение итератора атрибутов
///////////////////////////////////////////////////////////////////////////////////////////////////
Parser::AttributeIterator make_attribute_iterator (const ParseNode&);
Parser::AttributeIterator make_attribute_iterator (const ParseNode&, const char* name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Чтение атрибутов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>       bool try_read (const ParseNode&, const char* name, T& object); //nothrow
template <class T>       bool try_read (const ParseNode&, const char* name, T& object, const T& default_value); //nothrow
template <class T>       void read     (const ParseNode&, const char* name, T& object); //throws
template <class OutIter> void read     (const ParseNode&, const char* name, OutIter iter, size_t count); //throws
template <class T>       T    get      (const ParseNode&, const char* name); //throws
template <class T>       T    get      (const ParseNode&, const char* name, const T& default_value); //nothrow

///////////////////////////////////////////////////////////////////////////////////////////////////
///Применение функционала ко всем вложенным узлам
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Fn> void for_each_child (const ParseNode&, Fn fn); //nothrow
template <class Fn> void for_each_child (const ParseNode&, const char* name, Fn fn); //throws only if null-name

///////////////////////////////////////////////////////////////////////////////////////////////////
///Генерация исключения парсера
///////////////////////////////////////////////////////////////////////////////////////////////////
void raise_parser_exception (const ParseNode& node, const char* format, ...);

#include <common/detail/parser.inl>

}

#endif
