#ifndef COMMONLIB_PARSE_TREE_HEADER
#define COMMONLIB_PARSE_TREE_HEADER

#include <stl/auto_ptr.h>
#include <stl/string_fwd>

#include <xtl/functional_fwd>

namespace common
{

//forward declarations
class ParseTree;
class ParseLog;
class ParseTreeBuilder;
class PropertyMap;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Узел грамматического разбора
///////////////////////////////////////////////////////////////////////////////////////////////////
class ParseNode
{
  friend class ParseTreeBuilder;
  typedef bool (ParseNode::*UnspecifiedBoolType)() const;
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    ParseNode  ();
    ParseNode  (const ParseNode&);
    ~ParseNode ();

    ParseNode& operator = (const ParseNode&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Идентификатор
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Id () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsEmpty    () const;
    bool operator ! () const;

    operator UnspecifiedBoolType () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Name () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с атрибутами
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t       AttributesCount () const;
    const char*  Attribute       (size_t index) const;
    const char** Attributes      () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перебор вложенных узлов
///////////////////////////////////////////////////////////////////////////////////////////////////
    ParseNode First () const; //первый потомок
    ParseNode Next  () const; //следующий узел на данном уровне иерархии

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перебор узлов по имени
///////////////////////////////////////////////////////////////////////////////////////////////////
    ParseNode First (const char* name) const; //первый потомок с указанным именем
    ParseNode Next  (const char* name) const; //следующий узел на данном уровне иерархии с указанным именем

    ParseNode NextNamesake () const; //следующий "тёзка" на данном уровне иерархии

///////////////////////////////////////////////////////////////////////////////////////////////////
///Информация о расположении узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Source     () const; //имя исходного текста,  в котором расположен узел
    size_t      LineNumber () const; //номер строки

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединённый протокол разбора
///////////////////////////////////////////////////////////////////////////////////////////////////
    ParseLog Log () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (ParseNode&);

  private:
    ParseNode (ParseTree* tree, size_t offset);

  private:
    ParseTree* tree;
    size_t     offset;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (ParseNode&, ParseNode&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Класс, предназначенный для построения дерева грамматического разбора
///////////////////////////////////////////////////////////////////////////////////////////////////
class ParseTreeBuilder
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    ParseTreeBuilder  ();
    ParseTreeBuilder  (const ParseTreeBuilder&);
    ~ParseTreeBuilder ();

    ParseTreeBuilder& operator = (const ParseTreeBuilder&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Информация о контексте
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* NodeName             () const; //имя текущего узла
    size_t      NodeDepth            () const; //уровень вложенности узлов (корень на нулевом уровне)
    size_t      TotalNodesCount      () const; //общее количество узлов
    size_t      TotalAttributesCount () const; //общее количество атрибутов
    size_t      BufferSize           () const; //использованный размер буфера разбора
    size_t      BufferCapacity       () const; //зарезервированый размер буфера разбора

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя текущего разбираемого исходного текста
///////////////////////////////////////////////////////////////////////////////////////////////////
    void        SetSource (const char* name);
    const char* Source    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Определение границ узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BeginNode (const char* name);
    void BeginNode (const char* name, size_t line_number);
    void EndNode   ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление атрибутов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddAttribute  (const char* value);
    void AddAttributes (size_t count, const char** values);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Резервирование буфера разбора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void ReserveBuffer (size_t size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Завершение построения
///////////////////////////////////////////////////////////////////////////////////////////////////
    ParseNode Build ();
    ParseNode Build (const ParseLog&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (ParseTreeBuilder&);

  private:
    ParseNode BuildCore (const ParseLog*);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (ParseTreeBuilder&, ParseTreeBuilder&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Разрешение ссылок в дереве разбора
///////////////////////////////////////////////////////////////////////////////////////////////////
ParseNode resolve_references (const ParseNode& source_tree, const xtl::function<void (const char* reference_name, stl::string& reference_value)>& resolver);
ParseNode resolve_references (const ParseNode& source_tree, const ParseNode& reference_values);
ParseNode resolve_references (const ParseNode& source_tree, const PropertyMap& reference_values);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Объединение деревьев
///////////////////////////////////////////////////////////////////////////////////////////////////
ParseNode concat (size_t nodes_count, const ParseNode* nodes);
ParseNode concat (const ParseNode& node1, const ParseNode& node2);

}

#endif
