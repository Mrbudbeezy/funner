#ifndef COMMONLIB_THREAD_HEADER
#define COMMONLIB_THREAD_HEADER

#include <stl/auto_ptr.h>
#include <xtl/functional_fwd>

namespace common
{

//implementation forwards
struct CurrentThreadHolder;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Константы
///////////////////////////////////////////////////////////////////////////////////////////////////
const int THREAD_CANCELED_EXIT_CODE = -1; //од завершения сброшенной нити

///////////////////////////////////////////////////////////////////////////////////////////////////
///Нить
///////////////////////////////////////////////////////////////////////////////////////////////////
class Thread
{
  friend struct CurrentThreadHolder;
  public:
    typedef xtl::function<int ()> Function;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    Thread  (const Function& thread_function);
    Thread  (const char* name, const Function& thread_function);
    ~Thread ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя нити
///////////////////////////////////////////////////////////////////////////////////////////////////
//    const char* Name () const; //сделать возвращение объекта с подсчётом ссылок, иначе нить может удалиться, оставив badptr

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отмена нити
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Cancel ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ожидание завершения нити
///////////////////////////////////////////////////////////////////////////////////////////////////
    int Join (); //return exit code

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение текущей нити
///////////////////////////////////////////////////////////////////////////////////////////////////
    static Thread& GetCurrent ();
    
  private:
    struct Impl;

    Thread ();
    Thread  (const Thread&); //no impl
    Thread& operator = (const Thread&); //no impl

  private:
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Локальные данные нити
///////////////////////////////////////////////////////////////////////////////////////////////////
class ThreadLocalStorage
{
  public:
    typedef xtl::function<void (void* data)> CleanupHandler;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ThreadLocalStorage  ();
    ThreadLocalStorage  (const CleanupHandler& cleanup);
    ThreadLocalStorage  (void (*cleanup)(void*));
    ~ThreadLocalStorage ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / чтение данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void  SetValue (void* data);
    void* GetValue () const;

  private:
    ThreadLocalStorage (const ThreadLocalStorage&); //no impl
    ThreadLocalStorage& operator = (const ThreadLocalStorage&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Типизированный указатель на локальные данные нити
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> class ThreadLocalPointer
{
  public:
    typedef xtl::function<void (T* data)> CleanupHandler;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ThreadLocalPointer ();
    ThreadLocalPointer (const CleanupHandler& cleanup);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    T* Get         () const;
    T* operator -> () const;
    T& operator *  () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс указателя
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Reset (T* new_object); //????

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс указателя без очищения данных (вызова cleanup)
///////////////////////////////////////////////////////////////////////////////////////////////////
    T* Release ();

  private:
    ThreadLocalPointer (const ThreadLocalPointer&); //no impl
    ThreadLocalPointer& operator = (const ThreadLocalPointer&); //no impl
    
  private:
    ThreadLocalStorage storage;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исключающий семафор
///////////////////////////////////////////////////////////////////////////////////////////////////
class Mutex
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Mutex  ();
    ~Mutex ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Блокирование доступа
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool TryLock ();
    void Lock    ();
    void Lock    (size_t wait_in_milliseconds);
    void Unlock  ();

  private:
    Mutex  (const Mutex&); //no impl
    Mutex& operator = (const Mutex&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Семафор
///////////////////////////////////////////////////////////////////////////////////////////////////
class Semaphore
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Semaphore  ();
    ~Semaphore ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ожидание новой задачи / посылка новой задачи
///  возвращают количество задач, ожидающих выполнения
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Wait    ();
    size_t TryWait ();
    size_t Post    ();

  private:
    Semaphore  (const Semaphore&); //no impl
    Semaphore& operator = (const Semaphore&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Условие работы кода нити
///////////////////////////////////////////////////////////////////////////////////////////////////
class ThreadCondition
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ThreadCondition  ();
    ~ThreadCondition ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Посылка оповещения об изменении условия
///////////////////////////////////////////////////////////////////////////////////////////////////
    void NotifyOne ();
    void NotifyAll ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ожидание изменения условия
///////////////////////////////////////////////////////////////////////////////////////////////////
                          void Wait (Mutex& lock);
    template <class Pred> void Wait (Mutex& lock, Pred pred);

  private:
    ThreadCondition  (const ThreadCondition&); //no impl
    ThreadCondition& operator = (const ThreadCondition&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Блок захвата ресурсов нитью
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> class ThreadLockScope
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ThreadLockScope  (T& object);
    ~ThreadLockScope ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Упрощение однострочного доступа
///////////////////////////////////////////////////////////////////////////////////////////////////
    T* Get         () const;
    T* operator -> () const;

  private:
    ThreadLockScope (const ThreadLockScope&); //no impl
    ThreadLockScope& operator = (const ThreadLockScope&); //no impl

  private:
    T* object;
};

#include <common/detail/thread.inl>

}

#endif
