#ifndef COMMONLIB_THREAD_HEADER
#define COMMONLIB_THREAD_HEADER

#include <xtl/functional_fwd>

namespace common
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние нити
///////////////////////////////////////////////////////////////////////////////////////////////////
enum ThreadState
{
  ThreadState_Suspended, //нить приостановлена
  ThreadState_Worked,    //нить работает
  ThreadState_Exited,    //нить завершила работу  
  
  ThreadState_Num,
  
  ThreadState_DefaultInitialState = ThreadState_Suspended,
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Нить
///////////////////////////////////////////////////////////////////////////////////////////////////
class Thread
{
  public:
    typedef xtl::function<int ()> Function;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    Thread  ();
    Thread  (const Function& thread_function, ThreadState initial_state = ThreadState_DefaultInitialState);
    Thread  (const char* name, const Function& thread_function, ThreadState initial_state = ThreadState_DefaultInitialState);
    Thread  (const Thread&);
    ~Thread ();

    Thread& operator = (const Thread&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя нити
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Name () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление состоянием выполнения
///////////////////////////////////////////////////////////////////////////////////////////////////
    ThreadState State () const;
    void        SetState (ThreadState state);
    void        Suspend () { SetState (ThreadState_Suspended); } //приостановка выполнения нити
    void        Resume  () { SetState (ThreadState_Worked); }    //продолжение выполнения нити
    void        Kill    () { SetState (ThreadState_Exited); }    //принудительное завершение работы нити

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ожидание завершения нити
///////////////////////////////////////////////////////////////////////////////////////////////////
    int Join (); //return exit code

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (Thread&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (Thread&, Thread&);

}

#endif
