#ifndef COMMONLIB_STREAMS_HEADER
#define COMMONLIB_STREAMS_HEADER

#include <stl/auto_ptr.h>
#include <xtl/functional_fwd>
#include <xtl/common_exceptions.h>

namespace stl
{

//forward declaration
template <class Char, class Traits, class Allocator> class basic_string;

}

namespace xtl
{

//forward declaration
template <class FwdIter> class iterator_range;

}

namespace math
{

//forward declarations
template <class T, unsigned int Size> class vector;
template <class T, unsigned int Size> class matrix;
template <class T>                    class quat;

}

namespace common
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер потоков вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
class OutputStreamBuffer
{
  public:
    enum { DEFAULT_BUFFER_SIZE = 8192 };

    typedef xtl::function<size_t (const void* buffer, size_t buffer_size)> WriteFunction;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    explicit OutputStreamBuffer  (size_t buffer_size = DEFAULT_BUFFER_SIZE);
    explicit OutputStreamBuffer  (const WriteFunction& writer, size_t buffer_size = DEFAULT_BUFFER_SIZE);
             ~OutputStreamBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Запись
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Write (const void* buffer, size_t size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление размером буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Size   () const;
    void   Resize (size_t buffer_size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединение пользовательского буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUserBuffer (void* buffer, size_t size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Функция записи данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                 SetWriter (const WriteFunction&);
    const WriteFunction& Writer    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Функция записи данных по умолчанию
///////////////////////////////////////////////////////////////////////////////////////////////////
    static size_t DefaultWriter (const void* buffer, size_t size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Flush ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (OutputStreamBuffer&);

  private:
    OutputStreamBuffer (const OutputStreamBuffer&); //no impl
    OutputStreamBuffer& operator = (const OutputStreamBuffer&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (OutputStreamBuffer&, OutputStreamBuffer&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер потоков ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputStreamBuffer
{
  public:
    enum { DEFAULT_BUFFER_SIZE = 8192 };

    typedef xtl::function<size_t (void* buffer, size_t buffer_size)> ReadFunction;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    explicit InputStreamBuffer  (size_t buffer_size = DEFAULT_BUFFER_SIZE);
    explicit InputStreamBuffer  (const ReadFunction& reader, size_t buffer_size = DEFAULT_BUFFER_SIZE);
             ~InputStreamBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Чтение
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Read (void* buffer, size_t size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление размером буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Size   () const;
    void   Resize (size_t buffer_size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединение пользовательского буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUserBuffer (void* buffer, size_t size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Функция чтения данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                SetReader (const ReadFunction&);
    const ReadFunction& Reader    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Функция чтения данных по умолчанию
///////////////////////////////////////////////////////////////////////////////////////////////////
    static size_t DefaultReader (void* buffer, size_t size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (InputStreamBuffer&);

  private:
    InputStreamBuffer (const InputStreamBuffer&); //no impl
    InputStreamBuffer& operator = (const InputStreamBuffer&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (InputStreamBuffer&, InputStreamBuffer&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исключение: невозможно записать в поток
///////////////////////////////////////////////////////////////////////////////////////////////////
struct StreamWriteException: virtual public xtl::exception {};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текстовый поток вывода (выход потока в UTF8)
///////////////////////////////////////////////////////////////////////////////////////////////////
class OutputTextStream
{
  public:
    typedef OutputStreamBuffer::WriteFunction WriteFunction;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    explicit OutputTextStream  (size_t buffer_size = OutputStreamBuffer::DEFAULT_BUFFER_SIZE);
    explicit OutputTextStream  (const WriteFunction& writer, size_t buffer_size = OutputStreamBuffer::DEFAULT_BUFFER_SIZE);
             ~OutputTextStream ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер потока
///////////////////////////////////////////////////////////////////////////////////////////////////
    const OutputStreamBuffer& Buffer () const;
          OutputStreamBuffer& Buffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вывод строк (базовая гарантия исключений)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Write (const char* string);
    void Write (const char* string, size_t length);
    void Write (const wchar_t* string);
    void Write (const wchar_t* string, size_t length);

  private:
    OutputTextStream (const OutputTextStream&); //no impl
    OutputTextStream& operator = (const OutputTextStream&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вывод строк
///////////////////////////////////////////////////////////////////////////////////////////////////
void write (OutputTextStream&, const char* string);
void write (OutputTextStream&, const wchar_t* string);

template <class Traits, class Allocator>
void write (OutputTextStream&, const stl::basic_string<char, Traits, Allocator>&);

template <class Traits, class Allocator>
void write (OutputTextStream&, const stl::basic_string<wchar_t, Traits, Allocator>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вывод символов
///////////////////////////////////////////////////////////////////////////////////////////////////
void write (OutputTextStream&, char symbol);
void write (OutputTextStream&, wchar_t symbol);
void write (OutputTextStream&, size_t count, char symbol);
void write (OutputTextStream&, size_t count, wchar_t symbol);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вывод целых чисел
///  format:
///    ""      - вывод с форматированием по умолчанию
///    "hex"   - вывод в шестнадцатиричном формате
///    "#"     - вывод с заполнителем по умолчанию (' ') и шириной не меньше 1
///    "000"   - вывод с заполнителем 0 и шириной 3
///    "+##"   - вывод с заполнителем по умолчанию, шириной 3 и указанием знака
///    "hex:#" - вывод с заполнителем по умолчанию, шириной 1 в шастнадцатиричном формате
///////////////////////////////////////////////////////////////////////////////////////////////////
    //сделать проверку формата!!!
void write (OutputTextStream&, int value, const char* format="");
void write (OutputTextStream&, long value, const char* format="");
void write (OutputTextStream&, long long value, const char* format="");
void write (OutputTextStream&, unsigned int value, const char* format="");
void write (OutputTextStream&, unsigned long value, const char* format="");
void write (OutputTextStream&, unsigned long long value, const char* format="");

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вывод чисел с плавающей точкой
///  format (аналогично целым числам, исключая системы счисления):
///    отсутствие точки - печать дробной части с форматированием по умолчанию
///    ".##" - ширина не больше 2-х (1.2=1.2, 1.211=1.21)
///    ".00" - ширина 2 (1.2=1.20, 1.211=1.21)
///////////////////////////////////////////////////////////////////////////////////////////////////
    //сделать проверку формата!!!
void write (OutputTextStream&, float value, const char* format="");
void write (OutputTextStream&, double value, const char* format="");
void write (OutputTextStream&, long double value, const char* format="");

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вывод логических значений
///  format:
///    "alpha" - вывод в текстовом виде (true, false)
///    ""      - вывод в численном виде (0, 1)
///////////////////////////////////////////////////////////////////////////////////////////////////
void write (OutputTextStream&, bool value, const char* format);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сериализация математических типов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, unsigned int size>
void write (OutputTextStream&, const math::vector<T, size>& value, const char* format="");

template <class T, unsigned int size>
void write (OutputTextStream&, const math::matrix<T, size>& value, const char* format="");

template <class T>
void write (OutputTextStream&, const math::quat<T>& value, const char* format="");

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вывод интервалов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class InIter>
void write_range (OutputTextStream&, InIter first, InIter last);

template <class InIter>
void write_range (OutputTextStream&, InIter first, InIter last, const char* format);

template <class FwdIter>
void write (OutputTextStream&, const xtl::iterator_range<FwdIter>&);

template <class FwdIter>
void write (OutputTextStream&, const xtl::iterator_range<FwdIter>&, const char* format);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Бинарный поток вывода с учётом порядка следования байтов
///////////////////////////////////////////////////////////////////////////////////////////////////

#include <common/detail/streams.inl>

}

#endif
