#ifndef COMMONLIB_SINGLEON_HEADER
#define COMMONLIB_SINGLEON_HEADER

#include <new>
#include <stl/stdexcept>
#include <stdlib.h>

namespace common
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Распределение памяти для синглтона при помощи new/delete
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> struct SingletonCreateUsingNew
{
  static T*   Create  ();
  static void Destroy (T*);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Распределение памяти для синглтона при помощи malloc/free
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> struct SingletonCreateUsingMalloc
{
  static T*   Create  ();
  static void Destroy (T*);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Размещение синглтона в статической памяти
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> struct SingletonStatic
{
  static T*   Create  ();
  static void Destroy (T*);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Узел списка синглтонов
///////////////////////////////////////////////////////////////////////////////////////////////////
class SingletonListNode
{
  template <class T,template <class> class CreateaionPolicy> friend class Singleton;
  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация активных синглтонов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RegisterSingleton   (void (*destroy_function)());
    void UnregisterSingleton ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Уничтожение всех синглтонов
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void DestroyAll ();

  private:  
    SingletonListNode*        prev;
    SingletonListNode*        next;
    void                      (*destroy_function)();
    static SingletonListNode* first;
    static bool               atexit_registered;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Класс поддержки объекта - одиночки
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T,template <class> class CreateaionPolicy=SingletonStatic>
class Singleton
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение экземпляра
///////////////////////////////////////////////////////////////////////////////////////////////////
    static T& Instance ();
    static T* InstancePtr () { return &Instance (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Явная инициализация и уничтожение экземпляра
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void Init    ();
    static void Destroy ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка доступности экземпляра
///////////////////////////////////////////////////////////////////////////////////////////////////
    static bool IsInitialized ();

  private:
    Singleton ();

  private:
    static T*                instance;
    static SingletonListNode node;
    static bool              is_in_init;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Экземпляр синглтона
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T,template <class> class CreateaionPolicy>
T* Singleton<T,CreateaionPolicy>::instance = 0;

template <class T,template <class> class CreateaionPolicy>
SingletonListNode Singleton<T,CreateaionPolicy>::node;

template <class T,template <class> class CreateaionPolicy>
bool Singleton<T,CreateaionPolicy>::is_in_init = false;

#include <common/detail/singleton.inl>

}

#endif
