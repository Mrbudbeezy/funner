#ifndef RENDER_SCENE_RENDER_HEADER
#define RENDER_SCENE_RENDER_HEADER

#include <stl/auto_ptr.h>
#include <xtl/functional_fwd>

#include <mathlib.h>

#include <render/screen.h>

namespace media
{

//forward declaration
class Image;

}

namespace render
{

//forward declaration
class IRenderTargetImpl;
class RenderTargetManager;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Целевые буферы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
enum RenderTargetAttachment
{
  RenderTargetAttachment_DepthStencil, //буфер попиксельного отсечения
  RenderTargetAttachment_Color,        //буфер цвета

  RenderTargetAttachment_Num  
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Цель рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderTarget
{
  friend class SceneRender;
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTarget  ();
    RenderTarget  (const RenderTarget&); //политика копирования - подсчёт ссылок
    ~RenderTarget ();

    RenderTarget& operator = (const RenderTarget&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Идентификатор цели рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Id () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имена ассоциированных буферов
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Attachment (RenderTargetAttachment buffer_id) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Границы логически отображаемой области рабочего стола
///////////////////////////////////////////////////////////////////////////////////////////////////
    void        SetScreenArea (const Rect& rect);
    void        SetScreenArea (int left, int top, size_t width, size_t height);
    const Rect& ScreenArea    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Физические границы визуализируемой области (например, в оконных координатах)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void        SetRenderableArea (const Rect& rect);
    void        SetRenderableArea (int left, int top, size_t width, size_t height);
    const Rect& RenderableArea    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рабочий стол (политика владения - weak-ref)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                  SetScreen (render::Screen* screen);
    render::Screen*       Screen    ();
    const render::Screen* Screen    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Update ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Захват изображения (screen-shot)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void CaptureImage (media::Image&);
    void CaptureImage (const char* image_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (RenderTarget&);
    
  private:
    RenderTarget (RenderTargetManager&, const char*, const char*);
    RenderTarget (IRenderTargetImpl*);

  private:
    IRenderTargetImpl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (RenderTarget&, RenderTarget&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рендер сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class SceneRender
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SceneRender  ();
    SceneRender  (const char* driver_name_mask, const char* renderer_name_mask, const char* render_path_masks="*");
    ~SceneRender ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / сброс системы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetRenderer (const char* driver_name_mask,          //маска имени драйвера системы рендеринга
                      const char* renderer_name_mask,        //маска имени системы рендеринга в драйвере
                      const char* render_path_masks = "*");  //список масок имён требуемых путей рендеринга (разделитель - пробел)
    void ResetRenderer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение параметров текущей системы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* RendererDescription () const; //описание системы рендеринга
    const char* RenderPaths         () const; //список доступных путей рендеринга
    bool        HasRenderPath       (const char* name) const; //проверка доступности указанного пути рендеринга

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание цели рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTarget CreateRenderTarget (const char* color_attachment_name, const char* depth_stencil_attachment_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перебор доступных целей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t               RenderTargetsCount () const;
    render::RenderTarget RenderTarget       (size_t index) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка функции отладочного протоколирования
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (const char* message)> LogFunction;

    void               SetLogHandler (const LogFunction&);
    const LogFunction& LogHandler    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с ресурсами
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadResource (const char* tag, const char* file_name);
    void LoadResource (const char* file_name) { LoadResource ("auto", file_name); }

  private:
    SceneRender (const SceneRender&); //no impl
    SceneRender& operator = (const SceneRender&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

}

#endif
