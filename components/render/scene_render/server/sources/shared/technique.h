#ifndef RENDER_SCENE_SERVER_TECHNIQUE_SHARED_HEADER
#define RENDER_SCENE_SERVER_TECHNIQUE_SHARED_HEADER

#include <cstring>
#include <new>
#include <typeinfo>

#include <stl/auto_ptr.h>

#include <xtl/exception.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/reference_counter.h>

#include <shared/sg/traverse_result.h>

namespace common
{

//forward declarations
class ParseNode;
class PropertyMap;
class PropertyBindingMap;

}

namespace render
{

namespace manager
{

//forward declarations
class Frame;

}

namespace scene
{

namespace server
{

//forward declarations
class RenderManager;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Данные техники
///////////////////////////////////////////////////////////////////////////////////////////////////
class TechniquePrivateData
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    TechniquePrivateData  ();
    TechniquePrivateData  (const TechniquePrivateData&);
    ~TechniquePrivateData ();

    TechniquePrivateData& operator = (const TechniquePrivateData&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T>       T& Get ();
    template <class T> const T& Get () const;

  private:
    void RaiseSizeError (const std::type_info&, size_t size);

  private:
    enum { DATA_BUFFER_SIZE = 256 };

    struct ITypeInfo;

    template <class T> struct TypeInfoImpl;

  private:
    char       buffer [DATA_BUFFER_SIZE];
    ITypeInfo* type_info;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контекст рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderingContext
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderingContext (manager::Frame& frame, server::RenderManager& render_manager, ITraverseResultCache& traverse_result_cache);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текущий кадр
///////////////////////////////////////////////////////////////////////////////////////////////////
    manager::Frame& Frame () { return frame; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Результат обхода
///////////////////////////////////////////////////////////////////////////////////////////////////
    server::TraverseResult& TraverseResult ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    server::RenderManager& RenderManager ();

  private:
    RenderingContext (const RenderingContext&); //no implementation
    RenderingContext& operator = (const RenderingContext&); //no implementation

  private:
    manager::Frame&         frame;
    server::RenderManager&  render_manager;
    server::TraverseResult* traverse_result;
    ITraverseResultCache&   traverse_result_cache;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Техника рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class Technique: public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
            Technique  ();
    virtual ~Technique ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя техники
///////////////////////////////////////////////////////////////////////////////////////////////////
    void        SetName (const char* name);
    const char* Name    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Свойства рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                       SetProperties (const common::PropertyMap&);
    const common::PropertyMap& Properties    () const;
          common::PropertyMap& Properties    ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateFrame (RenderingContext& context, TechniquePrivateData& private_data);
    
  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка свойств по умолчанию
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                       SetDefaultProperties (const common::PropertyMap& properties);
    void                       SetDefaultProperties (const common::ParseNode& node);
    const common::PropertyMap& DefaultProperties    ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Связывание свойств техники с методами техники
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void BindProperties (common::PropertyBindingMap&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отрисовка массива отображаемых моделей
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw (RenderingContext& context, size_t visual_models_count, VisualModel* const* models) const;
    void Draw (RenderingContext& context, const stl::vector<VisualModel*>& models) const;

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void UpdateFrameCore (RenderingContext&, TechniquePrivateData&) = 0;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление свойств
///////////////////////////////////////////////////////////////////////////////////////////////////
            void UpdateProperties     ();
    virtual void UpdatePropertiesCore () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение свойств
///////////////////////////////////////////////////////////////////////////////////////////////////

  private:
    Technique (const Technique&); //no implementation
    Technique& operator = (const Technique&); //no implementation

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

typedef xtl::intrusive_ptr<Technique> TechniquePtr;

#include <shared/detail/technique.inl>

}

}

}

#endif
