#include <stl/string>

#include <xtl/common_exceptions.h>
#include <xtl/bind.h>
#include <xtl/function.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/reference_counter.h>
#include <xtl/trackable.h>

#include <common/property_map.h>
#include <common/strlib.h>

#include <syslib/thread.h>

#include <render/scene_render_server.h>

#include <render/scene/interchange/connection_manager.h>
#include <render/scene/interchange/context.h>
#include <render/scene/interchange/render_thread.h>
#include <render/scene/interchange/serializer.h>

#include <shared/server.h>

namespace render
{

namespace scene
{

namespace server
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Внутренние команды сервера
///////////////////////////////////////////////////////////////////////////////////////////////////
enum InternalCommandId
{
  InternalCommandId_OnSizeChanged = interchange::CommandId_FirstUserDefined,
  InternalCommandId_OnViewportChanged,
  InternalCommandId_OnHandleChanged,
  InternalCommandId_OnPaint,
};

typedef interchange::Context<interchange::ServerToClientSerializer, interchange::ClientToServerDeserializer> Context;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Объект принимающий входящие подключения рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class ConnectionAcceptor
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ConnectionAcceptor  (const char* name, ServerImpl& server, ServerThreadingModel model);
    ~ConnectionAcceptor ();

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние соединения
///////////////////////////////////////////////////////////////////////////////////////////////////
class ConnectionState: public xtl::noncopyable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ConnectionState  ();
    ~ConnectionState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Команды клиента
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadResource (const char*);
    void UnloadResource (const char*);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Соединение с клиентом
///////////////////////////////////////////////////////////////////////////////////////////////////
class Connection: public interchange::IConnection, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Connection  (ServerImpl& server, const char* init_string); //must be thread neutral
    ~Connection ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рендер сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    ServerImpl& Server ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контекст
///////////////////////////////////////////////////////////////////////////////////////////////////
    server::Context& Context ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние соединения
///////////////////////////////////////////////////////////////////////////////////////////////////
    ConnectionState& State ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработка входного потока данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void ProcessCommands (const interchange::CommandBuffer& commands);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение события оповещения об удалении
///////////////////////////////////////////////////////////////////////////////////////////////////
    xtl::trackable& GetTrackable ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчет ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddRef  ();
    void Release ();

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;  
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исходящее соединение от сервера к серверу
///////////////////////////////////////////////////////////////////////////////////////////////////
class OutputServerLoopbackConnection: public xtl::noncopyable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    OutputServerLoopbackConnection  (const char* name);
    ~OutputServerLoopbackConnection ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сообщения серверу
///////////////////////////////////////////////////////////////////////////////////////////////////
    void OnSizeChanged     (size_t width, size_t height);
    void OnViewportChanged (size_t left, size_t top, size_t right, size_t bottom);
    void OnHandleChanged   (void* handle);
    void OnPaint           ();

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

}

}

}
