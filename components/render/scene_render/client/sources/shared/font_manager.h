#ifndef RENDER_SCENE_CLIENT_FONT_MANAGER_SHARED_HEADER
#define RENDER_SCENE_CLIENT_FONT_MANAGER_SHARED_HEADER

#include <stl/auto_ptr.h>

#include <xtl/shared_ptr.h>

namespace media
{

//forward declarations
class  Font;
struct FontCreationParams;
struct RasterizedFontCreationParams;

}

namespace render
{

namespace scene
{

namespace client
{

//forward declarations
class  MaterialManager;
struct FontRenderingTempCache;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Информация о растеризованном глифе
///////////////////////////////////////////////////////////////////////////////////////////////////
struct RasterizedGlyphInfo
{
  unsigned short image_index; //индекс изображения в шрифте
  math::vec2f    tex_offset;  //смещение в текстуре
  math::vec2f    tex_size;    //размер в текстуре
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Шрифт
///////////////////////////////////////////////////////////////////////////////////////////////////
class Font: public xtl::reference_counter, public xtl::trackable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Font  (MaterialManager& material_manager, const media::Font& font, const media::RasterizedFontCreationParams& creation_params);
    ~Font ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя шрифта
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Name ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Размер таблицы глифов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GlyphsCount ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Код первого глифа
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t FirstGlyphCode ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Растеризованные глифы
///////////////////////////////////////////////////////////////////////////////////////////////////
    const RasterizedGlyphInfo* RasterizedGlyphs ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество текстур
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t TexturesCount ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение имени текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* TextureName (size_t texture_index);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

typedef xtl::intrusive_ptr<Font> FontPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Материал шрифта
///////////////////////////////////////////////////////////////////////////////////////////////////
class FontMaterial: public xtl::reference_counter, public xtl::trackable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FontMaterial  (MaterialManager& material_manager, const FontPtr& font, const char* material_name, const char* semantic);
    ~FontMaterial ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Шрифт
///////////////////////////////////////////////////////////////////////////////////////////////////
    client::Font& Font ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество материалов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t MaterialsCount ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение имени материала
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* MaterialName (size_t material_index);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

typedef xtl::intrusive_ptr<FontMaterial>        FontMaterialPtr;
typedef xtl::shared_ptr<FontRenderingTempCache> FontRenderingTempCachePtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер шрифтов
///////////////////////////////////////////////////////////////////////////////////////////////////
class FontManager: public xtl::noncopyable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FontManager  (MaterialManager&);
    ~FontManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание шрифта / материала шрифта
///////////////////////////////////////////////////////////////////////////////////////////////////
    FontPtr         CreateFont         (const media::Font&);
    FontMaterialPtr CreateFontMaterial (const media::Font&, const char* material, const char* semantic);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединение библиотеки шрифтов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AttachFontLibrary      (const media::FontLibrary&);
    void DetachFontLibrary      (const media::FontLibrary&);
    void DetachAllFontLibraries ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Предварительный рендеринг шрифтов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadFont   (const char* id, const char* name, const media::FontCreationParams& params, const char* material, const char* semantic);
    void LoadFont   (const char* init_string);
    void UnloadFont (const char* id);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка соответствия имени ресурса параметрам настройки кэша шрифтов
///////////////////////////////////////////////////////////////////////////////////////////////////
    static bool IsFontParams (const char* resource);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Кэш рендеринга шрифтов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                             SetFontRenderingTempCache (const FontRenderingTempCachePtr&);
    const FontRenderingTempCachePtr& FontRenderingTempCache    () const;

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

}

}

}

#endif
