#ifndef RENDER_SCENE_CLIENT_MATERIAL_MANAGER_SHARED_HEADER
#define RENDER_SCENE_CLIENT_MATERIAL_MANAGER_SHARED_HEADER

#include <stl/auto_ptr.h>

#include <shared/types.h>

namespace render
{

namespace scene
{

namespace client
{

//forward declarations
class ClientImpl;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Материал
///////////////////////////////////////////////////////////////////////////////////////////////////
class Material: public xtl::reference_counter, public xtl::noncopyable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Material  (Context& context, const char* name, const char* prototype, bool remove_on_destroy);
    ~Material ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Name ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление текстурной карты на стороне сервера (копии на стороне клиента не сохраняются)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetTexmapImage   (const char* semantic, const char* image_name);
    void SetTexmapSampler (const char* semantic, const char* sampler);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;  
};

typedef xtl::intrusive_ptr<Material> MaterialPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture: public xtl::reference_counter, public xtl::noncopyable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture  (Context& context, const char* name, bool remove_on_destroy);
    ~Texture ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Name ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Update (const media::Image&);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

typedef xtl::intrusive_ptr<Texture> TexturePtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер материалов
///////////////////////////////////////////////////////////////////////////////////////////////////
class MaterialManager: public xtl::noncopyable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    MaterialManager  (ClientImpl& client, Context& context);
    ~MaterialManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    MaterialPtr CreateMaterial (const char* name, const char* prototype, bool remove_on_destroy = true);    
    TexturePtr  CreateTexture  (const char* name, bool remove_on_destroy = true);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

}

}

}

#endif
