#include <stl/auto_ptr.h>
#include <stl/vector>

#include <xtl/array>
#include <xtl/bind.h>
#include <xtl/common_exceptions.h>
#include <xtl/function.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/reference_counter.h>
#include <xtl/trackable_ptr.h>

#include <common/property_map.h>
#include <common/strlib.h>
#include <common/time.h>

#include <media/image.h>

#include <syslib/condition.h>

#include <render/scene_render_client.h>

#include <render/scene/interchange/command_queue.h>
#include <render/scene/interchange/connection_manager.h>
#include <render/scene/interchange/context.h>
#include <render/scene/interchange/serializer.h>

namespace render
{

namespace scene
{

namespace client
{

typedef interchange::Context<interchange::ClientToServerSerializer, interchange::ServerToClientDeserializer> Context;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип синхронизируемого объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
enum ObjectType
{
  ObjectType_Viewport,
  ObjectType_RenderTarget,

  ObjectType_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация рендера сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class ClientImpl: public xtl::noncopyable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ClientImpl  ();
    ~ClientImpl ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Выделение идентификаторов
///////////////////////////////////////////////////////////////////////////////////////////////////
    interchange::uint32 AllocateId   (ObjectType type);
    void                DeallocateId (ObjectType type, interchange::uint32 id);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработчики ответов сервера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Dummy ();

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Соединение с сервером
///////////////////////////////////////////////////////////////////////////////////////////////////
class Connection: public xtl::noncopyable, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Connection  (const char* connection_name, const char* init_string, size_t logon_timeout_ms);
    ~Connection ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание соединения
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Description ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рендер сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    ClientImpl& Client ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контекст
///////////////////////////////////////////////////////////////////////////////////////////////////
    client::Context& Context ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ожидание ответа от сервера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void WaitServerFeedback    ();
    bool TryWaitServerFeedback (size_t timeout_ms);

  private:
    struct Impl;
    Impl* impl;  
};

typedef xtl::intrusive_ptr<Connection> ConnectionPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализации цели отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderTargetImpl: public xtl::noncopyable, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTargetImpl  (const ConnectionPtr& connection, const char* render_target_name);
    ~RenderTargetImpl ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Экран (политика владения - weak-ref)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                 SetScreen (scene_graph::Screen* screen);
    scene_graph::Screen* Screen    ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Update ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Захват изображения (screen-shot)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void CaptureImage (media::Image&);
    void CaptureImage (const char* image_name);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

typedef xtl::intrusive_ptr<RenderTargetImpl> RenderTargetPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Область вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderableView: public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderableView  (const ConnectionPtr& connection, scene_graph::Viewport& viewport);
    ~RenderableView ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Идентификатор
///////////////////////////////////////////////////////////////////////////////////////////////////
    interchange::uint8 Id ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Область вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    const scene_graph::Viewport& Viewport ();   

///////////////////////////////////////////////////////////////////////////////////////////////////
///Синхронизация с сервером
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Synchronize ();

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

typedef xtl::intrusive_ptr<RenderableView> RenderableViewPtr;

}

}

}
