#ifndef RENDER_SCENE_COMMAND_QUEUE_HEADER
#define RENDER_SCENE_COMMAND_QUEUE_HEADER

#include <render/scene/interchange/command_buffer.h>

namespace render
{

namespace scene
{

namespace interchange
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Очередь команд
///////////////////////////////////////////////////////////////////////////////////////////////////
class CommandQueue
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    CommandQueue  (size_t max_queue_size);
    ~CommandQueue ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Размер очереди / проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Size    () const;
    bool   IsEmpty () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Помещение элемента в очередь / извлечение из очереди
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Push (const CommandBuffer& buffer);
    bool Pop  (CommandBuffer& buffer, size_t timeout = size_t (-1));

  private:
    CommandQueue (const CommandQueue&); //no impl
    CommandQueue& operator = (const CommandQueue&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

}

}

}

#endif
