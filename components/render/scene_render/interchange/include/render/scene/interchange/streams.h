#ifndef RENDER_SCENE_INTERCHANGE_STREAMS_HEADER
#define RENDER_SCENE_INTERCHANGE_STREAMS_HEADER

#include <xtl/common_exceptions.h>

#include <render/scene/interchange/command_buffer.h>

namespace render
{

namespace scene
{

namespace interchange
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Выходной поток сериализации
///////////////////////////////////////////////////////////////////////////////////////////////////
class OutputStream
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    OutputStream  (const CommandBuffer&);
    ~OutputStream ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сериализация заголовка и конца команды
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BeginCommand (command_id_t);
    void EndCommand   ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подготовка достаточного места в буфере для записи
///////////////////////////////////////////////////////////////////////////////////////////////////
    void EnsureSpaceAvailable (size_t size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Запись поля
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> void Write (const T&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Запись блока данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void WriteData       (const void* data, size_t size);
    void WriteDataUnsafe (const void* data, size_t size);

  private:
    OutputStream (const OutputStream&); //no implementation
    OutputStream& operator = (const OutputStream&); //no implementation

  private:
    char*          command_start; //указатель на начало команды
    char*          buffer_end;    //указатель на конец буфера
    char*          pos;           //позиция указателя записи
    CommandBuffer& buffer;        //буфер
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Входной поток десериализации
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputStream
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputStream  (const CommandBuffer& buffer);
    ~InputStream ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество доступных для считывания данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Available () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Чтение блока данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void ReadData       (void* data, size_t size);
    void ReadDataUnsafe (void* data, size_t size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Чтение поля
///////////////////////////////////////////////////////////////////////////////////////////////////    
    template <class T> T Read ();

  private:
    InputStream (const InputStream&); //no implementation
    InputStream& operator = (const InputStream&); //no implementation   

  private:
    const char*   pos;
    const char*   buffer_end;
    CommandBuffer buffer;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сериализация базовых типов
///////////////////////////////////////////////////////////////////////////////////////////////////
void write (OutputStream&, int32);
void write (OutputStream&, uint32);
void write (OutputStream&, int16);
void write (OutputStream&, uint16);
void write (OutputStream&, int8);
void write (OutputStream&, uint8);
void write (OutputStream&, float32);

void read (InputStream&, int32&);
void read (InputStream&, uint32&);
void read (InputStream&, int16&);
void read (InputStream&, uint16&);
void read (InputStream&, int8&);
void read (InputStream&, uint8&);
void read (InputStream&, float32&);

}

}

}

#endif
