#ifndef RENDER_SCENE_INTERCHANGE_STREAMS_HEADER
#define RENDER_SCENE_INTERCHANGE_STREAMS_HEADER

#include <xtl/common_exceptions.h>
#include <xtl/type.h>

#include <render/scene/interchange/command_buffer.h>

namespace render
{

namespace scene
{

namespace interchange
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Выходной поток сериализации
///////////////////////////////////////////////////////////////////////////////////////////////////
class OutputStream
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    OutputStream  ();
    ~OutputStream ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Reset (const CommandBuffer&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сериализация заголовка и конца команды
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BeginCommand (command_id_t);
    void EndCommand   ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подготовка достаточного места в буфере для записи
///////////////////////////////////////////////////////////////////////////////////////////////////
    void EnsureSpaceAvailable (size_t size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Запись блока данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void WriteData       (const void* data, size_t size);
    void WriteDataUnsafe (const void* data, size_t size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Запись значения
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> void Write (const T& value);

  private:
    OutputStream (const OutputStream&); //no implementation
    OutputStream& operator = (const OutputStream&); //no implementation

    void Resize (size_t size);

  private:
    char*         command_start; //указатель на начало команды
    char*         buffer_end;    //указатель на конец буфера
    char*         pos;           //позиция указателя записи
    CommandBuffer buffer;        //буфер
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Входной поток десериализации
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputStream
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputStream  ();
    ~InputStream ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Reset (const CommandBuffer&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество доступных для считывания данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Available () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Чтение блока данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void ReadData       (void* data, size_t size);
    void ReadDataUnsafe (void* data, size_t size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Чтение значения
///////////////////////////////////////////////////////////////////////////////////////////////////
                       const void* ReadData (size_t size);
    template <class T> const T&    Read     ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Пропуск
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Skip (size_t size);

  private:
    InputStream (const InputStream&); //no implementation
    InputStream& operator = (const InputStream&); //no implementation   

  private:
    const char*   pos;
    const char*   buffer_end;
    CommandBuffer buffer;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сериализация базовых типов
///////////////////////////////////////////////////////////////////////////////////////////////////
void write (OutputStream&, int32);
void write (OutputStream&, uint32);
void write (OutputStream&, int16);
void write (OutputStream&, uint16);
void write (OutputStream&, int8);
void write (OutputStream&, uint8);
void write (OutputStream&, float32);

int32&   read (InputStream&, xtl::type<int32>);
uint32&  read (InputStream&, xtl::type<uint32>);
int16&   read (InputStream&, xtl::type<int16>);
uint16&  read (InputStream&, xtl::type<uint16>);
int8&    read (InputStream&, xtl::type<int8>);
uint8&   read (InputStream&, xtl::type<uint8>);
float32& read (InputStream&, xtl::type<float32>);
Command& read (InputStream&, xtl::type<Command>);

#include <render/scene/interchange/detail/streams.inl>

}

}

}

#endif
