#ifndef RENDER_SCENE_RENDER_CORE_SCENE_RENDER_SHARED_HEADER
#define RENDER_SCENE_RENDER_CORE_SCENE_RENDER_SHARED_HEADER

#include "shared.h"

namespace render
{

//forward declarations
struct DrawContext;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер путей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderPathManager
{
  public:
    typedef SceneRender::LogFunction          LogFunction;
    typedef ICustomSceneRender::QueryFunction QueryFunction;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderPathManager () {}
    RenderPathManager (const char*          driver_name_mask,
                       const char*          renderer_name_mask,
                       const char*          render_path_masks,
                       const LogFunction&   log_handler,
                       const QueryFunction& query_handler);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Система рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    mid_level::IRenderer* Renderer () const { return renderer.get (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Список доступных путей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* RenderPaths () const { return render_paths_string.c_str (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка наличия пути рендеринга / получение пути рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool                HasRenderPath (const char* path_name) const;
    ICustomSceneRender& GetRenderPath (const char* path_name) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка ресурса
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadResource (const char* tag, const char* file_name, const LogFunction& log_handler);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (RenderPathManager&);

  private:
    RenderPathManager (const RenderPathManager&); //no impl
    RenderPathManager& operator = (const RenderPathManager&); //no impl

  private:
    struct RenderPath
    {
      CustomSceneRenderPtr render;  
      stl::string          name;

      RenderPath (const CustomSceneRenderPtr& in_render, const char* in_name) : render (in_render), name (in_name) {}
    };

    typedef stl::hash_map<stl::hash_key<const char*>, RenderPath> RenderPathMap;
    typedef xtl::com_ptr<mid_level::IRenderer>                    RendererPtr;    

  private:
    RendererPtr   renderer;            //система рендеринга
    RenderPathMap render_paths;        //пути рендеринга
    stl::string   render_paths_string; //строка с именами доступных путей рендеринга
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый класс для реализации цели рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class IRenderTargetImpl: public xtl::reference_counter
{
  public:  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual ~IRenderTargetImpl () {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имена ассоциированных буферов
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual const char* ColorAttachment () = 0;
    virtual const char* DepthStencilAttachment () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текущий экран
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual render::Screen* Screen () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Смена текущего экрана
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void SetScreen (render::Screen* in_screen) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////    
///Текущее логическое окно вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void        SetScreenArea (const Rect& rect) = 0;
    virtual const Rect& ScreenArea    () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текущее физическое окно вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void        SetRenderableArea (const Rect& rect) = 0;
    virtual const Rect& RenderableArea    () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////    
///Перерисовка
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Draw () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////    
///Захват изображения
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void CaptureImage (media::Image&) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение о необходимости сброса ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void FlushResources () = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер целей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderTargetManager: public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTargetManager (const SceneRender::LogFunction& log_handler);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация целей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Register   (IRenderTargetImpl*);
    void Unregister (IRenderTargetImpl*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перебор доступных целей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t               RenderTargetsCount () { return render_targets.size (); }
    render::RenderTarget RenderTarget       (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текущего менеджера путей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetRenderPathManager (render::RenderPathManager*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение системы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    mid_level::IRenderer& Renderer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение пути рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    ICustomSceneRender& GetRenderPath (const char* render_path_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void FlushResources ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация ассоциированных целей ренедринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                      RegisterAttachment       (const char* name, mid_level::IRenderTarget* render_target);
    void                      UnregisterAttachment     (const char* name);
    void                      UnregisterAllAttachments ();
    mid_level::IRenderTarget* GetAttachment            (const char* name);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание цели рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    render::RenderTarget CreateRenderTarget (const char* color_attachment_name, const char* depth_stencil_attachment_name);
    render::RenderTarget CreateRenderTarget (const char*               prefix,
                                             mid_level::IRenderTarget* color_attachment,
                                             mid_level::IRenderTarget* depth_stencil_attachment);
    render::RenderTarget CreateRenderTarget (mid_level::IRenderTarget* color_attachment,
                                             mid_level::IRenderTarget* depth_stencil_attachment);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текущий контекст рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                 SetDrawContext (render::DrawContext*);
    render::DrawContext* DrawContext    () { return draw_context; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Максимальный уровень вложенности рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void   SetMaxDrawDepth (size_t level);
    size_t MaxDrawDepth    () const { return max_draw_depth; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование кадров
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DrawFrames ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Протоколирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LogMessage (const char* message);

  private:
    RenderTargetManager (const RenderTargetManager&); //no impl
    RenderTargetManager& operator = (const RenderTargetManager&); //no impl

  private:
    typedef stl::vector<IRenderTargetImpl*>                          RenderTargetList;
    typedef xtl::com_ptr<mid_level::IRenderTarget>                   AttachmentPtr;
    typedef stl::hash_map<stl::hash_key<const char*>, AttachmentPtr> AttachmentMap;

  private:
    render::RenderPathManager* render_path_manager;          //менеджер путей рендеринга
    RenderTargetList           render_targets;               //цели рендеринга
    AttachmentMap              attachments;                  //ассоциированные цели рендеринга
    render::DrawContext*       draw_context;                 //текущий контекст рендеринга
    size_t                     max_draw_depth;               //максимальный уровень вложенности рендеринга
    SceneRender::LogFunction   log_handler;                  //обработчик протоколирования
    size_t                     anonymous_attachment_counter; //текущий номер в имени анонимной ассоциации буферов рендеринга
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отрисовываемая область вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderView: private IViewportListener, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерфейс обратной связи от RenderView к RenderTarget
///////////////////////////////////////////////////////////////////////////////////////////////////
    class IRenderTargetAPI
    {
      public:
        virtual mid_level::IRenderer& GetRenderer       () = 0; //получение системы визуализации
        virtual const Rect&           GetRenderableArea () = 0; //получение физических границ области рендеринга
        virtual const Rect&           GetScreenArea     () = 0; //получение логических границ области рендеринга
        virtual ICustomSceneRender&   GetRenderPath     (const char* name) = 0; //получение пути рендеринга
        virtual void                  UpdateOrderNotify () = 0; //оповещение об обновлении порядка следования областей вывода
        virtual void                  GetRenderTargets  (mid_level::IRenderTarget*& render_target, mid_level::IRenderTarget*& depth_stencil_target) = 0; //получение ассоциированных буферов рендеринга
        
      protected:
        virtual ~IRenderTargetAPI () {}
    };  

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderView  (const render::Viewport& vp, IRenderTargetAPI& render_target_api);
    ~RenderView ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение области вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    render::Viewport& Viewport () { return viewport; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отрисовка
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void FlushResources ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение о необходимости изменения границ области вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateAreaNotify ();

  private:
    void UpdateRenderView   ();
    void UpdateClearFrame   ();
    void OnChangeCamera     (scene_graph::Camera*);
    void OnChangeArea       (const Rect&);
    void OnChangeRenderPath (const char*);
    void OnChangeZOrder     (int);
    void OnChangeScene      ();
    void OnChangeProperty   (const char* name, const char* value);
    void OnChangeBackground (bool state, const math::vec4f& color);
    void AddRef             ();
    void Release            ();

  private:
    typedef xtl::com_ptr<IRenderView>                    RenderViewPtr;
    typedef xtl::com_ptr<render::mid_level::IClearFrame> ClearFramePtr;

  private:
    render::Viewport      viewport;                //область вывода
    IRenderTargetAPI&     render_target_api;       //интерфейс обратной связи к RenderTarget
    RenderViewPtr         render_view;             //область рендеринга
    scene_graph::Scene*   current_scene;           //текущая сцена
    scene_graph::Camera*  current_camera;          //текущая камера
    ClearFramePtr         clear_frame;             //кадр очистки
    bool                  need_update_view;        //необходимо обновить параметры области вывода
    bool                  need_update_area;        //необходимо обновить координаты области вывода
    bool                  need_update_camera;      //необходимо обновить камеру
    bool                  need_update_path;        //необходимо обновить путь рендеринга
    bool                  need_update_clear_frame; //необходимо обновить очищающий кадр
    xtl::auto_connection  on_camera_scene_change;  //соединение с сигналом оповещения об изменении сцены в камере  
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер запросов
///////////////////////////////////////////////////////////////////////////////////////////////////
class QueryManager
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    QueryManager  ();
    ~QueryManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация функций обработки запросов рендеринга (дочерний рендеринг)
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef SceneRender::QueryFunction QueryFunction;

    void RegisterQueryHandler       (const char* query_string_mask, const QueryFunction& handler);
    void UnregisterQueryHandler     (const char* query_string_mask);
    void UnregisterAllQueryHandlers ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание запроса
///////////////////////////////////////////////////////////////////////////////////////////////////
    IRenderQuery* CreateQuery (mid_level::IRenderTarget* color_attachment,
                               mid_level::IRenderTarget* depth_stencil_attachment,
                               const char*               query_string,
                               RenderTargetManager&      render_target_manager);

  private:
    class QueryHandlerEntry;

    typedef xtl::intrusive_ptr<QueryHandlerEntry> EntryPtr;
    typedef stl::list<EntryPtr>                   QueryHandlerList;

  private:
    QueryHandlerList handlers; //обработчики запросов
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отладочное протоколирование
///////////////////////////////////////////////////////////////////////////////////////////////////
void log_printf (const SceneRender::LogFunction& log_handler, const char* format, ...);

}

#endif
