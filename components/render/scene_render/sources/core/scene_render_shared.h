#ifndef RENDER_SCENE_RENDER_CORE_SCENE_RENDER_SHARED_HEADER
#define RENDER_SCENE_RENDER_CORE_SCENE_RENDER_SHARED_HEADER

#include "shared.h"

namespace render
{

//forward declaration
class RenderTargetManager;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер путей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderPathManager
{
  public:
    typedef SceneRender::LogFunction LogFunction;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderPathManager () {}
    RenderPathManager (const char* driver_name_mask, const char* renderer_name_mask, const char* render_path_masks, const LogFunction& log_handler);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Система рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    mid_level::IRenderer* Renderer () const { return renderer.get (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Список доступных путей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* RenderPaths () const { return render_paths_string.c_str (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка наличия пути рендеринга / получение пути рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool                HasRenderPath (const char* path_name) const;
    ICustomSceneRender& GetRenderPath (const char* path_name) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка ресурса
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadResource (const char* tag, const char* file_name, const LogFunction& log_handler);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (RenderPathManager&);
    
  private:
    RenderPathManager (const RenderPathManager&); //no impl
    RenderPathManager& operator = (const RenderPathManager&); //no impl

  private:
    struct RenderPath
    {
      CustomSceneRenderPtr render;  
      stl::string          name;

      RenderPath (const CustomSceneRenderPtr& in_render, const char* in_name) : render (in_render), name (in_name) {}
    };

    typedef stl::hash_map<stl::hash_key<const char*>, RenderPath> RenderPathMap;
    typedef xtl::com_ptr<mid_level::IRenderer>                    RendererPtr;    

  private:
    RendererPtr   renderer;            //система рендеринга
    RenderPathMap render_paths;        //пути рендеринга
    stl::string   render_paths_string; //строка с именами доступных путей рендеринга
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый класс для реализации цели рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderTargetBase
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер целей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTargetManager& Manager () const { return *manager; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение о необходимости сброса ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void FlushResources () = 0;

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTargetBase  (RenderTargetManager&);
    ~RenderTargetBase ();

  private:
    RenderTargetBase (const RenderTargetBase&); //no impl
    RenderTargetBase& operator = (const RenderTargetBase&); //no impl
    
  private:
    typedef xtl::intrusive_ptr<RenderTargetManager> ManagerPtr;

  private:
    ManagerPtr manager; //менеджер целей рендеринга
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер целей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderTargetManager: public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTargetManager ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация целей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Register   (RenderTargetBase&);
    void Unregister (RenderTargetBase&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текущего менеджера путей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                       SetRenderPathManager (render::RenderPathManager*);
    render::RenderPathManager* RenderPathManager    () { return render_path_manager; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void FlushResources ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Начало / конец транзакции отрисовки 
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool BeginDraw (); //результат показывает допустимость отрисовки (введено для будущего контроля глубины вложенности рендеринга)
    void EndDraw   ();
    bool IsInDraw  () const { return draw_depth != 0; }

  private:
    RenderTargetManager (const RenderTargetManager&); //no impl
    RenderTargetManager& operator = (const RenderTargetManager&); //no impl

  private:
    typedef stl::hash_set<RenderTargetBase*> RenderTargetSet;

  private:
    render::RenderPathManager* render_path_manager; //менеджер путей рендеринга
    RenderTargetSet            render_targets;      //цели рендеринга
    size_t                     draw_depth;          //глубина вложенности рендеринга
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отрисовываемая область вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderView: private IViewportListener, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерфейс обратной связи от RenderView к RenderTarget
///////////////////////////////////////////////////////////////////////////////////////////////////
    class IRenderTargetAPI
    {
      public:
        virtual render::mid_level::IRenderer& GetRenderer          () = 0; //получение системы визуализации
        virtual const Rect&                   GetRenderableArea    () = 0; //получение физических границ области рендеринга
        virtual const Rect&                   GetScreenArea        () = 0; //получение логических границ области рендеринга
        virtual RenderPathManager*            GetRenderPathManager () = 0; //получение менеджера путей рендеринга
        virtual void                          UpdateOrderNotify    () = 0; //оповещение об обновлении порядка следования областей вывода
        
      protected:
        virtual ~IRenderTargetAPI () {}
    };  

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderView  (const render::Viewport& vp, IRenderTargetAPI& render_target_api);
    ~RenderView ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение области вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    render::Viewport& Viewport () { return viewport; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отрисовка
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void FlushResources ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение о необходимости изменения границ области вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateAreaNotify ();

  private:
    void UpdateRenderView   ();
    void UpdateClearFrame   ();
    void OnChangeCamera     (scene_graph::Camera*);
    void OnChangeArea       (const Rect&);
    void OnChangeRenderPath (const char*);
    void OnChangeZOrder     (int);
    void OnChangeScene      ();
    void OnChangeProperty   (const char* name, const char* value);
    void OnChangeBackground (bool state, const math::vec4f& color);
    void AddRef             ();
    void Release            ();

  private:
    typedef xtl::com_ptr<IRenderView>                    RenderViewPtr;
    typedef xtl::com_ptr<render::mid_level::IClearFrame> ClearFramePtr;

  private:
    render::Viewport      viewport;                //область вывода
    IRenderTargetAPI&     render_target_api;       //интерфейс обратной связи к RenderTarget
    RenderViewPtr         render_view;             //область рендеринга
    scene_graph::Scene*   current_scene;           //текущая сцена
    scene_graph::Camera*  current_camera;          //текущая камера
    ClearFramePtr         clear_frame;             //кадр очистки
    bool                  need_update_view;        //необходимо обновить параметры области вывода
    bool                  need_update_area;        //необходимо обновить координаты области вывода
    bool                  need_update_camera;      //необходимо обновить камеру
    bool                  need_update_path;        //необходимо обновить путь рендеринга
    bool                  need_update_clear_frame; //необходимо обновить очищающий кадр
    xtl::auto_connection  on_camera_scene_change;  //соединение с сигналом оповещения об изменении сцены в камере  
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отладочное протоколирование
///////////////////////////////////////////////////////////////////////////////////////////////////
void log_printf (const SceneRender::LogFunction& log_handler, const char* format, ...);

}

#endif
