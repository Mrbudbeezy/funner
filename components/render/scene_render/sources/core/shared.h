#ifndef RENDER_SCENE_RENDER_CORE_SHARED_HEADER
#define RENDER_SCENE_RENDER_CORE_SHARED_HEADER

#include <stl/hash_set>
#include <stl/hash_map>
#include <stl/vector>
#include <stl/string>
#include <stl/algorithm>

#include <xtl/bind.h>
#include <xtl/common_exceptions.h>
#include <xtl/connection.h>
#include <xtl/function.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/iterator.h>
#include <xtl/reference_counter.h>
#include <xtl/trackable.h>

#include <common/component.h>
#include <common/singleton.h>
#include <common/strlib.h>

#include <media/image.h>

#include <sg/camera.h>

#include <render/mid_level/driver.h>

#include <render/custom_render.h>
#include <render/scene_render.h>

namespace render
{

//forward declarations
class DrawTransactionManager;

typedef xtl::com_ptr<ICustomSceneRender> CustomSceneRenderPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание рендера сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
CustomSceneRenderPtr create_render_path (mid_level::IRenderer* renderer, const char* path_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderManager
{
  friend class RenderTargetImpl;
  public:
    typedef SceneRender::LogFunction          LogFunction;
    typedef ICustomSceneRender::QueryFunction QueryFunction;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderManager  (const char*          driver_name_mask,
                    const char*          renderer_name_mask,
                    const char*          render_path_masks,
                    const LogFunction&   log_handler,
                    const QueryFunction& query_handler);
    ~RenderManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Система рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    mid_level::IRenderer& Renderer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Список доступных путей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* RenderPaths ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка наличия пути рендеринга / получение пути рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool                HasRenderPath (const char* path_name);
    ICustomSceneRender& GetRenderPath (const char* path_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перебор целей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t            RenderTargetsCount ();
    RenderTargetImpl& RenderTarget       (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер транзакций отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    render::DrawTransactionManager& DrawTransactionManager (); //может быть равен 0 

///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка ресурса
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadResource (const char* tag, const char* file_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Протоколирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LogPrintf (const char* format, ...);

  private:    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация целей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RegisterRenderTarget   (render::RenderTargetImpl*);
    void UnregisterRenderTarget (render::RenderTargetImpl*);

  private:
    RenderManager (const RenderManager&); //no impl
    RenderManager& operator = (const RenderManager&); //no impl

  private:
    class Impl;
    stl::auto_ptr<Impl> impl;    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер транзакций отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
class DrawTransactionManager
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    DrawTransactionManager  (mid_level::IRenderer&, const SceneRender::LogFunction& log_handler);
    ~DrawTransactionManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление транзакцией отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t BeginDraw (size_t last_update_transaction_id); //возвращает уникальный номер транзакции отрисовки или 0 в случае отказа
    void   EndDraw   ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Максимальный уровень вложенности рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void   SetMaxDrawDepth (size_t level);
    size_t MaxDrawDepth    () const;

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация цели рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderTargetImpl: public xtl::reference_counter
{
  public: 
    typedef xtl::intrusive_ptr<RenderTargetImpl> Pointer;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ~RenderTargetImpl ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание
///////////////////////////////////////////////////////////////////////////////////////////////////
    static Pointer Create (mid_level::IRenderTarget* color_attachment, mid_level::IRenderTarget* depth_stencil_attachment);
    static Pointer Create (RenderManager& render_manager, mid_level::IRenderTarget* color_attachment, mid_level::IRenderTarget* depth_stencil_attachment);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Целевые буферы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    mid_level::IRenderTarget* ColorAttachment        ();
    mid_level::IRenderTarget* DepthStencilAttachment ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                   SetRenderManager (render::RenderManager*);
    render::RenderManager* RenderManager    ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Экран (политика владения - weak-ref)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void            SetScreen (render::Screen* screen);
    render::Screen* Screen    ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Размеры области рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    const Rect& RenderableArea    ();
    void        SetRenderableArea (const Rect&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение о необходимости пересортировки областей вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateViewportsOrder ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Update ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Захват изображения (screen-shot)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void CaptureImage (media::Image&);
    void CaptureImage (const char* image_name);

  private:    
    RenderTargetImpl (mid_level::IRenderTarget* render_target, mid_level::IRenderTarget* depth_stencil_target);
  
    RenderTargetImpl (const RenderTargetImpl&); //no impl
    RenderTargetImpl& operator = (const RenderTargetImpl&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отрисовываемая область вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderableViewport
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderableViewport  (const render::Viewport& viewport,
                         RenderTargetImpl&       render_target,
                         RenderManager&          render_manager);
    RenderableViewport  (const RenderableViewport&);
    ~RenderableViewport ();

    RenderableViewport& operator = (const RenderableViewport&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение области вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    render::Viewport& Viewport ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление област вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Update ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение о необходимости изменения границ области вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateArea ();

  private:
    class Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер запросов
///////////////////////////////////////////////////////////////////////////////////////////////////
class QueryManager
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    QueryManager  ();
    ~QueryManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация функций обработки запросов рендеринга (дочерний рендеринг)
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef SceneRender::QueryFunction QueryFunction;

    void RegisterQueryHandler       (const char* query_string_mask, const QueryFunction& handler);
    void UnregisterQueryHandler     (const char* query_string_mask);
    void UnregisterAllQueryHandlers ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание запроса
///////////////////////////////////////////////////////////////////////////////////////////////////
    IRenderQuery* CreateQuery (mid_level::IRenderTarget* color_attachment,
                               mid_level::IRenderTarget* depth_stencil_attachment,
                               const char*               query_string,
                               RenderManager&            render_manager);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструируемая обёртка цели рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
struct ConstructableRenderTarget: public RenderTarget
{
  ConstructableRenderTarget (RenderTargetImpl& impl) : RenderTarget (&impl) {}
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отладочное протоколирование
///////////////////////////////////////////////////////////////////////////////////////////////////
void log_printf (const SceneRender::LogFunction& log_handler, const char* format, ...);

}

#endif
