#ifndef SCENE_GRAPH_RENDER2D_HEADER
#define SCENE_GRAPH_RENDER2D_HEADER

#include <stl/hash_map>

#include <xtl/common_exceptions.h>
#include <xtl/function.h>
#include <xtl/reference_counter.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/connection.h>
#include <xtl/bind.h>
#include <xtl/visitor.h>
#include <xtl/iterator.h>
#include <xtl/trackable.h>

#include <common/component.h>
#include <common/strlib.h>

#include <media/image.h>
#include <media/font.h>
#include <media/rfx/material_library.h>
#include <media/rfx/sprite_material.h>

#include <sg/camera.h>
#include <sg/scene.h>
#include <sg/sprite.h>
#include <sg/text_line.h>

#include <render/mid_level/renderer2d.h>

#include <render/custom_render.h>

namespace render
{

namespace render2d
{

//forward declaration
class Render;

typedef mid_level::renderer2d::IPrimitive  IPrimitive;
typedef mid_level::renderer2d::IRenderer   IRenderer;
typedef mid_level::renderer2d::IFrame      IFrame;
typedef mid_level::renderer2d::ITexture    ITexture;
typedef mid_level::renderer2d::BlendMode   BlendMode;
typedef media::rfx::SpriteMaterial         SpriteMaterial;

typedef xtl::com_ptr<IPrimitive>  PrimitivePtr;
typedef xtl::com_ptr<IRenderer>   RendererPtr;
typedef xtl::com_ptr<IFrame>      FramePtr;
typedef xtl::com_ptr<ITexture>    TexturePtr;
typedef SpriteMaterial::Pointer   SpriteMaterialPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый визуализируемый объект
///////////////////////////////////////////////////////////////////////////////////////////////////
class Renderable: public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
            Renderable  (scene_graph::Entity*);
    virtual ~Renderable () {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw (IFrame& frame);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об изменениях в объекте
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Update () {}
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void DrawCore (IFrame& frame) = 0;
    
  private:
    void UpdateNotify ();
  
  private:
    xtl::auto_connection on_update_connection;  //соединение на сигнал оповещения об обновлении объекта
    bool                 need_update;           //флаг необходимости обновления внутренних структур данных объекта
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Модель, состоящая из спрайтов
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderableSpriteModel: public Renderable, public xtl::trackable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderableSpriteModel (scene_graph::SpriteModel* model, Render& render);
    ~RenderableSpriteModel ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление модели
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Update ();
    void UpdateMaterialNotify ();
    void UpdateSpritesNotify ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование модели
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DrawCore (IFrame&);

  private:
    Render&                   render;                          //ссылка на рендер
    scene_graph::SpriteModel* model;                           //исходная модель
    PrimitivePtr              primitive;                       //визуализируемый примитив
    bool                      need_update_sprites;             //флаг необходимости обновления массива спрайтов
    size_t                    tile_columns;                    //количество столбцов тайлов
    float                     tile_tex_width, tile_tex_height; //размеры тайла в текстурных координатах
    size_t                    current_world_tm_hash;           //хэш текущей матрицы трансформации
    size_t                    current_material_name_hash;      //хэш текущего имени материала
    float                     current_alpha_reference;         //текущее значение параметра альфа-отсечения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подготовленные к рендерингу шрифт
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderableFont
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderableFont (const char* font_name, Render& in_render);
    ~RenderableFont ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение шрифта
///////////////////////////////////////////////////////////////////////////////////////////////////
    const media::Font& GetFont () const { return font; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    ITexture* GetTexture () const { return texture.get (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение размера самой большой стороны глифа
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetMaxGlyphSide () const { return max_glyph_side; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение спрайта по индексу
///////////////////////////////////////////////////////////////////////////////////////////////////
    const render::mid_level::renderer2d::Sprite& GetSprite (size_t index) const;

  private:
    typedef xtl::uninitialized_storage<render::mid_level::renderer2d::Sprite> SpritesBuffer;
    typedef xtl::com_ptr<ITexture>                                            TextuerPtr;

  private:
    Render&       render;                       //ссылка на рендер
    media::Font   font;                         //шрифт
    SpritesBuffer sprites_buffer;               //буффер спрайтов (по спрайту для каждого глифа)
    TexturePtr    texture;                      //текстура
    size_t        max_glyph_side;               //размер самой большой стороны среди всех глифов (в пикселях)
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Линия текста
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderableTextLine: public Renderable, public xtl::trackable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderableTextLine (scene_graph::TextLine* text_line, Render& render);
    ~RenderableTextLine ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление линии текста
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Update ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка нового шрифта
///////////////////////////////////////////////////////////////////////////////////////////////////
    void PreprocessFont ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование линии текста
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DrawCore (IFrame&);

  private:
    typedef xtl::uninitialized_storage<render::mid_level::renderer2d::Sprite> SpritesBuffer;

  private:
    Render&                        render;                       //ссылка на рендер
    scene_graph::TextLine*         text_line;                    //исходная линия текста
    PrimitivePtr                   primitive;                    //визуализируемый примитив
    math::mat4f                    translate_tm;                 //матрица сдвига для выравнивания
    math::mat4f                    current_world_tm;             //текущая матрица трансформации
    size_t                         current_world_tm_hash;        //хэш текущей матрицы трансформации
    stl::string                    current_font_name;            //текущий шрифт
    stl::string                    current_text;                 //текущий текст
    math::vec4f                    current_color;                //текущий цвет
    scene_graph::TextLineAlignment current_horizontal_alignment; //текущее горизонтальное выравнивание
    scene_graph::TextLineAlignment current_vertical_alignment;   //текущее вертикальное выравнивание
    SpritesBuffer                  sprites_buffer;               //буффер спрайтов
    stl::vector<size_t>            glyph_indices;                //индексы глифов в буффере спрайтов
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Область вывода рендера
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderView: public IRenderView, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderView  (scene_graph::Scene*, Render*);
    ~RenderView ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка области вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetViewport (const Rect& rect);
    void GetViewport (Rect& out_rect);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка камеры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                 SetCamera (scene_graph::Camera*);
    scene_graph::Camera* GetCamera ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / чтение свойств
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetProperty (const char* name, const char* value);
    void GetProperty (const char* name, size_t buffer_size, char* value_buffer);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddRef  ();
    void Release ();

  private:
    typedef xtl::intrusive_ptr<Render> RenderPtr;

    RenderPtr            render; //рендер
    FramePtr             frame;  //кадр
    scene_graph::Scene*  scene;  //сцена
    scene_graph::Camera* camera; //камера
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рендер двумерной сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class Render: public ICustomSceneRender, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Render  (mid_level::IRenderer*);
    ~Render ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание областей вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    IRenderView* CreateRenderView (scene_graph::Scene* scene);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с ресурсами
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadResource (const char* tag, const char* file_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка функции отладочного протоколирования
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetLogHandler (const LogFunction&);
    const LogFunction& GetLogHandler ();

    void LogPrintf (const char* format, ...);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddRef  ();
    void Release ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение системы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    const RendererPtr& Renderer () const { return renderer; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с кэшем
///////////////////////////////////////////////////////////////////////////////////////////////////
    Renderable*     GetRenderable (scene_graph::SpriteModel*);  // дублирование!!!
    Renderable*     GetRenderable (scene_graph::TextLine*);     // дублирование!!!
    ITexture*       GetTexture    (const char* file_name, bool need_alpha=false);
    SpriteMaterial* GetMaterial   (const char* name);
    RenderableFont* GetFont       (const char* name);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление кадра на отрисовку
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddFrame (IFrame*);

  private:
    typedef xtl::intrusive_ptr<Renderable> RenderablePtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с кэшем примитивов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void InsertRenderable (scene_graph::Entity*, const RenderablePtr&);
    void RemoveRenderable (scene_graph::Entity*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с ресурсами
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadMaterialLibrary (const char* file_name);
    void InsertMaterial      (const char* id, const SpriteMaterialPtr&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание текстур
///////////////////////////////////////////////////////////////////////////////////////////////////
    TexturePtr CreateTexture (const char* file_name, bool need_alpha, bool& has_alpha);

  private:
    struct RenderableHolder
    {
      RenderablePtr        renderable;
      xtl::auto_connection on_destroy;

      RenderableHolder (const RenderablePtr& in_renderable, const xtl::connection& in_on_destroy) :
        renderable (in_renderable), on_destroy (in_on_destroy) {}
    };
    
    struct TextureHolder
    {
      TexturePtr base_texture;  //базовая текстура
      TexturePtr alpha_texture; //альфа-текстура

      TextureHolder (const TexturePtr& in_base_texture, const TexturePtr& in_alpha_texture) :
        base_texture (in_base_texture), alpha_texture (in_alpha_texture) {}
    };

    typedef stl::hash_map<scene_graph::Entity*, RenderableHolder>        RenderableMap;
    typedef stl::hash_map<stl::hash_key<const char*>, SpriteMaterialPtr> MaterialMap;
    typedef stl::hash_map<stl::hash_key<const char*>, TextureHolder>     TextureMap;

    typedef xtl::shared_ptr<RenderableFont>                              RenderableFontPtr;
    typedef stl::hash_map<stl::hash_key<const char*>, RenderableFontPtr> RenderableFontMap;

  private:
    LogFunction       log_handler;       //функция протоколирования
    RendererPtr       renderer;          //система рендеринга
    RenderableMap     renderables_cache; //кэш визуализируемых объектов
    MaterialMap       materials;         //материалы
    TextureMap        textures;          //текстуры
    RenderableFontMap fonts;             //шрифты
};

}

}

#endif
