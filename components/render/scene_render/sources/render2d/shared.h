#ifndef SCENE_GRAPH_RENDER2D_HEADER
#define SCENE_GRAPH_RENDER2D_HEADER

#include <stl/hash_map>

#include <xtl/common_exceptions.h>
#include <xtl/function.h>
#include <xtl/reference_counter.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/connection.h>
#include <xtl/bind.h>
#include <xtl/visitor.h>
#include <xtl/iterator.h>
#include <xtl/trackable.h>

#include <common/component.h>
#include <common/strlib.h>

#include <media/image.h>
#include <media/rfx/material_library.h>
#include <media/rfx/sprite_material.h>

#include <sg/scene.h>
#include <sg/camera.h>
#include <sg/sprite.h>

#include <render/mid_level/renderer2d.h>

#include <render/custom_render.h>

namespace render
{

namespace render2d
{

//forward declaration
class Render;

typedef mid_level::renderer2d::IPrimitive  IPrimitive;
typedef mid_level::renderer2d::IRenderer   IRenderer;
typedef mid_level::renderer2d::IFrame      IFrame;
typedef mid_level::renderer2d::ITexture    ITexture;
typedef mid_level::renderer2d::BlendMode   BlendMode;
typedef media::rfx::SpriteMaterial         SpriteMaterial;

typedef xtl::com_ptr<IPrimitive>  PrimitivePtr;
typedef xtl::com_ptr<IRenderer>   RendererPtr;
typedef xtl::com_ptr<IFrame>      FramePtr;
typedef xtl::com_ptr<ITexture>    TexturePtr;
typedef SpriteMaterial::Pointer   SpriteMaterialPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый визуализируемый объект
///////////////////////////////////////////////////////////////////////////////////////////////////
class Renderable: public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
            Renderable  (scene_graph::Entity*);
    virtual ~Renderable () {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw (IFrame& frame);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об изменениях в объекте
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Update () {}
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void DrawCore (IFrame& frame) = 0;
    
  private:
    void UpdateNotify ();
  
  private:
    xtl::auto_connection on_update_connection;  //соединение на сигнал оповещения об обновлении объекта
    bool                 need_update;           //флаг необходимости обновления внутренних структур данных объекта
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Модель, состоящая из спрайтов
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderableSpriteModel: public Renderable, public xtl::trackable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderableSpriteModel (scene_graph::SpriteModel* model, Render& render);
    ~RenderableSpriteModel ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление модели
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Update ();
    void UpdateMaterialNotify ();
    void UpdateSpritesNotify ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование модели
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DrawCore (IFrame&);

  private:
    Render&                   render;                          //ссылка на рендер
    scene_graph::SpriteModel* model;                           //исходная модель
    PrimitivePtr              primitive;                       //визуализируемый примитив
    bool                      need_update_sprites;             //флаг необходимости обновления массива спрайтов
    size_t                    tile_columns;                    //количество столбцов тайлов
    float                     tile_tex_width, tile_tex_height; //размеры тайла в текстурных координатах
    size_t                    current_world_tm_hash;           //хэш текущей матрицы трансформации
    size_t                    current_material_name_hash;      //хэш текущего имени материала
    float                     current_alpha_reference;         //текущее значение параметра альфа-отсечения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Область вывода рендера
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderView: public IRenderView, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderView  (scene_graph::Scene*, Render*);
    ~RenderView ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка области вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetViewport (const Rect& rect);
    void GetViewport (Rect& out_rect);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка камеры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                 SetCamera (scene_graph::Camera*);
    scene_graph::Camera* GetCamera ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / чтение свойств
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetProperty (const char* name, const char* value);
    void GetProperty (const char* name, size_t buffer_size, char* value_buffer);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddRef  ();
    void Release ();

  private:
    typedef xtl::intrusive_ptr<Render> RenderPtr;

    RenderPtr            render; //рендер
    FramePtr             frame;  //кадр
    scene_graph::Scene*  scene;  //сцена
    scene_graph::Camera* camera; //камера
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рендер двумерной сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class Render: public ICustomSceneRender, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Render  (mid_level::IRenderer*);
    ~Render ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание областей вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    IRenderView* CreateRenderView (scene_graph::Scene* scene);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с ресурсами
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadResource (const char* tag, const char* file_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка функции отладочного протоколирования
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetLogHandler (const LogFunction&);
    const LogFunction& GetLogHandler ();

    void LogPrintf (const char* format, ...);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddRef  ();
    void Release ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение системы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    const RendererPtr& Renderer () const { return renderer; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с кэшем
///////////////////////////////////////////////////////////////////////////////////////////////////
    Renderable*     GetRenderable (scene_graph::SpriteModel*);
    ITexture*       GetTexture    (const char* file_name);    
    SpriteMaterial* GetMaterial   (const char* name);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление кадра на отрисовку
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddFrame (IFrame*);

  private:
    typedef xtl::intrusive_ptr<Renderable> RenderablePtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с кэшем примитивов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void InsertRenderable (scene_graph::Entity*, const RenderablePtr&);
    void RemoveRenderable (scene_graph::Entity*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с ресурсами
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadMaterialLibrary (const char* file_name);
    void InsertMaterial      (const char* id, const SpriteMaterialPtr&);

  private:
    struct RenderableHolder
    {
      RenderablePtr        renderable;
      xtl::auto_connection on_destroy;

      RenderableHolder (const RenderablePtr& in_renderable, const xtl::connection& in_on_destroy) :
        renderable (in_renderable), on_destroy (in_on_destroy) {}
    };  

    typedef stl::hash_map<scene_graph::Entity*, RenderableHolder>        RenderableMap;
    typedef stl::hash_map<stl::hash_key<const char*>, SpriteMaterialPtr> MaterialMap;
    typedef stl::hash_map<stl::hash_key<const char*>, TexturePtr>        TextureMap;

  private:
    LogFunction   log_handler;       //функция протоколирования
    RendererPtr   renderer;          //система рендеринга
    RenderableMap renderables_cache; //кэш визуализируемых объектов
    MaterialMap   materials;         //материалы
    TextureMap    textures;          //текстуры
};

}

}

#endif
