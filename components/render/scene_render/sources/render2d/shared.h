#ifndef SCENE_GRAPH_RENDER2D_HEADER
#define SCENE_GRAPH_RENDER2D_HEADER

#include <stl/hash_map>

#include <xtl/common_exceptions.h>
#include <xtl/function.h>
#include <xtl/reference_counter.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/connection.h>
#include <xtl/bind.h>
#include <xtl/visitor.h>

#include <common/component.h>

#include <sg/scene.h>
#include <sg/camera.h>
#include <sg/sprite.h>

#include <render/mid_level/renderer2d.h>

#include <render/custom_render.h>

namespace render
{

namespace render2d
{

//forward declaration
class Render;

typedef mid_level::renderer2d::IPrimitive IPrimitive;
typedef mid_level::renderer2d::IRenderer  IRenderer;
typedef mid_level::renderer2d::IFrame     IFrame;

typedef xtl::com_ptr<IPrimitive> PrimitivePtr;
typedef xtl::com_ptr<IRenderer>  RendererPtr;
typedef xtl::com_ptr<IFrame>     FramePtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый визуализируемый объект
///////////////////////////////////////////////////////////////////////////////////////////////////
class Renderable: public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Renderable (scene_graph::Entity*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Draw (IFrame& frame) {}

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об изменениях в объекте
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void UpdateNotify () {}
  
  private:
    xtl::auto_connection on_update_connection;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Спрайт
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderableSprite: public Renderable
{
  public:
    RenderableSprite (scene_graph::Sprite* sprite, IRenderer& renderer);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw (IFrame& frame);

  private:
    void UpdateNotify ();

  private:
    scene_graph::Sprite* sprite;
    PrimitivePtr         primitive;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Область вывода рендера
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderView: public IRenderView, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderView  (scene_graph::Scene*, Render*);
    ~RenderView ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка области вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetViewport (float left, float top, float width, float height);
    void GetViewport (float viewport [4]);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка камеры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                 SetCamera (scene_graph::Camera*);
    scene_graph::Camera* GetCamera ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / чтение свойств
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetProperty (const char* name, const char* value);
    void GetProperty (const char* name, size_t buffer_size, char* value_buffer);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddRef  ();
    void Release ();

  private:
    typedef xtl::intrusive_ptr<Render> RenderPtr;

    RenderPtr            render;       //рендер
    FramePtr             frame;        //кадр
    scene_graph::Scene*  scene;        //сцена
    scene_graph::Camera* camera;       //камера
    float                viewport [4]; //границы области вывода
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рендер двумерной сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class Render: public ICustomSceneRender, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Render  (mid_level::IRenderer*);
    ~Render ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание областей вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    IRenderView* CreateRenderView (scene_graph::Scene* scene);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка цвета очистка буфера кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetBackgroundColor (const math::vec4f& color);
    void GetBackgroundColor (math::vec4f& color);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка функции отладочного протоколирования
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetLogHandler (const LogFunction&);
    const LogFunction& GetLogHandler ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddRef  ();
    void Release ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение системы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    const RendererPtr& Renderer () const { return renderer; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с кэшем примитивов
///////////////////////////////////////////////////////////////////////////////////////////////////
    Renderable* GetRenderable (scene_graph::Sprite*);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление кадра на отрисовку
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddFrame (IFrame*);

  private:
    typedef xtl::intrusive_ptr<Renderable> RenderablePtr;
    
    struct RenderableHolder
    {
      RenderablePtr        renderable;
      xtl::auto_connection on_destroy;

      RenderableHolder (const RenderablePtr& in_renderable, const xtl::connection& in_on_destroy) :
        renderable (in_renderable), on_destroy (in_on_destroy) {}
    };

    void InsertRenderable (scene_graph::Entity*, const RenderablePtr&);
    void RemoveRenderable (scene_graph::Entity*);

  private:
    typedef stl::hash_map<scene_graph::Entity*, RenderableHolder> RenderableMap;

  private:
    math::vec4f    clear_color;       //цвет очистки
    LogFunction    log_handler;       //функция протоколирования
    RendererPtr    renderer;          //система рендеринга
    RenderableMap  renderables_cache; //кэш визуализируемых объектов
};

}

}

#endif
