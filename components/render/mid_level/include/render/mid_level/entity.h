#ifndef RENDER_MID_LEVEL_ENTITY_HEADER
#define RENDER_MID_LEVEL_ENTITY_HEADER

#include <common/property_map.h>

#include <math/matrix.h>

#include <render/mid_level/primitive.h>

namespace render
{

namespace mid_level
{

//implementation forwards
class EntityImpl;
class Wrappers;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Объект рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class Entity
{
  friend class Wrappers;
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    Entity  (const Entity&);
    ~Entity ();
    
    Entity& operator = (const Entity&);
    
    ///????????scene-render properties??? from materials
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Свойства рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                       SetProperties (const common::PropertyMap&);
    const common::PropertyMap& Properties    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Матрица преобразований
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetTransformation (const math::mat4f&);
    const math::vec4f& Transformation    () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с костями (для скиннинга)
///  преобразования умножаются на матрицу Entity::Transformation в случае если она не единична
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetJointsCount         (size_t count);
    size_t             JointsCount            () const;
    void               SetJointTransformation (size_t joint_index, const math::mat4f&);
    const math::mat4f& JointTransformation    (size_t joint_index) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с уровнями детализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t LodsCount () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с примитивом
///////////////////////////////////////////////////////////////////////////////////////////////////
    mid_level::Primitive Primitive           (size_t level_of_detail = 0) const;
    void                 SetPrimitive        (const mid_level::Primitive&, size_t level_of_detail = 0);    
    void                 ResetPrimitive      (size_t level_of_detail = 0);    
    bool                 HasPrimitive        (size_t level_of_detail = 0) const;
    void                 ResetAllPrimitives  ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (Entity&);
    
  private:
    Entity (EntityImpl*);
    
  private:
    EntityImpl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (Entity&, Entity&);

}

}

#endif
