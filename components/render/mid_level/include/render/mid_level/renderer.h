#ifndef RENDER_MID_LEVEL_RENDERER_HEADER
#define RENDER_MID_LEVEL_RENDERER_HEADER

#include <mathlib.h>

namespace media
{

//forward declaration
class Image;

}

namespace render
{

namespace mid_level
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый класс
///////////////////////////////////////////////////////////////////////////////////////////////////
class IObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void AddRef  () = 0;
    virtual void Release () = 0;

  protected:
    virtual ~IObject () {}
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Целевой буфер отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
class IRenderTarget: virtual public IObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Размеры буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual size_t GetWidth  () = 0;
    virtual size_t GetHeight () = 0;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Копирование образа текстуры в картинку
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void CaptureImage (media::Image&) = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Область вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
struct Viewport
{
  int    x;      //абсцисса левого верхнего угла области
  int    y;      //ордината левого верхнего угла области
  size_t width;  //ширина области
  size_t height; //высота области
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый класс для визуализируемых кадров
///////////////////////////////////////////////////////////////////////////////////////////////////
class IFrame: virtual public IObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Целевые буферы отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void           SetRenderTargets      (IRenderTarget* render_target, IRenderTarget* depth_stencil_target) = 0;
    virtual IRenderTarget* GetRenderTarget       () = 0; //целевой буфер цвета
    virtual IRenderTarget* GetDepthStencilTarget () = 0; //целевой буфер попиксельного отсечения

///////////////////////////////////////////////////////////////////////////////////////////////////
///Область вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void SetViewport (const Viewport&) = 0;
    virtual void GetViewport (Viewport&) = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Флаги очистки
///////////////////////////////////////////////////////////////////////////////////////////////////
enum ClearFlag
{
  ClearFlag_RenderTarget  = 1, //очистка буфера цвета
  ClearFlag_Depth         = 2, //очистка буфера глубины
  ClearFlag_Stencil       = 4, //очистка буфера трафарета
  ClearFlag_ViewportOnly  = 8, //очистка только области вывода (могут быть потери производительности)

  ClearFlag_DepthStencil = ClearFlag_Depth | ClearFlag_Stencil,
  ClearFlag_All          = ClearFlag_DepthStencil | ClearFlag_RenderTarget
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Класс, применяемый для очистки кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class IClearFrame: virtual public IFrame
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Флаги очистки кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void   SetFlags (size_t clear_flags) = 0;
    virtual size_t GetFlags () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры очистки буфера цвета
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void SetColor (const math::vec4f& color) = 0;
    virtual void GetColor (math::vec4f& color) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры очистки буфера попиксельного отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void          SetDepthValue   (float depth_value) = 0;
    virtual void          SetStencilIndex (unsigned char stencil_index) = 0;
    virtual float         GetDepthValue   () = 0;
    virtual unsigned char GetStencilIndex () = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class IFrameBuffer: virtual public IObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение буфера цвета и буфера попиксельного отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual IRenderTarget* GetColorBuffer        () = 0;
    virtual IRenderTarget* GetDepthStencilBuffer () = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Слушатель событий системы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class IRendererListener
{
  public:
    virtual void OnFrameBufferCreate  (IFrameBuffer& frame_buffer) {}                              //создан буфер кадра
    virtual void OnFrameBufferDestroy (IFrameBuffer& frame_buffer) {}                              //буфер кадра удалён  
    virtual void OnFrameBufferUpdate  (IFrameBuffer& frame_buffer) {}                              //буфер кадра необходимо обновить
    virtual void OnFrameBufferResize  (IFrameBuffer& frame_buffer, size_t width, size_t height) {} //размеры буфера кадра изменились

  protected:
    virtual ~IRendererListener () {}
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Система рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class IRenderer: virtual public IObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual const char* GetDescription () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перебор буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::iterator<IFrameBuffer> FrameBufferIterator;

    virtual FrameBufferIterator CreateFrameBufferIterator () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual IRenderTarget* CreateDepthStencilBuffer (size_t width, size_t height) = 0;
    virtual IRenderTarget* CreateRenderBuffer       (size_t width, size_t height) = 0;
    virtual IClearFrame*   CreateClearFrame         () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление кадра в список отрисовки (позиция вставки кадров смещается вперёд на 1)
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void AddFrame (IFrame* frame) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество кадров / позиция вставки следующего кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual size_t FramesCount      () = 0;
    virtual void   SetFramePosition (size_t position) = 0;
    virtual size_t GetFramePosition () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конец отрисовки / сброс отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void DrawFrames   () = 0;
    virtual void CancelFrames () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подписка на события системы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void AttachListener (IRendererListener*) = 0;
    virtual void DetachListener (IRendererListener*) = 0;
};

}

}

#endif
