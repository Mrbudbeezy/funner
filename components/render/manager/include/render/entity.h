#ifndef RENDER_MANAGER_ENTITY_HEADER
#define RENDER_MANAGER_ENTITY_HEADER

#include <common/property_map.h>

#include <math/matrix.h>

#include <render/primitive.h>

namespace render
{

//implementation forwards
class EntityImpl;
class Wrappers;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Объект рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class Entity
{
  friend class Wrappers;
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    Entity  (const Entity&);
    ~Entity ();
    
    Entity& operator = (const Entity&);   

///////////////////////////////////////////////////////////////////////////////////////////////////
///Свойства рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                       SetProperties (const common::PropertyMap&);
    const common::PropertyMap& Properties    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Матрица преобразований
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetTransformation (const math::mat4f&);
    const math::mat4f& Transformation    () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с костями (для скиннинга)
///  преобразования умножаются на матрицу Entity::Transformation в случае если она не единична
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetJointsCount         (size_t count);
    size_t             JointsCount            () const;
    void               SetJointTransformation (size_t joint_index, const math::mat4f&);
    const math::mat4f& JointTransformation    (size_t joint_index) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с уровнями детализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t LodsCount () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с примитивом
///////////////////////////////////////////////////////////////////////////////////////////////////
    render::Primitive Primitive           (size_t level_of_detail = 0) const;
    const char*       PrimitiveName       (size_t level_of_detail = 0) const;
    void              SetPrimitive        (const render::Primitive&, size_t level_of_detail = 0);
    void              SetPrimitive        (const char* name, size_t level_of_detail = 0);
    void              ResetPrimitive      (size_t level_of_detail = 0);
    bool              HasPrimitive        (size_t level_of_detail = 0) const;
    void              ResetAllPrimitives  ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (Entity&);
    
  private:
    Entity (EntityImpl*);
    
  private:
    EntityImpl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (Entity&, Entity&);

}

#endif
