#ifndef RENDER_MANAGER_FRAME_HEADER
#define RENDER_MANAGER_FRAME_HEADER

#include <math/matrix.h>

#include <render/common.h>
#include <render/entity.h>
#include <render/render_target.h>

namespace render
{

//implementation forwards
class FrameImpl;
class RectAreaImpl;
class Wrappers;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Флаги очистки
///////////////////////////////////////////////////////////////////////////////////////////////////
enum ClearFlag
{
  ClearFlag_RenderTarget  = 1, //очистка буфера цвета
  ClearFlag_Depth         = 2, //очистка буфера глубины
  ClearFlag_Stencil       = 4, //очистка буфера трафарета
  ClearFlag_ViewportOnly  = 8, //очистка только области вывода (могут быть потери производительности)

  ClearFlag_DepthStencil = ClearFlag_Depth | ClearFlag_Stencil,
  ClearFlag_All          = ClearFlag_DepthStencil | ClearFlag_RenderTarget
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Прямоугольная область (для совместного доступа нескольких областей вывода)
///////////////////////////////////////////////////////////////////////////////////////////////////
class RectArea
{
  friend class Wrappers;
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    RectArea  ();
    RectArea  (const render::Rect&);
    ~RectArea ();
    
    RectArea& operator = (const RectArea&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Размеры области
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                SetRect (const render::Rect& rect);
    void                SetRect (int x, int y, size_t width, size_t height);
    const render::Rect& Rect    () const;
    int                 X       () const;
    int                 Y       () const;
    size_t              Width   () const;
    size_t              Height  () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (RectArea&);
  
  private:
    RectArea (RectAreaImpl*);
    
  private:
    RectAreaImpl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (RectArea&, RectArea&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры отрисовки объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
struct EntityDrawParams
{
  common::PropertyMap& properties; //свойства пары фрейм-объект
  math::mat4f&         mvp_matrix; //матрица model-view-projection
  
  EntityDrawParams (common::PropertyMap& in_properties, math::mat4f& in_mvp_matrix) : properties (in_properties), mvp_matrix (in_mvp_matrix) {}
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Визуализируемый кадр
///////////////////////////////////////////////////////////////////////////////////////////////////
class Frame
{
  friend class Wrappers;
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    Frame  (const Frame&);
    ~Frame ();

    Frame& operator = (const Frame&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация целевых буферов отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetRenderTarget        (const char* name, const render::RenderTarget& target);
    void SetRenderTarget        (const char* name, const render::RenderTarget& target, const RectArea& viewport);
    void SetRenderTarget        (const char* name, const render::RenderTarget& target, const RectArea& viewport, const RectArea& scissor);
    void RemoveRenderTarget     (const char* name);
    void RemoveAllRenderTargets ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение целевых буферов отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool                  HasRenderTarget (const char* name) const;
    render::RenderTarget  RenderTarget    (const char* name) const;
    RectArea              Viewport        (const char* name) const;
    RectArea              Scissor         (const char* name) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление отсечением
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetScissorState (bool state);
    bool ScissorState    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Флаги очистки кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    void   SetClearFlags (size_t clear_flags);
    size_t ClearFlags    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры очистки буфера цвета
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetClearColor (const math::vec4f& color);
    const math::vec4f& ClearColor    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры очистки буфера попиксельного отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
    void          SetClearDepthValue   (float depth_value);
    void          SetClearStencilIndex (unsigned char stencil_index);
    float         ClearDepthValue      () const;
    unsigned char ClearStencilIndex    () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Локальные текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetLocalTexture        (const char* name, const Texture& texture);
    void RemoveLocalTexture     (const char* name);
    void RemoveAllLocalTextures ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение локальной текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool    HasLocalTexture (const char* name) const;
    Texture LocalTexture    (const char* name) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка эффекта рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void        SetEffect (const char* name);
    const char* Effect    () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Свойства рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                       SetProperties (const common::PropertyMap&);
    const common::PropertyMap& Properties    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Список отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (Frame& frame, Entity& entity, EntityDrawParams& out_params)> EntityDrawHandler;

    size_t EntitiesCount     () const;
    void   AddEntity         (const Entity& entity);
    void   AddEntity         (const Entity& entity, const common::PropertyMap& properties, const math::mat4f& mvp_matrix = math::mat4f (1.0f));
    void   AddEntity         (const Entity& entity, const EntityDrawHandler& handler);
    void   RemoveAllEntities ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление кадра (порядок отрисовки определяется по тэгам при описании эффекта)
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t FramesCount     () const;
    void   AddFrame        (const Frame& frame);
    void   RemoveAllFrames ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление всех объектов из кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RemoveAllFramesAndEntities ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление кэшированием
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateCache ();
    void ResetCache  ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (Frame&);
    
  private:
    Frame (FrameImpl*);
    
  private:
    FrameImpl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (Frame&, Frame&);

}

#endif
