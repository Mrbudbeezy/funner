#ifndef RENDER_MANAGER_CACHE_HEADER
#define RENDER_MANAGER_CACHE_HEADER

//TODO: добавить базовый класс для временных объектов кэша: инстанцированных списокв параметров, скомпилированных шейдеров

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние кэша
///////////////////////////////////////////////////////////////////////////////////////////////////
enum CacheState
{
  CacheState_Reset,   //кэш сброшен
  CacheState_Valid,   //кэш в актуальном состоянии
  CacheState_Invalid, //кэш в требует обновления
  CacheState_Broken,  //кэш в некорректном состоянии, вызванном ошибкой при обновлении кэша
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Объект, хранящий кэшируемые объекты
///////////////////////////////////////////////////////////////////////////////////////////////////
class CacheHolder: public xtl::noncopyable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    CacheHolder  ();
    ~CacheHolder ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Построение списка связанных хранителей кэша
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AttachCacheSource     (CacheHolder& source);
    void DetachCacheSource     (CacheHolder& source);
    void DetachAllCacheSources ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние кэша
///////////////////////////////////////////////////////////////////////////////////////////////////
    CacheState State () { return state; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Предикаты
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsParentOf (CacheHolder& child);
    bool IsValid    () { return state == CacheState_Valid; }
    bool IsBroken   () { return state == CacheState_Broken; }

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка флага необходимости обновления кэша / зависимых кэшей
///////////////////////////////////////////////////////////////////////////////////////////////////
    void InvalidateCache (bool invalidate_dependencies = true);
    void InvalidateCacheDependencies () { InvalidateCache (true); }
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс кэша
///////////////////////////////////////////////////////////////////////////////////////////////////
    void ResetCache ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление кэша. Необходимо вызывать перед каждым использованием ресурса
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateCache ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Кэшируемый источник требует обновления кэша
///////////////////////////////////////////////////////////////////////////////////////////////////  
    virtual void UpdateCacheCore () = 0;
    virtual void ResetCacheCore  () = 0;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Внутренние методы
///////////////////////////////////////////////////////////////////////////////////////////////////
    void InvalidateFlags ();
    void UpdateCacheAfterReset ();

  private:
    typedef stl::list<CacheHolder*> HolderList;

  private:
    HolderList dependencies;
    HolderList sources;
    CacheState state;
    bool       need_update_this;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Источник кэшированных данных
///////////////////////////////////////////////////////////////////////////////////////////////////
class CacheSource: public CacheHolder
{
  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Кэшируемый источник требует обновления кэша.
///////////////////////////////////////////////////////////////////////////////////////////////////  
    void UpdateCacheCore ();
    void ResetCacheCore  ();
};

#endif
