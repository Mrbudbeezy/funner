class  DynamicPrimitive;
class  DynamicPrimitiveEntityStorage;
struct RendererPrimitive;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание операции рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
struct RendererOperation
{
  EntityImpl*                     entity;                         //объект
  render::low_level::IStateBlock* state_block;                    //блок состояний объекта
  ProgramParametersLayout*        entity_parameters_layout;       //расположение параметров объекта
  const RendererPrimitive*        primitive;                      //примитив
  DynamicPrimitive*               dynamic_primitive;              //динамический примитив, соответствующий операции (может быть 0)
  ShaderOptionsCache*             shader_options_cache;           //кэш опций шейдера
  const RectAreaImpl*             scissor;                        //область отсечения (может быть null)
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание списка операций
///////////////////////////////////////////////////////////////////////////////////////////////////
struct RendererOperationList
{
  size_t                   operations_count; //количество операций
  const RendererOperation* operations;       //операции
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Информация о уровне детализации
///////////////////////////////////////////////////////////////////////////////////////////////////
struct EntityLodDesc
{
  RendererOperationList&         operations;                       //операции рендеринга
  DynamicPrimitiveEntityStorage& dynamic_primitive_storage;        //хранилище динамических примитивов
  bool                           has_frame_dependent_operations;   //есть ли операции зависящие от кадра
  bool                           has_frame_independent_operations; //есть ли операции не зависящие от кадра

  EntityLodDesc (RendererOperationList& in_operations, DynamicPrimitiveEntityStorage& in_storage)
    : operations (in_operations)
    , dynamic_primitive_storage (in_storage)
    , has_frame_dependent_operations ()
    , has_frame_independent_operations ()
  {
  }
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Объект рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class EntityImpl: public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    EntityImpl  (const DeviceManagerPtr&, const TextureManagerPtr&, const PrimitiveManagerPtr&);
    ~EntityImpl ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Хранилище динамических текстур
///////////////////////////////////////////////////////////////////////////////////////////////////
    DynamicTextureEntityStorage& DynamicTextureStorage ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Свойства рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                       SetProperties (const common::PropertyMap&);
    const common::PropertyMap& Properties    ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Макро-определения шейдера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                       SetShaderOptions (const common::PropertyMap&);
    const common::PropertyMap& ShaderOptions    ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Пользовательские данные
///////////////////////////////////////////////////////////////////////////////////////////////////
    void  SetUserData (void* data);
    void* UserData    ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с костями (для скиннинга)
///  преобразования умножаются на матрицу Entity::Transformation в случае если она не единична
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetJointsCount         (size_t count);
    size_t             JointsCount            ();
    void               SetJointTransformation (size_t joint_index, const math::mat4f&);
    const math::mat4f& JointTransformation    (size_t joint_index);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с уровнями детализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t LodsCount ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с примитивом
///////////////////////////////////////////////////////////////////////////////////////////////////
    PrimitivePtr Primitive           (size_t level_of_detail);
    const char*  PrimitiveName       (size_t level_of_detail);  
    void         SetPrimitive        (const PrimitivePtr&, size_t level_of_detail);
    void         SetPrimitive        (const char* name, size_t level_of_detail);
    void         ResetPrimitive      (size_t level_of_detail);
    bool         HasPrimitive        (size_t level_of_detail);
    void         ResetAllPrimitives  ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Точка в локальной системе координат объекта для расчёта удаленности от камеры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetLodPoint (const math::vec3f&);
    const math::vec3f& LodPoint    ();
   
///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление областью отсечения объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    void            SetScissor      (const RectArea& scissor);
    const RectArea& Scissor         ();
    void            SetScissorState (bool state);
    bool            ScissorState    ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение информации об уровне детализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    const EntityLodDesc& GetLod (size_t level_of_detail, bool find_nearest = false);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление кэшированием
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateCache ();
    void ResetCache  ();

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};
