///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер текстур
///////////////////////////////////////////////////////////////////////////////////////////////////
class TextureManager: public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextureManager  (const DeviceManagerPtr&);
    ~TextureManager ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание текстур
///////////////////////////////////////////////////////////////////////////////////////////////////    
    TexturePtr CreateTexture (const media::Image& image, bool generate_mipmaps);
    TexturePtr CreateTexture (const media::Image& image, TextureDimension dimension, bool generate_mipmaps);
    TexturePtr CreateTexture (TextureDimension dimension, size_t width, size_t height, size_t depth, PixelFormat format, bool generate_mipmaps);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка: является ли ресурс текстурой
///////////////////////////////////////////////////////////////////////////////////////////////////
    static bool IsTextureResource (const char* name);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка / выгрузка текстур
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadTexture   (const char* name);
    void UnloadTexture (const char* name);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение прокси
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextureProxy GetTextureProxy (const char* name); //создание прокси в случае отсутствия
    SamplerProxy GetSamplerProxy (const char* name); //создание прокси в случае отсутствия
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск загруженной текстуры / сэмплера
///////////////////////////////////////////////////////////////////////////////////////////////////
    TexturePtr              FindTexture (const char* name);
    LowLevelSamplerStatePtr FindSampler (const char* name);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание динамической текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    DynamicTexturePtr CreateDynamicTexture (const char* name, const EntityPtr& entity);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация динамических текстур
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef RenderManager::DynamicTextureCreator DynamicTextureCreator;

    void RegisterDynamicTexture       (const char* name_mask, const DynamicTextureCreator& creator);
    void UnregisterDynamicTexture     (const char* name_mask);
    void UnregisterAllDynamicTextures ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текстуры по умолчанию / сэмплера по умолчанию
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                    SetDefaultTexture (const TexturePtr& texture);
    void                    SetDefaultSampler (const LowLevelSamplerStatePtr& sampler);
    TexturePtr              DefaultTexture    ();
    LowLevelSamplerStatePtr DefaultSampler    ();
  
  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};
