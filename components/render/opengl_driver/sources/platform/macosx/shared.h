#ifndef RENDER_GL_DRIVER_MACOSX_SHARED_HEADER
#define RENDER_GL_DRIVER_MACOSX_SHARED_HEADER

#include <stl/auto_ptr.h>
#include <stl/list>
#include <stl/string>
#include <stl/vector>

#include <xtl/bind.h>
#include <xtl/common_exceptions.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/reference_counter.h>

#include <common/singleton.h>
#include <common/utf_converter.h>

#include <syslib/dll.h>

#include <render/low_level/utils.h>

#include <shared/log.h>
#include <shared/object.h>
#include <shared/platform.h>

#include <IOGraphicsLib.h>

#include <CGDirectDisplay.h>
#include <CGDisplayConfiguration.h>

#include <agl.h>

namespace render
{

namespace low_level
{

namespace opengl
{

namespace macosx
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Устройство вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
class Output: virtual public IOutput, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Output  (CGDirectDisplayID display_id);
    ~Output ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение имени устройства
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetName ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение списка видео-режимов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetModesCount ();
    void   GetModeDesc   (size_t mode_index, OutputModeDesc& mode_desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текущего видео-режима
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetCurrentMode (const OutputModeDesc&);
    void GetCurrentMode (OutputModeDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление гамма-коррекцией
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetGammaRamp (const Color3f table [256]);
    void GetGammaRamp (Color3f table [256]);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Возвращение внутреннего дескриптора дисплея
///////////////////////////////////////////////////////////////////////////////////////////////////
    CGDirectDisplayID GetDisplayID ();

  private:
    Output (const Output&); //no impl
    Output& operator = (const Output&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Класс, инкапсулирующий работу с низкоуровневыми устройствами вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
class OutputManager
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    OutputManager  ();
    ~OutputManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перечисление доступных устройств вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t  GetOutputsCount () const;
    Output* GetOutput       (size_t index) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск устройства вывода, перекрытие которого с окном максимально
///////////////////////////////////////////////////////////////////////////////////////////////////
    Output* FindContainingOutput (WindowRef window) const;

  private:
    OutputManager (const OutputManager&); //no impl
    OutputManager& operator = (const OutputManager&); //no impl

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Адаптер
///////////////////////////////////////////////////////////////////////////////////////////////////
class Adapter: virtual public IAdapter, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Adapter  ();
    ~Adapter ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя адаптера / описание / путь к модулю
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetPath        ();
    const char* GetName        ();
    const char* GetDescription ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перечисление доступных устройств вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t   GetOutputsCount ();
    IOutput* GetOutput       (size_t index);

  private:
    Adapter (const Adapter&); //no impl
    Adapter& operator = (const Adapter&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контекст устройства отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
class ISwapChainImpl: virtual public ISwapChain
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение/установка контекста
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void       SetContext (AGLContext context) = 0;
    virtual AGLContext GetContext () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение пиксел формата
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual AGLPixelFormat GetPixelFormat () = 0;

  protected:
    virtual ~ISwapChainImpl () {}
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Первичная цепочка обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class PrimarySwapChain: virtual public ISwapChainImpl, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    PrimarySwapChain  (const SwapChainDesc& sc_desc, Adapter* adapter);
    ~PrimarySwapChain ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (SwapChainDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение адаптера
///////////////////////////////////////////////////////////////////////////////////////////////////
    IAdapter* GetAdapter ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение устройства вывода с максимальным размером области перекрытия
///////////////////////////////////////////////////////////////////////////////////////////////////
    IOutput* GetContainingOutput ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен текущего заднего буфера и переднего буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Present ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / взятие состояния full-screen mode
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetFullscreenState (bool state);
    bool GetFullscreenState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация интерфейса ISwapChainImpl
///////////////////////////////////////////////////////////////////////////////////////////////////
    void           SetContext     (AGLContext context);
    AGLContext     GetContext     ();
    AGLPixelFormat GetPixelFormat ();


  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Библиотека функций OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
class Library: public ILibrary, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Library ();
    ~Library ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение адреса точки входа
///////////////////////////////////////////////////////////////////////////////////////////////////
    const void* GetProcAddress (const char* name, size_t search_flags);

  private:
    Library (const Library&); //no impl
    Library& operator = (const Library&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контекст
///////////////////////////////////////////////////////////////////////////////////////////////////
class Context: virtual public IContext, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Context  (ISwapChain* swap_chain, Library* library);
    ~Context ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текущего контектса
///////////////////////////////////////////////////////////////////////////////////////////////////
    void MakeCurrent (ISwapChain* swap_chain);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка совместимости цепочки обмена с контекстом
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsCompatible (ISwapChain* swap_chain);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение интерфейса библиотеки OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    ILibrary& GetLibrary ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подписка на события контекста
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AttachListener (IContextListener*);
    void DetachListener (IContextListener*);

  private:
    Context (const Context&); //no impl
    Context& operator = (const Context&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

//Проверка ошибок
void check_event_manager_error  (OSStatus error_code, const char* source, const char* message);  //проверка ошибок EventManager
void check_quartz_error         (CGError error_code, const char* source, const char* message);   //проверка ошибок Quartz Framework
void check_window_manager_error (OSStatus error_code, const char* source);                       //генерация исключений WindowManager
void check_agl_error            (const char* source);                                            //проверка ошибок Agl Framework
void raise_agl_error            (const char* source);                                            //генерация исключений с информацией об ошибке


}

}

}

}

#endif
