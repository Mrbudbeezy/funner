#ifndef RENDER_GL_DRIVER_GLX_SHARED_HEADER
#define RENDER_GL_DRIVER_GLX_SHARED_HEADER

#include <dlfcn.h>

#include <stl/algorithm>
#include <stl/auto_ptr.h>
#include <stl/hash_map>
#include <stl/vector>

#include <xtl/bind.h>
#include <xtl/intrusive_ptr.h>

#include <common/singleton.h>
#include <common/strlib.h>

#include <syslib/window.h>
#include <syslib/platform/x11.h>

#include <shared/log.h>
#include <shared/object.h>
#include <shared/platform.h>
#include <shared/property_list.h>

#include <GL/gl.h>
#include <GL/glx.h>

#include <X11/Xlib.h>
#include <X11/extensions/Xrandr.h>
#include <X11/extensions/xf86vmode.h>

namespace render
{

namespace low_level
{

namespace opengl
{

namespace glx
{

//forward declarations
class Adapter;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Устройство вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
class Output: virtual public IOutput, public Object
{
  public:
    typedef xtl::com_ptr<Output> Pointer;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////    
    Output  (Display* display, int screen_number);
    ~Output ();    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение имени
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetName ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение имени
///////////////////////////////////////////////////////////////////////////////////////////////////
    int GetScreenNumber ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение списка видео-режимов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetModesCount ();
    void   GetModeDesc   (size_t mode_index, OutputModeDesc& mode_desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текущего видео-режима
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetCurrentMode (const OutputModeDesc&);
    void GetCurrentMode (OutputModeDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление гамма-коррекцией
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetGammaRamp (const Color3f table [256]);
    void GetGammaRamp (Color3f table [256]);
    
  private:
    Output (const Output&); //no impl
    Output& operator = (const Output&); //no impl
    
  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Класс, инкапсулирующий работу с низкоуровневыми устройствами вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
class OutputManager
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    OutputManager  ();
    ~OutputManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перечисление доступных устройств вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t  GetOutputsCount () const;
    Output* GetOutput       (size_t index) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск устройства вывода, перекрытие которого с окном максимально
///////////////////////////////////////////////////////////////////////////////////////////////////
    Output* FindContainingOutput (Window window) const;

  private:
    OutputManager (const OutputManager&); //no impl
    OutputManager& operator = (const OutputManager&); //no impl

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Слушатель события потери контекста
///////////////////////////////////////////////////////////////////////////////////////////////////
class IContextLostListener
{
  public:
    virtual void OnLostCurrent () = 0;

  protected:
    virtual ~IContextLostListener () {}
};

class DynamicLibrary;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Загружаемая библиотека OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
class AdapterLibrary: virtual public ILibrary, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка библиотеки
///////////////////////////////////////////////////////////////////////////////////////////////////
    static AdapterLibraryPtr LoadLibrary (const char* path);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ~AdapterLibrary ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Путь к библиотеке
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetName ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с областью рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    GLXPbuffer CreatePbuffer  (Display *dpy, GLXFBConfig config, const int *attrib_list); //создание внеэкранной области рендеринга
    void       DestroyPbuffer (Display *dpy, GLXPbuffer pbuf);                            //уничтожение внеэкранной области рендеринга

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание и удаление контекста
///////////////////////////////////////////////////////////////////////////////////////////////////
    GLXContext CreateContext (Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct); //создание нового контекста GLX-рендеринга
    void       DestroyContext (Display *dpy, GLXContext ctx); //удаление контекста GLX-рендеринга

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текущего контекста
///////////////////////////////////////////////////////////////////////////////////////////////////
    void MakeCurrent (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx, IContextLostListener* = 0);
                              
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение текущего контекста и drawable
///////////////////////////////////////////////////////////////////////////////////////////////////
    GLXContext  GetCurrentContext      (); //получение текущего контекста
    GLXDrawable GetCurrentDrawable     (); //получение текущей области drawable
    GLXDrawable GetCurrentReadDrawable (); //получение текущей области drawable для чтения
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конфигурация буфера кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    int          GetFBConfigAttrib (Display *dpy, GLXFBConfig config, int attribute, int *value); //возвращает список конфигураций GLX-буфера кадра, соответствующих заданным атрибутам
    GLXFBConfig* GetFBConfigs      (Display *dpy, int screen, int *nelements) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен содержимого рабочего и фонового буферов
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void SwapBuffers (Display *dpy, GLXDrawable drawable) = 0;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение адреса точки входа
///////////////////////////////////////////////////////////////////////////////////////////////////
    const void* GetProcAddress (const char* name, size_t search_flags);

  private:
    AdapterLibrary (stl::auto_ptr<DynamicLibrary>&);
    
  private:
    AdapterLibrary (const AdapterLibrary&);             //no impl
    AdapterLibrary& operator = (const AdapterLibrary&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

typedef xtl::intrusive_ptr<AdapterLibrary> AdapterLibraryPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Адаптер
///////////////////////////////////////////////////////////////////////////////////////////////////
class Adapter: virtual public IAdapter, public Object
{
  friend class Output;
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Adapter  (const char* name, const char* dll_path, const char* init_string);
    ~Adapter ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя адаптера / путь к модулю / описание
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetName        ();
    const char* GetPath        ();
    const char* GetDescription ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перечисление доступных устройств вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t   GetOutputsCount ();
    IOutput* GetOutput       (size_t index);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Библиотека
///////////////////////////////////////////////////////////////////////////////////////////////////
    IAdapterLibrary& GetLibrary ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Запрос устройства вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    Output::Pointer GetOutput (Window window);

  private:
    Adapter (const Adapter&); //no impl
    Adapter& operator = (const Adapter&); //no impl    

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Первичная цепочка обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class PrimarySwapChain: virtual public ISwapChain, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    PrimarySwapChain  (Adapter* adapter, const SwapChainDesc& desc);
    ~PrimarySwapChain ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение адаптера
///////////////////////////////////////////////////////////////////////////////////////////////////
    IAdapter* GetAdapter ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (SwapChainDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение устройства вывода с максимальным размером области перекрытия
///////////////////////////////////////////////////////////////////////////////////////////////////
    IOutput* GetContainingOutput ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / взятие состояния full-screen mode
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetFullscreenState (bool state);
    bool GetFullscreenState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен текущего заднего буфера и переднего буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Present ();    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Список свойств устройства вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    IPropertyList* GetProperties ();

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контекст
///////////////////////////////////////////////////////////////////////////////////////////////////
class Context: virtual public IContext, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Context  (ISwapChain* swap_chain);
    ~Context ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текущего контектса
///////////////////////////////////////////////////////////////////////////////////////////////////
    void MakeCurrent (ISwapChain* swap_chain);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка совместимости цепочки обмена с контекстом
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsCompatible (ISwapChain* swap_chain);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение интерфейса библиотеки OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    IAdapterLibrary& GetLibrary ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подписка на события контекста
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AttachListener (IContextListener*);
    void DetachListener (IContextListener*);

  private:
    Context (const Context&); //no impl
    Context& operator = (const Context&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка ошибок
///////////////////////////////////////////////////////////////////////////////////////////////////
void check_errors (const char* source);
void raise_error  (const char* source);

using syslib::x11::DisplayManager;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Блокировка соединения X11
///////////////////////////////////////////////////////////////////////////////////////////////////
class DisplayLock
{
  public:
    DisplayLock () : display ((Display*)DisplayManager::DisplayHandle ())
    {
      XLockDisplay (display);    
    }
  
    DisplayLock (Display* in_display) : display (in_display)
    {
      XLockDisplay (display);
    }

    ~DisplayLock ()
    {
      XUnlockDisplay (display);
    }

  private:
    Display* display;
};


}

}

}

}

#endif
