#ifndef RENDER_GL_DRIVER_QUERY_MANAGER_SHARED_HEADER
#define RENDER_GL_DRIVER_QUERY_MANAGER_SHARED_HEADER

#include <xtl/common_exceptions.h>
#include <xtl/trackable_ptr.h>

#include <shared/context_object.h>
#include <shared/query_manager.h>

namespace render
{

namespace low_level
{

namespace opengl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Элементы таблицы локальных данных контекста
///////////////////////////////////////////////////////////////////////////////////////////////////
enum QueryManagerCacheEntry
{
  CacheEntry_IsInQueryRanges = CacheEntry_QueryManagerPrivateFirst  //находимся ли в рамках begin-end
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерфейс запроса, имеющего границы
///////////////////////////////////////////////////////////////////////////////////////////////////
class IQueryScope: virtual public IQuery
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Указание границ запроса
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Begin () = 0;
    virtual void End   () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка на совместимость
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual bool IsCompatible (const ContextManager&) = 0;

  protected:
    virtual ~IQueryScope () {}
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Расширенный интерфейс предиката
///////////////////////////////////////////////////////////////////////////////////////////////////
class IOpenGlPredicate: virtual public IPredicate
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение результата отрисовки
///  (операция может привести к остановке выполнения нити до завершения отрисовки)
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual bool GetResult () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение доступности результата отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual bool IsResultAvailable () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип запроса
///////////////////////////////////////////////////////////////////////////////////////////////////  
    QueryType GetType () { return QueryType_OcclusionPredicate; }
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение данных
///////////////////////////////////////////////////////////////////////////////////////////////////  
    void GetData (size_t size, void* data)
    {
      if (size < sizeof (OcclusionPredicateQueryDesc))
        throw xtl::make_argument_exception ("render::low_level::opengl::IOpenGlPredicate::GetData", "size", size, "Size is too small");

      *reinterpret_cast<OcclusionPredicateQueryDesc*> (data) = GetResult ();
    }

    bool TryGetData (size_t size, void* data)
    {
      if (size < sizeof (OcclusionPredicateQueryDesc))
        return false;

      if (!IsResultAvailable ())
        return false;

      *reinterpret_cast<OcclusionPredicateQueryDesc*> (data) = GetResult ();

      return true;
    }
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Предикат, создаваемый при отсутствии аппаратной поддержки occlusion query
///////////////////////////////////////////////////////////////////////////////////////////////////
class NullPredicate : virtual public IOpenGlPredicate, virtual public IQueryScope, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Указание границ запроса
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Begin () {}
    void End   () {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка на совместимость
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsCompatible (const ContextManager&) { return true; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение результата отрисовки
///  (операция может привести к остановке выполнения нити до завершения отрисовки)
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool GetResult () { return true; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение доступности результата отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsResultAvailable () { return true; }
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Предикат с асинхронным запросом результатов
///////////////////////////////////////////////////////////////////////////////////////////////////
class AsyncPredicate : virtual public IOpenGlPredicate, virtual public IQueryScope, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    AsyncPredicate  (const ContextManager&);
    ~AsyncPredicate ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Указание границ запроса
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Begin ();
    void End   ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка на совместимость
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsCompatible (const ContextManager&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение результата отрисовки
///  (операция может привести к остановке выполнения нити до завершения отрисовки)
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool GetResult ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение доступности результата отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsResultAvailable ();

  private:
    GLuint query; //OpenGL id запроса
};

}

}

}

#endif
