#ifndef RENDER_GL_DRIVER_OUTPUT_STAGE_SHARED_HEADER
#define RENDER_GL_DRIVER_OUTPUT_STAGE_SHARED_HEADER

#include <stl/list>

#include <xtl/intrusive_ptr.h>
#include <xtl/trackable_ptr.h>
#include <xtl/bind.h>
#include <xtl/uninitialized_storage.h>
#include <xtl/common_exceptions.h>

//#include <common/strlib.h>

#include <render/low_level/utils.h>

#include <shared/context_object.h>
#include <shared/frame_buffer_manager.h>
#include <shared/texture_manager.h>

namespace render
{

namespace low_level
{

namespace opengl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Элементы таблицы локальных данных контекста
///////////////////////////////////////////////////////////////////////////////////////////////////
enum FrameBufferManagerCache
{
  FrameBufferManagerCache_FrameBufferId,         //идентификатор текущего буфера кадра
  FrameBufferManagerCache_BufferAttachment,      //тип буфера
  FrameBufferManagerCache_ClearColorHash,        //хэш цвета очистки буфера цвета
  FrameBufferManagerCache_ClearDepthHash,        //хэш значения очистки буфера глубины
  FrameBufferManagerCache_ClearStencilValue,     //значение очистки буфера трафарета
  FrameBufferManagerCache_ViewportHash,          //хэш состояния области вывода
  FrameBufferManagerCache_ScissorHash,           //хэш состояния области отсечения
  FrameBufferManagerCache_ColorWriteMask,        //маска записи в буфер цвета
  FrameBufferManagerCache_DepthWriteEnable,      //включена ли запись в буфер глубины
  FrameBufferManagerCache_StencilWriteMask,      //маска записи в буфер трафарета
  FrameBufferManagerCache_ScissorEnable,         //включен ли тест отсечения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип цели рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
enum RenderTargetType
{
  RenderTargetType_Color,        //буфер цвета
  RenderTargetType_DepthStencil, //буфер глубина-трафарет
  
  RenderTargetType_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отображение
///////////////////////////////////////////////////////////////////////////////////////////////////
class View: virtual public IView, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    View (const ContextManager&, ITexture* texture, const ViewDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение целевой текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    ITexture* GetTexture ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора / флагов биндинга текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void   GetDesc (ViewDesc&);
    size_t GetBindFlags () const { return bind_flags; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение строкового имени типа текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetTextureTypeName () { return type.name (); }

  private:
    typedef xtl::com_ptr<ITexture> TexturePtr;

  private:
    TexturePtr            texture;    //указатель на текстуру
    const std::type_info& type;       //тип отображения
    ViewDesc              desc;       //дескриптор отображения
    size_t                bind_flags; //флаги биндинга
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерфейс буфера кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class IFrameBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////  
    virtual ~IFrameBuffer () {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Bind () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об отрисовке в целевые буферы
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void InvalidateRenderTargets (const Rect& update_rect) = 0;
    virtual void InvalidateRenderTargets () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление целевых буферов отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void UpdateRenderTargets     () = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерфейс функторов создания буфера кадра / буфера рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef xtl::function<IFrameBuffer* (View* color_view, View* depth_stencil_view)> FrameBufferCreater;
typedef xtl::function<bool (View* color_view, View* depth_stencil_view)>          FrameBufferChecker;
typedef xtl::function<ITexture* (const TextureDesc&)>                             RenderBufferCreater;
typedef xtl::function<ITexture* (ISwapChain*, size_t)>                            ColorBufferCreater;
typedef xtl::function<ITexture* (ISwapChain*)>                                    DepthStencilBufferCreater;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class FrameBufferManager ////???имя
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FrameBufferManager  (const ContextManager&, ISwapChain* default_swap_chain);
    FrameBufferManager  (const FrameBufferManager&);
    ~FrameBufferManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение менеджера контекстов
///////////////////////////////////////////////////////////////////////////////////////////////////
    const ContextManager& GetContextManager () const;
          ContextManager& GetContextManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение цепочки обмена по умолчанию
///////////////////////////////////////////////////////////////////////////////////////////////////
    ISwapChain* GetDefaultSwapChain () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация обработчиков создания буферов кадра и отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RegisterCreater       (const FrameBufferChecker& frame_buffer_checker,const FrameBufferCreater& frame_buffer_creater);
    void RegisterCreater       (const RenderBufferCreater&);
    void RegisterCreater       (const ColorBufferCreater&);
    void RegisterCreater       (const DepthStencilBufferCreater&);
    void UnregisterAllCreaters ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание буфера кадра / буфера рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    IFrameBuffer*  CreateFrameBuffer        (View* color_view, View* depth_stencil_view);
    ITexture*      CreateRenderBuffer       (const TextureDesc&);
    ITexture*      CreateColorBuffer        (ISwapChain* swap_chain, size_t buffer_index);
    ITexture*      CreateDepthStencilBuffer (ISwapChain* swap_chain);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка активного буфера кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetFrameBuffer (ISwapChain* swap_chain, GLenum buffer_type);
    void SetFrameBuffer (size_t fbo_id, size_t cache_id);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверки активности буферов цвета и попиксельного отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetFrameBufferActivity     (bool color_buffer_state, bool depth_stencil_buffer_state);
    bool IsActiveColorBuffer        () const;
    bool IsActiveDepthStencilBuffer () const;

  private:
    FrameBufferManager& operator = (const FrameBufferManager&); //no impl

  private:
    struct Impl;
    xtl::com_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация фабрик буферов кадра / рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
void register_swap_chain_manager (FrameBufferManager&);
void register_fbo_manager        (FrameBufferManager&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderBuffer: virtual public ITexture, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (TextureDesc&);
    const TextureDesc& GetDesc () const { return desc; }
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение типа буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTargetType GetTargetType () const { return target_type; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderBuffer (const ContextManager& context_manager, RenderTargetType target_type);
    RenderBuffer (const ContextManager& context_manager, const TextureDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Изменение размеров
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetSize (size_t width, size_t height);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Bind () = 0;

  private:
    RenderTargetType target_type;  //тип буфера
    TextureDesc      desc;         //дескриптор текстуры
};

}

}

}

#endif
