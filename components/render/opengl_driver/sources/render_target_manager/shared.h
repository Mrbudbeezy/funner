#ifndef RENDER_GL_DRIVER_RENDER_TARGET_MANAGER_SHARED_HEADER
#define RENDER_GL_DRIVER_RENDER_TARGET_MANAGER_SHARED_HEADER

#include <stl/hash_map>

#include <xtl/common_exceptions.h>
#include <xtl/bind.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/trackable_ptr.h>
#include <xtl/uninitialized_storage.h>

#include <common/strlib.h>

#include <render/low_level/utils.h>

#include <shared/context_object.h>
#include <shared/render_target_manager.h>
#include <shared/texture_manager.h>

namespace render
{

namespace low_level
{

namespace opengl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Элементы таблицы локальных данных контекста
///////////////////////////////////////////////////////////////////////////////////////////////////
enum RenderTargetManagerCache
{
  RenderTargetManagerCache_FrameBufferId,         //идентификатор текущего буфера кадра
  RenderTargetManagerCache_BufferAttachment,      //тип буфера
  RenderTargetManagerCache_ClearColorHash,        //хэш цвета очистки буфера цвета
  RenderTargetManagerCache_ClearDepthHash,        //хэш значения очистки буфера глубины
  RenderTargetManagerCache_ClearStencilValue,     //значение очистки буфера трафарета
  RenderTargetManagerCache_ViewportHash,          //хэш состояния области вывода
  RenderTargetManagerCache_ScissorHash,           //хэш состояния области отсечения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип цели рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
enum RenderTargetType
{
  RenderTargetType_Color,        //буфер цвета
  RenderTargetType_DepthStencil, //буфер глубина-трафарет
  
  RenderTargetType_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderBuffer: virtual public ITexture, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (TextureDesc&);
    const TextureDesc& GetDesc () const { return desc; }
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение типа буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTargetType GetTargetType () const { return target_type; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderBuffer (const ContextManager& context_manager, RenderTargetType target_type);
    RenderBuffer (const ContextManager& context_manager, const TextureDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Изменение размеров
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetSize (size_t width, size_t height);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Bind () = 0;

  private:
    RenderTargetType target_type;  //тип буфера
    TextureDesc      desc;         //дескриптор текстуры
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отображение
///////////////////////////////////////////////////////////////////////////////////////////////////
class View: virtual public IView, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    View (const ContextManager&, ITexture* texture, const ViewDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение целевой текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    ITexture* GetTexture ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора / флагов биндинга текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void   GetDesc (ViewDesc&);
    size_t GetBindFlags () const { return bind_flags; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение строкового имени типа текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetTextureTypeName () { return type.name (); }

  private:
    typedef xtl::com_ptr<ITexture> TexturePtr;

  private:
    TexturePtr            texture;    //указатель на текстуру
    const std::type_info& type;       //тип отображения
    ViewDesc              desc;       //дескриптор отображения
    size_t                bind_flags; //флаги биндинга
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерфейс буфера кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class IFrameBuffer: public xtl::trackable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////  
    virtual ~IFrameBuffer () {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Bind () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об отрисовке в целевые буферы
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void InvalidateRenderTargets (const Rect& update_rect) = 0;
    virtual void InvalidateRenderTargets () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление целевых буферов отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void UpdateRenderTargets () = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Функторы создания буфера кадра / буфера рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef xtl::function<IFrameBuffer* (View* render_target_view, View* depth_stencil_view)> FrameBufferCreater;
typedef xtl::function<bool (View* render_target_view, View* depth_stencil_view)>          FrameBufferChecker;
typedef xtl::function<ITexture* (const TextureDesc&)>                                     RenderBufferCreater;
typedef xtl::function<ITexture* (ISwapChain*, size_t)>                                    ColorBufferCreater;
typedef xtl::function<ITexture* (ISwapChain*)>                                            DepthStencilBufferCreater;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерфейс реестра буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderTargetRegistry
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTargetRegistry  ();
    ~RenderTargetRegistry ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация обработчиков создания буферов кадра и отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RegisterCreater (const FrameBufferChecker& frame_buffer_checker, const FrameBufferCreater& frame_buffer_creater);
    void RegisterCreater (const RenderBufferCreater&);
    void RegisterCreater (const ColorBufferCreater&);
    void RegisterCreater (const DepthStencilBufferCreater&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание буферов рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    ITexture* CreateRenderBuffer       (const TextureDesc& desc);
    ITexture* CreateColorBuffer        (ISwapChain* swap_chain, size_t index);
    ITexture* CreateDepthStencilBuffer (ISwapChain* swap_chain);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение буфера кадра по двум отображениям
///////////////////////////////////////////////////////////////////////////////////////////////////
    IFrameBuffer& GetFrameBuffer (View* render_target_view, View* depth_stencil_view);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Освобождение ресурсов, связанных с отображением
///////////////////////////////////////////////////////////////////////////////////////////////////
    void ReleaseResources (View*);

  private:
    RenderTargetRegistry (const RenderTargetRegistry&); //no impl
    RenderTargetRegistry& operator = (const RenderTargetRegistry&); //no impl
    
    IFrameBuffer* CreateFrameBuffer (View* render_target_view, View* depth_stencil_view);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация фабрик буферов кадра / рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
void register_swap_chain_manager (RenderTargetRegistry& registry, const ContextManager& manager, ISwapChain* default_swap_chain);
void register_fbo_manager        (RenderTargetRegistry& registry, const ContextManager& manager, ISwapChain* default_swap_chain);

}

}

}

#endif
