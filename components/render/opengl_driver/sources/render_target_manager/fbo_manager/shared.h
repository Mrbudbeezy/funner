#ifndef RENDER_GL_DRIVER_RENDER_TARGET_MANAGER_FBO_MANAGER_SHARED_HEADER
#define RENDER_GL_DRIVER_RENDER_TARGET_MANAGER_FBO_MANAGER_SHARED_HEADER

#include "../shared.h"

namespace render
{

namespace low_level
{

namespace opengl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class FboFrameBufferManager: public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FboFrameBufferManager (const ContextManager&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание буферов рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    ITexture* CreateRenderBuffer (const TextureDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    static bool          IsSupported       (View* color_view, View* depth_stencil_view);
           IFrameBuffer* CreateFrameBuffer (View* color_view, View* depth_stencil_view);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текущего буфера кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetFrameBuffer (unsigned int fbo_id, size_t cache_id);
};

typedef xtl::com_ptr<FboFrameBufferManager> FrameBufferManagerPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер отрисовки, создаваемый посредством расширения EXT_framebuffer_object
///////////////////////////////////////////////////////////////////////////////////////////////////
class FboRenderBuffer: public RenderBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FboRenderBuffer  (const FrameBufferManagerPtr& manager, const TextureDesc& desc);
    ~FboRenderBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Внутренний OpenGL идентификатор буфера рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    int GetRenderBufferId () const { return render_buffer_id; }

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение OpenGL идентификатора буфера кадра для возможности ручной записи / чтения данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    unsigned int GetFrameBufferId ();

  private:
    FrameBufferManagerPtr frame_buffer_manager; //менеджер буферов кадра
    GLuint                render_buffer_id;     //идентификатор буфера рендеринга
    GLuint                frame_buffer_id;      //идентификатор буфера кадра, используемого для установки/чтения данных
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер кадра на основе расширения EXT_framebuffer_object
///////////////////////////////////////////////////////////////////////////////////////////////////
class FboFrameBuffer: public IFrameBuffer, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FboFrameBuffer  (const FrameBufferManagerPtr&, View* color_view, View* depth_stencil_view);
    ~FboFrameBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об отрисовке в целевые буферы
///////////////////////////////////////////////////////////////////////////////////////////////////
    void InvalidateRenderTargets (unsigned int, const Rect&) {}
    void InvalidateRenderTargets (unsigned int) {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление целевых текстур
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateRenderTargets () {}

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка целевых отображений
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetAttachment (RenderTargetType target_type, View* view);
    void SetAttachment (RenderTargetType target_type, IRenderTargetTexture* texture, const ViewDesc& view_desc, const TextureDesc& texture_desc);
    void SetAttachment (RenderTargetType target_type, FboRenderBuffer* render_buffer);
    void SetAttachment (GLenum textarget, GLenum attachment, unsigned int texture_id, const ViewDesc& view_desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Завершение инициализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    void FinishInitialization ();

  private:
    FrameBufferManagerPtr frame_buffer_manager;   //менеджер буферов кадра
    GLuint                id;                     //идентификатор буфера кадра
    bool                  is_color_buffer_active; //активен ли буфер цвета
};

//проверка состояния текущего буфера кадра
void check_frame_buffer_status (const char* source, GLenum status);

}

}

}

#endif
