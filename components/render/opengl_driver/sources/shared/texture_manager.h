#ifndef RENDER_GL_DRIVER_TEXTURE_MANAGER_HEADER
#define RENDER_GL_DRIVER_TEXTURE_MANAGER_HEADER

#include <render/low_level/device.h>
#include <shared/context_manager.h>
#include <shared/stage_state.h>
#include <stl/auto_ptr.h>

namespace render
{

namespace low_level
{

namespace opengl
{

//implementation forwards
struct TextureExtesions;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Внутренний дескриптор целевой текстуры отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
struct RenderTargetTextureDesc: public TextureDesc
{
  GLenum target; //тип текстуры
  size_t id;     //идентификатор текстуры
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор mip-уровня текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
struct MipLevelDesc
{
  size_t width, height; //ширина / высота изображения на уровне
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Целевая текстура отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
  //!!!сделать IBindabletexture / BindableTexture!!!!
class IRenderTargetTexture: virtual public IObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора целевой текстуры отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void GetDesc (RenderTargetTextureDesc&) = 0;
    virtual void GetMipLevelDesc (size_t level, MipLevelDesc& desc) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текстуры в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Bind () = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер текстур
///////////////////////////////////////////////////////////////////////////////////////////////////
class TextureManager
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextureManager  (const ContextManager&);
    ~TextureManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание объекта состояния уровня
///////////////////////////////////////////////////////////////////////////////////////////////////
    IStageState* CreateStageState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Биндинг текстур и сэмплеров
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание текстуры и сэмплера
///////////////////////////////////////////////////////////////////////////////////////////////////
    ITexture*      CreateTexture      (const TextureDesc&, const TextureData*);
    ISamplerState* CreateSamplerState (const SamplerDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текущей текстуры и сэмплера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void           SetTexture (size_t sampler_slot, ITexture* texture);
    void           SetSampler (size_t sampler_slot, ISamplerState* state);
    ITexture*      GetTexture (size_t sampler_slot) const;
    ISamplerState* GetSampler (size_t sampler_slot) const;

  private:
    TextureManager (const TextureManager&);             //no impl
    TextureManager& operator = (const TextureManager&); //no impl
    
  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

}

}

}

#endif
