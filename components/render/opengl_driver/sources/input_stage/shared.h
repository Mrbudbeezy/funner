#ifndef RENDER_GL_DRIVER_INPUT_STAGE_SHARED_HEADER
#define RENDER_GL_DRIVER_INPUT_STAGE_SHARED_HEADER

#include <string.h>

#include <stl/algorithm>
#include <stl/hash_map>
#include <stl/vector>

#include <xtl/array>
#include <xtl/bind.h>
#include <xtl/common_exceptions.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/trackable_ptr.h>
#include <xtl/uninitialized_storage.h>

#include <common/singleton.h>
#include <common/string.h>
#include <common/hash.h>

#include <render/low_level/utils.h>

#include <shared/input_stage.h>
#include <shared/context_object.h>
#include <shared/object.h>

namespace render
{

namespace low_level
{

namespace opengl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Элементы таблицы локальных данных контекста
///////////////////////////////////////////////////////////////////////////////////////////////////
enum InputStageCacheEntry
{
  CacheEntry_BindedVboBuffer = CacheEntry_InputStagePrivateFirst, //ID текущего забинденного буфера
  CacheEntry_EnabledSemantics,        //маска используемых семантик вершинных атрибутов
  CacheEntry_CurrentBaseVertex,       //текущая базовая вершина
  CacheEntry_CurrentLayoutHash,       //хэш атрибутов layout'а
  CacheEntry_CurrentBuffersHash,      //хэш установленных вершинных буферов
  CacheEntry_CurrentShaderLayoutHash, //хэш расположения вершинных атрибутов
  CacheEntry_EnabledShaderSemantics,  //маска используемых семантик шейдерных вершинных атрибутов
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вершинный буфер
///////////////////////////////////////////////////////////////////////////////////////////////////
class Buffer: public IBindableBuffer, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Buffer (const ContextManager&, const BufferDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка типа буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool         IsVertexBuffer () const { return (desc.bind_flags & BindFlag_VertexBuffer) != 0; }
    bool         IsIndexBuffer  () const { return (desc.bind_flags & BindFlag_IndexBuffer) != 0; }
    unsigned int GetBindFlags   () const { return desc.bind_flags; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (BufferDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (unsigned int offset, unsigned int size, const void* data, IDeviceContext*);
    void GetData (unsigned int offset, unsigned int size, void* data, IDeviceContext*);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / чтение данных после отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void SetDataCore (unsigned int offset, unsigned int size, const void* data) = 0;
    virtual void GetDataCore (unsigned int offset, unsigned int size, void* data) = 0;

  private:
    BufferDesc desc; //дескриптор буфера
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Указатель на буфер
///////////////////////////////////////////////////////////////////////////////////////////////////    
typedef xtl::trackable_ptr<Buffer> BufferPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер с хранением в системной памяти
///////////////////////////////////////////////////////////////////////////////////////////////////
class SystemMemoryBuffer: public Buffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SystemMemoryBuffer  (const ContextManager&, const BufferDesc&);
    ~SystemMemoryBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind () {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Указатель на данные буфера
///////////////////////////////////////////////////////////////////////////////////////////////////    
    void* GetDataPointer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение хеша данных (0 - данные не хешируются)
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetDataHash ();

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / чтение данных после отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDataCore (unsigned int offset, unsigned int size, const void* data);
    void GetDataCore (unsigned int offset, unsigned int size, void* data);

  private:
    xtl::uninitialized_storage <char> buffer;                //буфер в системной памяти
    size_t                            data_hash;             //хеш данных
    bool                              need_data_hash_recalc; //данные изменялись
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Input-буфер с хранением в системной памяти
///////////////////////////////////////////////////////////////////////////////////////////////////
class SystemMemoryInputBuffer: public SystemMemoryBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SystemMemoryInputBuffer (const ContextManager&, GLenum target, const BufferDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / чтение данных после отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDataCore (unsigned int offset, unsigned int size, const void* data);
    
  private:
    GLenum target; //целевой тип аппаратного буфера (GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER)
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Константный буфер
///////////////////////////////////////////////////////////////////////////////////////////////////
class ConstantBuffer: public SystemMemoryBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ConstantBuffer (const ContextManager&, const BufferDesc&);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / чтение данных после отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDataCore (unsigned int offset, unsigned int size, const void* data);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер с хранением в видеопамяти с использованием расширения GL_ARB_vertex_buffer_object
///////////////////////////////////////////////////////////////////////////////////////////////////
class VboBuffer: public Buffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    VboBuffer  (const ContextManager&, GLenum target, const BufferDesc&);
    ~VboBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Cмещение от начала буфера (для аппаратных буферов)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void* GetDataPointer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение хеша данных (0 - данные не хешируются)
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetDataHash () { return 0; }

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / чтение данных после отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDataCore (unsigned int offset, unsigned int size, const void* data);
    void GetDataCore (unsigned int offset, unsigned int size, void* data);

  private:
    GLenum target;     //целевой тип аппаратного буфера (GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER)
    GLuint buffer_id;  //номер буфера в контексте OpenGL
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние подуровня расположения геометрии
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputLayout: virtual public IInputLayout, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputLayout  (const ContextManager&, const InputLayoutDesc&, unsigned int ffp_tex_units_count);
    ~InputLayout ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDesc (const InputLayoutDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
//Установка состояния в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
   void Bind (unsigned int                base_vertex,
              unsigned int                base_index,
              BufferPtr*                  vertex_buffers,
              IVertexAttributeDictionary* dictionary,
              Buffer*                     index_buffer,
              IndicesLayout*              out_indices_layout);

  private:
    struct ShaderAttributeLayout;

    void                   BindVertexAttributes (unsigned int base_vertex, BufferPtr* vertex_buffers, ShaderAttributeLayout* shader_layout);
    ShaderAttributeLayout& GetShaderLayout      (IVertexAttributeDictionary& dictionary);
    void                   RemoveShaderLayout   (IVertexAttributeDictionary*);

  private:
    struct GlVertexAttribute;
    struct GlVertexAttributeGroup;

    typedef stl::vector<GlVertexAttribute>                                       GlVertexAttributeArray;
    typedef stl::vector<GlVertexAttributeGroup>                                  GlVertexAttributeGroupArray;
    typedef xtl::intrusive_ptr<ShaderAttributeLayout>                            ShaderAttributeLayoutPtr;
    typedef stl::hash_map<IVertexAttributeDictionary*, ShaderAttributeLayoutPtr> ShaderAttributeLayoutMap;

  private:
    GlVertexAttributeArray      vertex_attributes;       //вершинные атрибуты
    GlVertexAttributeGroupArray vertex_attribute_groups; //группы вершинных атрибутов
    ShaderAttributeLayoutMap    shader_layouts;          //расположение атрибутов шейдера
    common::StringArray         shader_attribute_names;  //имена шейдерных атрибутов
    GLenum                      index_data_type;         //тип индексов
    unsigned int                index_size;              //размер индекса
    unsigned int                index_buffer_offset;     //смещение в индексном буфере до первого индекса
    unsigned int                ffp_tex_units_count;     //количество текстурных юнитов поддерживаемое аппаратно для FFP
    unsigned int                used_semantics_mask;     //маска используемых семантик
    size_t                      attributes_hash;         //хеш атрибутов
};

//получение семантики по имени (returns (VertexAttributeSemantic)-1 if fails)
VertexAttributeSemantic get_semantic_by_name (const char* name);

//получение имени семантики
const char* get_semantic_name (VertexAttributeSemantic semantic);

}

}

}

#endif
