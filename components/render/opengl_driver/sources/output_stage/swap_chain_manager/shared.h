#ifndef RENDER_GL_DRIVER_OUTPUT_STAGE_SWAP_CHAIN_MANAGER_SHARED_HEADER
#define RENDER_GL_DRIVER_OUTPUT_STAGE_SWAP_CHAIN_MANAGER_SHARED_HEADER

#include "../shared.h"

#include <stl/list>

namespace render
{

namespace low_level
{

namespace opengl
{

//forward declarations
class SwapChainFrameBuffer;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер рендеринга цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainRenderBuffer: public RenderBuffer
{
  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainRenderBuffer (const FrameBufferManager& manager, RenderTargetType target_type);
    SwapChainRenderBuffer (const FrameBufferManager& manager, const TextureDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка активного буфера кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetFrameBuffer (ISwapChain* swap_chain, GLenum buffer_type, bool has_depth_stencil);

  private:
    FrameBufferManager frame_buffer_manager; //менеджер буферов кадра
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер цвета цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainColorBuffer: public SwapChainRenderBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainColorBuffer (const FrameBufferManager& manager, ISwapChain* swap_chain, size_t buffer_index);
    SwapChainColorBuffer (const FrameBufferManager& manager, ISwapChain* swap_chain, const TextureDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Цепочка обмена и номер буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    ISwapChain* GetSwapChain   () const { return swap_chain.get (); }
    size_t      GetBufferIndex () const { return buffer_index; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип буфера
///////////////////////////////////////////////////////////////////////////////////////////////////    
    GLenum GetBufferType () const { return buffer_type; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Является ли буфер теневым
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsShadow () const { return is_shadow; }

  private:
    void Bind ();

  private:
    typedef xtl::com_ptr<ISwapChain> SwapChainPtr;

  private:
    SwapChainPtr swap_chain;   //цепочка обмена
    size_t       buffer_index; //индекс буфера обмена в цепочке обмена
    GLenum       buffer_type;  //тип буфера
    bool         is_shadow;    //является ли буфер теневым
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер попиксельного отсечения цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainDepthStencilBuffer: public SwapChainRenderBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainDepthStencilBuffer  (const FrameBufferManager& manager, ISwapChain* swap_chain);
    SwapChainDepthStencilBuffer  (const FrameBufferManager& manager, ISwapChain* swap_chain, const TextureDesc&);
    ~SwapChainDepthStencilBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Цепочка обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
    ISwapChain* GetSwapChain   () const { return swap_chain.get (); }

  private:
    void Bind ();

  private:
    typedef xtl::com_ptr<ISwapChain> SwapChainPtr;

  private:
    SwapChainPtr swap_chain; //цепочка обмена
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер попиксельного отсечения, необходимый для сочетания с буферами цвета
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainFakeDepthStencilBuffer: virtual public ITexture, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainFakeDepthStencilBuffer  (const ContextManager&, const TextureDesc&);
    ~SwapChainFakeDepthStencilBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (TextureDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  private:
    TextureDesc desc; //дескриптор текстуры
};

typedef xtl::com_ptr<SwapChainColorBuffer>        ColorBufferPtr;
typedef xtl::com_ptr<SwapChainDepthStencilBuffer> DepthStencilBufferPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainFrameBufferManager: public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainFrameBufferManager  (const FrameBufferManager& manager);
    ~SwapChainFrameBufferManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание целевых буферов вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    ITexture* CreateRenderBuffer       (const TextureDesc&);
    ITexture* CreateColorBuffer        (ISwapChain* swap_chain, size_t buffer_index);
    ITexture* CreateDepthStencilBuffer (ISwapChain* swap_chain);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    static bool          IsSupported       (View* color_view, View* depth_stencil_view);
           IFrameBuffer* CreateFrameBuffer (View* color_view, View* depth_stencil_view);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с теневыми буферами
///////////////////////////////////////////////////////////////////////////////////////////////////
    ColorBufferPtr        GetShadowBuffer  (SwapChainDepthStencilBuffer*);
    DepthStencilBufferPtr GetShadowBuffer  (SwapChainColorBuffer*);
    void                  GetShadowBuffers (ColorBufferPtr&, DepthStencilBufferPtr&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение менеджера буферов кадров
///////////////////////////////////////////////////////////////////////////////////////////////////
    const FrameBufferManager& GetFrameBufferManager () const { return frame_buffer_manager; }
          FrameBufferManager& GetFrameBufferManager ()       { return frame_buffer_manager; }

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с теневыми буферами
///////////////////////////////////////////////////////////////////////////////////////////////////
    ColorBufferPtr        CreateShadowColorBuffer        (SwapChainDepthStencilBuffer*);
    DepthStencilBufferPtr CreateShadowDepthStencilBuffer (SwapChainColorBuffer*);
    SwapChainFrameBuffer* CreateShadowFrameBuffer  ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение цепочки обмена по умолчанию
///////////////////////////////////////////////////////////////////////////////////////////////////
    ISwapChain* GetDefaultSwapChain () const;

  private:
    typedef xtl::trackable_ptr<SwapChainColorBuffer>        ColorBufferTrackablePtr;
    typedef xtl::trackable_ptr<SwapChainDepthStencilBuffer> DepthStencilBufferTrackablePtr;

  private:
    FrameBufferManager             frame_buffer_manager;        //менеджер буферов кадра
    ColorBufferTrackablePtr        shadow_color_buffer;         //теневой буфер цвета
    DepthStencilBufferTrackablePtr shadow_depth_stencil_buffer; //теневой буфер попиксельного отсечения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация буфера кадра для цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainFrameBuffer: public IFrameBuffer, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainFrameBuffer (SwapChainFrameBufferManager& manager, View* color_view, View* depth_stencil_view);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об отрисовке в целевые буферы
///////////////////////////////////////////////////////////////////////////////////////////////////
    void InvalidateRenderTargets (const Rect& update_rect);
    void InvalidateRenderTargets ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление целевых текстур
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateRenderTargets ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Инициализация целевых отображений
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetColorView         (View*);
    void SetDepthStencilView  (View*);
    void FinishInitialization (SwapChainFrameBufferManager&);

  private:
    typedef xtl::com_ptr<IRenderTargetTexture>            TexturePtr;
    typedef xtl::com_ptr<SwapChainFakeDepthStencilBuffer> FakeDepthStencilBufferPtr;

    struct RenderTarget
    {
      ViewDesc                view_desc;      //дескриптор отображения
      TexturePtr              target_texture; //целевая текстура
      MipLevelDesc            mip_level_desc; //дескриптор целевого mip-уровня текстуры
      RenderTargetTextureDesc texture_desc;   //дескриптор целевой текстуры
      
      RenderTarget ();
    };

  private:
    FrameBufferManager        frame_buffer_manager;                    //менеджер буферов кадра
    ColorBufferPtr            color_buffer;                            //буфер цвета
    DepthStencilBufferPtr     depth_stencil_buffer;                    //буфер попиксельного отсечения
    FakeDepthStencilBufferPtr fake_depth_stencil_buffer;               //вспомогательный буфер попиксельного отсечения
    RenderTarget              render_targets [RenderTargetType_Num];   //цели отрисовки
    bool                      is_buffer_active [RenderTargetType_Num]; //активность буферов цвета и попиксельного отсечения
    bool                      has_texture_targets;                     //флаг, определяющий присутствие целевых текстур
    Rect                      dirty_rect;                              //область обновления целевых текстур
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Пустой буфер кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainNullFrameBuffer: public IFrameBuffer, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainNullFrameBuffer (const FrameBufferManager&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об отрисовке в целевые буферы
///////////////////////////////////////////////////////////////////////////////////////////////////
    void InvalidateRenderTargets (const Rect&) {}
    void InvalidateRenderTargets () {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление целевых текстур
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateRenderTargets () {}
    
  private:
    FrameBufferManager frame_buffer_manager; //менеджер буферов кадра
};

}

}

}

#endif
