#ifndef RENDER_GL_DRIVER_OUTPUT_STAGE_SWAP_CHAIN_MANAGER_SHARED_HEADER
#define RENDER_GL_DRIVER_OUTPUT_STAGE_SWAP_CHAIN_MANAGER_SHARED_HEADER

#include "../shared.h"

#include <stl/list>

namespace render
{

namespace low_level
{

namespace opengl
{

//forward declarations
class SwapChainFrameBuffer;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер рендеринга цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainRenderBuffer: public RenderBuffer
{
  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainRenderBuffer (const FrameBufferManager& manager, RenderTargetType target_type);
    SwapChainRenderBuffer (const FrameBufferManager& manager, const TextureDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка активного буфера кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetFrameBuffer (size_t context_id, ISwapChain* swap_chain, GLenum buffer_type);

  private:
    FrameBufferManager frame_buffer_manager; //менеджер буферов кадра
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер цвета цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainColorBuffer: public SwapChainRenderBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainColorBuffer (const FrameBufferManager& manager, ISwapChain* swap_chain, size_t buffer_index);
    SwapChainColorBuffer (const FrameBufferManager& manager, ISwapChain* swap_chain, const TextureDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Цепочка обмена и номер буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    ISwapChain* GetSwapChain   () const { return swap_chain.get (); }
    size_t      GetBufferIndex () const { return buffer_index; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип буфера
///////////////////////////////////////////////////////////////////////////////////////////////////    
    GLenum GetBufferType () const { return buffer_type; }

  private:
    void Bind ();

  private:
    typedef xtl::com_ptr<ISwapChain> SwapChainPtr;

  private:
    SwapChainPtr swap_chain;   //цепочка обмена
    size_t       buffer_index; //индекс буфера обмена в цепочке обмена
    GLenum       buffer_type;  //тип буфера
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер глубины-трафарета цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainDepthStencilBuffer: public SwapChainRenderBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainDepthStencilBuffer  (const FrameBufferManager& manager, ISwapChain* swap_chain);
    SwapChainDepthStencilBuffer  (const FrameBufferManager& manager, ISwapChain* swap_chain, const TextureDesc&);
    ~SwapChainDepthStencilBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Идентификатор контекста
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetContextId () const { return context_id; }

  private:
    void Bind ();

  private:
    size_t context_id; //идентификатор контекста
};

typedef xtl::com_ptr<SwapChainColorBuffer>        ColorBufferPtr;
typedef xtl::com_ptr<SwapChainDepthStencilBuffer> DepthStencilBufferPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainFrameBufferManager: public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainFrameBufferManager  (const FrameBufferManager& manager);
    ~SwapChainFrameBufferManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание целевых буферов вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    ITexture* CreateRenderBuffer       (const TextureDesc&);
    ITexture* CreateColorBuffer        (ISwapChain* swap_chain, size_t buffer_index);
    ITexture* CreateDepthStencilBuffer (ISwapChain* swap_chain);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    static bool          IsSupported       (View* color_view, View* depth_stencil_view);
           IFrameBuffer* CreateFrameBuffer (View* color_view, View* depth_stencil_view);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с теневыми буферами
///////////////////////////////////////////////////////////////////////////////////////////////////
    ColorBufferPtr        GetShadowBuffer  (SwapChainDepthStencilBuffer*);
    DepthStencilBufferPtr GetShadowBuffer  (SwapChainColorBuffer*);
    void                  GetShadowBuffers (ColorBufferPtr&, DepthStencilBufferPtr&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение менеджера буферов кадров
///////////////////////////////////////////////////////////////////////////////////////////////////
    const FrameBufferManager& GetFrameBufferManager () const { return frame_buffer_manager; }
          FrameBufferManager& GetFrameBufferManager ()       { return frame_buffer_manager; }

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с теневыми буферами
///////////////////////////////////////////////////////////////////////////////////////////////////
    ColorBufferPtr        CreateShadowColorBuffer        (SwapChainDepthStencilBuffer*);
    DepthStencilBufferPtr CreateShadowDepthStencilBuffer (SwapChainColorBuffer*);
    SwapChainFrameBuffer* CreateShadowFrameBuffer  ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение цепочки обмена по умолчанию
///////////////////////////////////////////////////////////////////////////////////////////////////
    ISwapChain* GetDefaultSwapChain () const;

  private:
    typedef stl::list<SwapChainColorBuffer*>        ColorBufferList;
    typedef stl::list<SwapChainDepthStencilBuffer*> DepthStencilBufferList;

  private:
    FrameBufferManager     frame_buffer_manager;          //менеджер буферов кадра
    ColorBufferList        shadow_color_buffers;          //список теневых буферов цвета
    DepthStencilBufferList shadow_depth_stencil_buffers;  //список теневых буферов попиксельного отсечения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация буфера кадра для цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainFrameBuffer: public IFrameBuffer, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainFrameBuffer (SwapChainFrameBufferManager& manager, View* color_view, View* depth_stencil_view);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об отрисовке в целевые буферы
///////////////////////////////////////////////////////////////////////////////////////////////////
    void InvalidateRenderTargets (const Rect& update_rect);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление целевых текстур
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateRenderTargets ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Инициализация целевых отображений
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetColorView         (View*);
    void SetDepthStencilView  (View*);
    void FinishInitialization (SwapChainFrameBufferManager&);

  private:
    typedef xtl::com_ptr<IRenderTargetTexture> TexturePtr;

    struct RenderTarget
    {
      ViewDesc                view_desc;      //дескриптор отображения
      TexturePtr              target_texture; //целевая текстура
      MipLevelDesc            mip_level_desc; //дескриптор целевого mip-уровня текстуры
      RenderTargetTextureDesc texture_desc;   //дескриптор целевой текстуры
      
      RenderTarget ();
    };

  private:
    FrameBufferManager    frame_buffer_manager;                    //менеджер буферов кадра
    ColorBufferPtr        color_buffer;                            //буфер цвета
    DepthStencilBufferPtr depth_stencil_buffer;                    //буфер попиксельного отсечения
    RenderTarget          render_targets [RenderTargetType_Num];   //цели отрисовки
    bool                  is_buffer_active [RenderTargetType_Num]; //активность буферов цвета и попиксельного отсечения
    bool                  has_texture_targets;                     //флаг, определяющий присутствие целевых текстур
    Rect                  dirty_rect;                              //область обновления целевых текстур
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Пустой буфер кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainNullFrameBuffer: public IFrameBuffer, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainNullFrameBuffer (const FrameBufferManager&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об отрисовке в целевые буферы
///////////////////////////////////////////////////////////////////////////////////////////////////
    void InvalidateRenderTargets (const Rect&) {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление целевых текстур
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateRenderTargets () {}
    
  private:
    FrameBufferManager frame_buffer_manager; //менеджер буферов кадра
};

}

}

}

#endif
