#ifndef RENDER_GL_DRIVER_OUTPUT_STAGE_FBO_MANAGER_SHARED_HEADER
#define RENDER_GL_DRIVER_OUTPUT_STAGE_FBO_MANAGER_SHARED_HEADER

#include "../shared.h"

#include <xtl/shared_ptr.h>

namespace render
{

namespace low_level
{

namespace opengl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер отрисовки, создаваемый посредством расширения EXT_framebuffer_object
///////////////////////////////////////////////////////////////////////////////////////////////////
class FboRenderBuffer: public RenderBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FboRenderBuffer  (const FrameBufferManager& manager, const TextureDesc& desc);
    ~FboRenderBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Внутренний OpenGL идентификатор буфера рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    int GetRenderBufferId () const { return render_buffer_id; }
    
  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (); 

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение OpenGL идентификатора буфера кадра для возможности ручной записи / чтения данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetFrameBufferId ();

  private:
    FrameBufferManager frame_buffer_manager; //менеджер буферов кадра
    size_t             render_buffer_id;     //идентификатор буфера рендеринга
    size_t             frame_buffer_id;      //идентификатор буфера кадра, используемого для установки/чтения данных
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер кадра на основе расширения EXT_framebuffer_object
///////////////////////////////////////////////////////////////////////////////////////////////////
class FboFrameBuffer: public IFrameBuffer, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////  
    FboFrameBuffer  (const FrameBufferManager&, View* color_view, View* depth_stencil_view);
    ~FboFrameBuffer ();  

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об отрисовке в целевые буферы
///////////////////////////////////////////////////////////////////////////////////////////////////
    void InvalidateRenderTargets (const Rect&) {}
    void InvalidateRenderTargets () {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление целевых текстур
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateRenderTargets () {}    

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка целевых отображений
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetAttachment (RenderTargetType target_type, View* view);
    void SetAttachment (RenderTargetType target_type, IRenderTargetTexture* texture, const ViewDesc& view_desc, const TextureDesc& texture_desc);
    void SetAttachment (RenderTargetType target_type, FboRenderBuffer* render_buffer);
    void SetAttachment (GLenum textarget, GLenum attachment, size_t texture_id, const ViewDesc& view_desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Завершение инициализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    void FinishInitialization ();

  private:
    FrameBufferManager frame_buffer_manager;             //менеджер буферов кадра
    size_t             id;                               //идентификатор буфера кадра
    bool               is_active [RenderTargetType_Num]; //флаги активности целевых буферов
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class FboFrameBufferManager
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FboFrameBufferManager (const FrameBufferManager&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание буферов рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    ITexture* CreateRenderBuffer (const TextureDesc&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    static bool          IsSupported       (View* color_view, View* depth_stencil_view);
           IFrameBuffer* CreateFrameBuffer (View* color_view, View* depth_stencil_view);

  private:
    FrameBufferManager frame_buffer_manager; //менеджер буферов кадра
};

//проверка состояния текущего буфера кадра
void check_frame_buffer_status (const char* source, GLenum status);

}

}

}

#endif
