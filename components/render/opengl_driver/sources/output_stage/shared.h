#ifndef RENDER_GL_DRIVER_OUTPUT_STAGE_SHARED_HEADER
#define RENDER_GL_DRIVER_OUTPUT_STAGE_SHARED_HEADER

#include <memory.h>

#include <stl/list>

#include <xtl/intrusive_ptr.h>
#include <xtl/trackable_ptr.h>
#include <xtl/bind.h>
#include <xtl/uninitialized_storage.h>
#include <xtl/common_exceptions.h>

#include <common/strlib.h>
#include <common/hash.h>

#include <render/low_level/utils.h>

#include <shared/output_stage.h>
#include <shared/context_object.h>
#include <shared/texture_manager.h>

namespace render
{

namespace low_level
{

namespace opengl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Элементы таблицы локальных данных контекста
///////////////////////////////////////////////////////////////////////////////////////////////////
enum OutputStageCache
{
  OutputStageCache_FrameBufferId,         //идентификатор текущего буфера кадра
  OutputStageCache_BufferAttachment,      //тип буфера
  OutputStageCache_ClearColorHash,        //хэш цвета очистки буфера цвета
  OutputStageCache_ClearDepthHash,        //хэш значения очистки буфера глубины
  OutputStageCache_ClearStencilValue,     //значение очистки буфера трафарета
  OutputStageCache_BlendStateHash,        //хэш состояния подуровня смешивания цветов
  OutputStageCache_DepthStencilStateHash, //хэш состояния подуровня попиксельного отсечения
  OutputStageCache_StencilReference,      //ссылочное значение теста трафарета
  OutputStageCache_ViewportHash,          //хэш состояния области вывода
  OutputStageCache_ScissorHash,           //хэш состояния области отсечения
  OutputStageCache_RasterizerStateHash,   //хэш состояния подуровня растеризации
  OutputStageCache_ColorWriteMask,        //маска записи в буфер цвета
  OutputStageCache_DepthWriteEnable,      //включена ли запись в буфер глубины
  OutputStageCache_StencilWriteMask,      //маска записи в буфер трафарета
  OutputStageCache_ScissorEnable,         //включен ли тест отсечения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип цели рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
enum RenderTargetType
{
  RenderTargetType_Color,        //буфер цвета
  RenderTargetType_DepthStencil, //буфер глубина-трафарет
  
  RenderTargetType_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отображение
///////////////////////////////////////////////////////////////////////////////////////////////////
class View: virtual public IView, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    View (const ContextManager&, ITexture* texture, const ViewDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение целевой текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    ITexture* GetTexture ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора / флагов биндинга текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void   GetDesc (ViewDesc&);
    size_t GetBindFlags () const { return bind_flags; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение строкового имени типа текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetTextureTypeName () { return type.name (); }

  private:
    typedef xtl::com_ptr<ITexture> TexturePtr;

  private:
    TexturePtr            texture;    //указатель на текстуру
    const std::type_info& type;       //тип отображения
    ViewDesc              desc;       //дескриптор отображения
    size_t                bind_flags; //флаги биндинга
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерфейс буфера кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class IFrameBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////  
    virtual ~IFrameBuffer () {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Bind () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об отрисовке в целевые буферы
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void InvalidateRenderTargets (const Rect& update_rect) = 0;
    virtual void InvalidateRenderTargets () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление целевых буферов отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void UpdateRenderTargets     () = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерфейс функторов создания буфера кадра / буфера рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef xtl::function<IFrameBuffer* (View* color_view, View* depth_stencil_view)> FrameBufferCreater;
typedef xtl::function<bool (View* color_view, View* depth_stencil_view)>          FrameBufferChecker;
typedef xtl::function<ITexture* (const TextureDesc&)>                             RenderBufferCreater;
typedef xtl::function<ITexture* (ISwapChain*, size_t)>                            ColorBufferCreater;
typedef xtl::function<ITexture* (ISwapChain*)>                                    DepthStencilBufferCreater;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class FrameBufferManager
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FrameBufferManager  (const ContextManager&, ISwapChain* default_swap_chain);
    FrameBufferManager  (const FrameBufferManager&);
    ~FrameBufferManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение менеджера контекстов
///////////////////////////////////////////////////////////////////////////////////////////////////
    const ContextManager& GetContextManager () const;
          ContextManager& GetContextManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение цепочки обмена по умолчанию
///////////////////////////////////////////////////////////////////////////////////////////////////
    ISwapChain* GetDefaultSwapChain () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация обработчиков создания буферов кадра и отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RegisterCreater       (const FrameBufferChecker& frame_buffer_checker,const FrameBufferCreater& frame_buffer_creater);
    void RegisterCreater       (const RenderBufferCreater&);
    void RegisterCreater       (const ColorBufferCreater&);
    void RegisterCreater       (const DepthStencilBufferCreater&);
    void UnregisterAllCreaters ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание буфера кадра / буфера рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    IFrameBuffer*  CreateFrameBuffer        (View* color_view, View* depth_stencil_view);
    ITexture*      CreateRenderBuffer       (const TextureDesc&);
    ITexture*      CreateColorBuffer        (ISwapChain* swap_chain, size_t buffer_index);
    ITexture*      CreateDepthStencilBuffer (ISwapChain* swap_chain);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка активного буфера кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetFrameBuffer (size_t context_id, ISwapChain* swap_chain, GLenum buffer_type);
    void SetFrameBuffer (size_t fbo_id, size_t cache_id);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверки активности буферов цвета и попиксельного отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetFrameBufferActivity     (bool color_buffer_state, bool depth_stencil_buffer_state);
    bool IsActiveColorBuffer        () const;
    bool IsActiveDepthStencilBuffer () const;

  private:
    FrameBufferManager& operator = (const FrameBufferManager&); //no impl

  private:
    struct Impl;
    xtl::com_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация фабрик буферов кадра / рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
void register_swap_chain_manager (FrameBufferManager&);
void register_fbo_manager        (FrameBufferManager&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderBuffer: virtual public ITexture, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (TextureDesc&);
    const TextureDesc& GetDesc () const { return desc; }
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение типа буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTargetType GetTargetType () const { return target_type; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderBuffer (const ContextManager& context_manager, RenderTargetType target_type);
    RenderBuffer (const ContextManager& context_manager, const TextureDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Изменение размеров
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetSize (size_t width, size_t height);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Bind () = 0;

  private:
    RenderTargetType target_type;  //тип буфера
    TextureDesc      desc;         //дескриптор текстуры
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние подуровня смешивания цветов
///////////////////////////////////////////////////////////////////////////////////////////////////
class BlendState: virtual public IBlendState, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    BlendState  (const ContextManager&, const BlendDesc&);
    ~BlendState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка/изменение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDesc (const BlendDesc&);
    void GetDesc (BlendDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка состояния в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

  private:
    BlendDesc desc;         //дескриптор состояния
    size_t    desc_hash;    //хэш дескриптора состояния
    int       display_list; //номер списка команд конфигурации OpenGL
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние подуровня попиксельного отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
class DepthStencilState: virtual public IDepthStencilState, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    DepthStencilState  (const ContextManager&, const DepthStencilDesc&);
    ~DepthStencilState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка/изменение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDesc (const DepthStencilDesc&);
    void GetDesc (DepthStencilDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка состояния в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (size_t stencil_reference);

  private:
    DepthStencilDesc desc;                           //дескриптор состояния
    size_t           desc_hash;                      //хэш дескриптора состояния
    int              display_list;                   //номер списка команд конфигурации OpenGL
    GLenum           gl_stencil_func [FaceMode_Num]; //функции отсечения трафарета
    bool             need_two_side_stencil;          //состояние требует двустороннего трафарета
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние подуровня растеризации
///////////////////////////////////////////////////////////////////////////////////////////////////
class RasterizerState : virtual public IRasterizerState, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RasterizerState  (const ContextManager& manager, const RasterizerDesc& desc);
    ~RasterizerState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка состояния в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Изменение/получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDesc (const RasterizerDesc&);
    void GetDesc (RasterizerDesc&);

  private:
    RasterizerDesc desc;         //дескриптор состояния
    size_t         desc_hash;    //хэш дескриптора состояния
    int            display_list; //номер списка команд конфигурации состояния в OpenGL
};

}

}

}

#endif
