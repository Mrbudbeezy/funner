#ifndef RENDER_GL_DRIVER_OUTPUT_STAGE_SHARED_HEADER
#define RENDER_GL_DRIVER_OUTPUT_STAGE_SHARED_HEADER

#include <string.h>

#include <xtl/common_exceptions.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/trackable_ptr.h>

#include <common/strlib.h>
#include <common/hash.h>

#include <render/low_level/utils.h>

#include <shared/command_list.h>
#include <shared/context_object.h>
#include <shared/output_stage.h>

namespace render
{

namespace low_level
{

namespace opengl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Элементы таблицы локальных данных контекста
///////////////////////////////////////////////////////////////////////////////////////////////////
enum OutputStageCacheEntry
{
  CacheEntry_BlendStateHash = CacheEntry_OutputStagePrivateFirst, //хэш состояния подуровня смешивания цветов
  CacheEntry_DepthStencilStateHash, //хэш состояния подуровня попиксельного отсечения
  CacheEntry_StencilReference,      //ссылочное значение теста трафарета
  CacheEntry_RasterizerStateHash,   //хэш состояния подуровня растеризации
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние подуровня смешивания цветов
///////////////////////////////////////////////////////////////////////////////////////////////////
class BlendState: virtual public IBlendState, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    BlendState  (const ContextManager&, const BlendDesc&);
    ~BlendState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка/изменение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDesc (const BlendDesc&);
    void GetDesc (BlendDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка состояния в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();
    
  private:
    typedef CommandListBuilder::ExecuterPtr ExecuterPtr;

  private:
    BlendDesc   desc;      //дескриптор состояния
    size_t      desc_hash; //хэш дескриптора состояния
    ExecuterPtr executer;  //исполнитель списка команд
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние подуровня попиксельного отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
class DepthStencilState: virtual public IDepthStencilState, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    DepthStencilState  (const ContextManager&, const DepthStencilDesc&);
    ~DepthStencilState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка/изменение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDesc (const DepthStencilDesc&);
    void GetDesc (DepthStencilDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка состояния в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (unsigned int stencil_reference);

  private:
    typedef CommandListBuilder::ExecuterPtr ExecuterPtr;

  private:
    DepthStencilDesc desc;                           //дескриптор состояния
    size_t           desc_hash;                      //хэш дескриптора состояния
    GLenum           gl_stencil_func [FaceMode_Num]; //функции отсечения трафарета
    bool             need_two_side_stencil;          //состояние требует двустороннего трафарета
    ExecuterPtr      executer;                       //исполнитель списка команд
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние подуровня растеризации
///////////////////////////////////////////////////////////////////////////////////////////////////
class RasterizerState : virtual public IRasterizerState, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RasterizerState  (const ContextManager& manager, const RasterizerDesc& desc);
    ~RasterizerState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка состояния в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Изменение/получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDesc (const RasterizerDesc&);
    void GetDesc (RasterizerDesc&);

  private:
    typedef CommandListBuilder::ExecuterPtr ExecuterPtr;

  private:
    RasterizerDesc desc;      //дескриптор состояния
    size_t         desc_hash; //хэш дескриптора состояния
    ExecuterPtr    executer;  //исполнитель списка команд
};

}

}

}

#endif
