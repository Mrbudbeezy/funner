#ifndef RENDER_GL_DRIVER_TEXTURE_SHARED_HEADER
#define RENDER_GL_DRIVER_TEXTURE_SHARED_HEADER

#include <cmath>
#include <cfloat>

#include <stl/algorithm>
#include <stl/auto_ptr.h>

#include <xtl/array>
#include <xtl/common_exceptions.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/shared_ptr.h>
#include <xtl/trackable_ptr.h>
#include <xtl/uninitialized_storage.h>

#include <common/hash.h>

#include <render/low_level/utils.h>

#include <shared/context_object.h>
#include <shared/texture_manager.h>

#include "nv_dxt/blockdxt.h"
#include "nv_dxt/colorblock.h"

#undef min
#undef max

namespace render
{

namespace low_level
{

namespace opengl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Идентификаторы элементов кэша контекстной таблицы
///////////////////////////////////////////////////////////////////////////////////////////////////
enum TextureManagerCacheEntry
{
  CacheEntry_TextureId0 = CacheEntry_TextureManagerPrivateFirst,
  CacheEntry_TextureIdLast = CacheEntry_TextureId0 + DEVICE_SAMPLER_SLOTS_COUNT - 1,
  CacheEntry_TextureTarget0,
  CacheEntry_TextureTargetLast = CacheEntry_TextureTarget0 + DEVICE_SAMPLER_SLOTS_COUNT - 1,
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор слоя текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
struct LayerDesc
{
  GLenum target;    //тип текстуры
  size_t new_index; //индекс слоя в образе получаемом посредством glGetTexImage
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор текстуры устанавливамой в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
struct BindableTextureDesc
{
  size_t target; //целевой тип текстуры
  size_t id;     //идентификатор текстуры
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Данные мип-уровня
///////////////////////////////////////////////////////////////////////////////////////////////////
struct TextureLevelData
{
  size_t      size; //размер буфера
  const void* data; //буфер с данными  
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обёртка для выборки текстурных данных
///////////////////////////////////////////////////////////////////////////////////////////////////
class TextureDataSelector
{
  public: 
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextureDataSelector (const TextureDesc& desc, const TextureData* data);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение данных уровня
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool GetLevelData (size_t width, size_t height, size_t depth, TextureLevelData&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Переход к следующему блоку
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Next ();
    
  private:
    PixelFormat        format;
    const TextureData* data;
    size_t             data_size;
    size_t             index;
    size_t             images_count;
    size_t             offset;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текстура устанавливаемая в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
class BindableTexture: virtual public ITexture, virtual public IRenderTargetTexture, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескрипторов
///////////////////////////////////////////////////////////////////////////////////////////////////
    using ITexture::GetDesc;
    using IRenderTargetTexture::GetDesc;
    
    virtual void GetDesc (BindableTextureDesc&) = 0;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текстуры в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Bind () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение формата пикселей
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual PixelFormat GetFormat () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / получение хэша дескриптора прикрепленного сэмплера
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void   SetSamplerHash (size_t hash) = 0;
    virtual size_t GetSamplerHash () = 0;

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    BindableTexture (const ContextManager& context_manager) : ContextObject (context_manager) {}      
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый класс реализации текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture: public BindableTexture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc         (TextureDesc&);
    void GetDesc         (RenderTargetTextureDesc&);
    void GetDesc         (BindableTextureDesc&); 
    void GetMipLevelDesc (size_t level, MipLevelDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение информации о текстуре
///////////////////////////////////////////////////////////////////////////////////////////////////
    GLenum      GetTarget    () { return target; }      //получение типа текстуры
    GLuint      GetTextureId () { return texture_id; }  //получение идентификатора текстуры
    size_t      GetMipsCount () { return mips_count; }  //получение количества mip-уровней
    PixelFormat GetFormat    () { return desc.format; } //получение формата текстуры

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / получение хэша дескриптора прикрепленного сэмплера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void   SetSamplerHash (size_t hash);
    size_t GetSamplerHash ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текстуры в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);
    
  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture  (const ContextManager&, const TextureDesc& desc, GLenum target, size_t mips_count);
    ~Texture ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Изменение формата текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetFormat (PixelFormat);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора слоя текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void GetLayerDesc (size_t layer, LayerDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                                      GLenum format, GLenum type, const void* buffer) = 0;
    virtual void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                                    GLenum format, size_t buffer_size, const void* buffer) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Генерация mip-уровней
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BuildMipmaps (size_t x, size_t y, size_t z, size_t width, size_t unclamped_width, size_t height, PixelFormat format, const void* data);
    
  private:
    TextureDesc   desc;                //дескриптор текстуры  
    GLenum        target;              //тип текстуры
    GLuint        texture_id;          //идентификатор текстуры
    size_t        mips_count;          //количество мип-уровней
    size_t        binded_sampler_hash; //хэш дескриптора прикрепленного сэмплера
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Одномерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture1D: public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture1D (const ContextManager&, const TextureDesc& texture_desc, const TextureData* data, bool ignore_null_data = false);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Одномерная текстура без возможности изменения части изображения
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture1DNoSubimage: public Texture1D
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture1DNoSubimage (const ContextManager&, const TextureDesc&, const TextureData* data);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);

  private:
    GLenum gl_internal_format;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Двумерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture2D: public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture2D (const ContextManager&, const TextureDesc&, const TextureData* data, bool ignore_null_data = false);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Двумерная текстура без возможности изменения части изображения
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture2DNoSubimage: public Texture2D
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture2DNoSubimage (const ContextManager&, const TextureDesc&, const TextureData* data);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);

  private:
    GLenum gl_internal_format;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текстура со сторонами не степени 2, работающая через расширение GL_EXT_texture_rectangle
///////////////////////////////////////////////////////////////////////////////////////////////////
class TextureNpot: public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextureNpot (const ContextManager&, const TextureDesc& texture_desc, const TextureData* data);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Трёхмерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture3D : public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture3D (const ContextManager&, const TextureDesc&, const TextureData* data);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Кубмап текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class TextureCubemap : public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextureCubemap (const ContextManager&, const TextureDesc&, const TextureData* data);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора слоя текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetLayerDesc (size_t layer, LayerDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текстура со сторонами, масштабированными до ближайшей степени двойки
///////////////////////////////////////////////////////////////////////////////////////////////////
class ScaledTexture: public BindableTexture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ScaledTexture (const ContextManager&, TextureManager&, const TextureDesc& original_desc, const TextureData* data, size_t scaled_width=0, size_t scaled_height=0);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void        GetDesc         (TextureDesc&);
    void        GetDesc         (RenderTargetTextureDesc&);
    void        GetDesc         (BindableTextureDesc&);
    void        GetMipLevelDesc (size_t level, MipLevelDesc& desc);
    PixelFormat GetFormat       ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / получение хэша дескриптора прикрепленного сэмплера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void   SetSamplerHash (size_t hash);
    size_t GetSamplerHash ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текстуры в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);
    
  private:
    typedef xtl::com_ptr<BindableTexture>    TexturePtr;    
    typedef xtl::uninitialized_storage<char> Buffer;

    void ScaleImage (size_t width, size_t height, PixelFormat source_format, const void* src_buffer, Buffer& scaled_buffer, PixelFormat& scaled_format);

  private:
    TexturePtr    shadow_texture;   //теневая текстура, со сторонами кратными степени двойки
    size_t        original_width;   //ширина оригинальной текстуры
    size_t        original_height;  //высота оригинальной текстуры
    float         horisontal_scale; //коэффициент растяжения по горизонтали
    float         vertical_scale;   //коэффициент растяжения по вертикали
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сэмплер
///////////////////////////////////////////////////////////////////////////////////////////////////
class SamplerState : virtual public ISamplerState, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SamplerState  (const ContextManager& manager, const SamplerDesc& desc);
    ~SamplerState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Выбор сэмплера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (GLenum texture_target, bool is_depth);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Изменение/получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDesc (const SamplerDesc&);
    void GetDesc (SamplerDesc&);    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение хэша дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////    
    size_t GetDescHash ();
    
  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Утилиты
///////////////////////////////////////////////////////////////////////////////////////////////////
size_t      get_image_size                      (PixelFormat format, size_t width, size_t height, size_t depth); //получение размера битового образа
size_t      get_next_higher_power_of_two        (size_t size);        //получение ближайшей сверху степени двойки
GLint       get_gl_internal_format              (PixelFormat format); //внутренний формат OpenGL
GLenum      get_gl_format                       (PixelFormat format); //формат OpenGL
GLenum      get_gl_type                         (PixelFormat format); //тип OpenGL
GLenum      get_uncompressed_gl_internal_format (PixelFormat format); //распакованный внутренний формат OpenGL
GLenum      get_uncompressed_gl_format          (PixelFormat format); //распакованный формат OpenGL
GLenum      get_uncompressed_gl_type            (PixelFormat format); //распакованный тип OpenGL
PixelFormat get_pixel_format                    (GLenum gl_format);   //эквивалент внутреннего формата OpenGL

///////////////////////////////////////////////////////////////////////////////////////////////////
///Масштабирование текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
void scale_image_2x_down (PixelFormat format, size_t width, size_t height, const void* src, void* dest);
void scale_image         (PixelFormat format, size_t width, size_t height, size_t new_width, size_t new_height, const void* src, void* dest);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с DXT форматом при остутствии аппаратной поддержки
///////////////////////////////////////////////////////////////////////////////////////////////////
void unpack_dxt (PixelFormat format, size_t width, size_t height, const void* dxt_data, void* unpacked_data);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Копирование изображений различных форматов
///////////////////////////////////////////////////////////////////////////////////////////////////
void copy_image (size_t pixels_count, PixelFormat src_format, const void* src_buffer, PixelFormat dst_format, void* dst_buffer);

}

}

}

#endif
