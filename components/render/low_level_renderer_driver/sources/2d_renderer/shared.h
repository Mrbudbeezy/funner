#ifndef RENDER_MID_LEVEL_LOW_LEVEL_DRIVER_2D_RENDERER_SHARED_HEADER
#define RENDER_MID_LEVEL_LOW_LEVEL_DRIVER_2D_RENDERER_SHARED_HEADER

#include <stl/algorithm>

#include <xtl/common_exceptions.h>

#include <xtl/uninitialized_storage.h>

#include <common/log.h>

#include <media/image.h>

#include <render/low_level/utils.h>

#include <shared/basic_renderer.h>
#include <shared/2d_renderer.h>

namespace render
{

namespace mid_level
{

namespace low_level_driver
{

namespace renderer2d
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Константы
///////////////////////////////////////////////////////////////////////////////////////////////////
const size_t SPRITE_VERTICES_COUNT = 6; //количество вершин в одном спрайте

///////////////////////////////////////////////////////////////////////////////////////////////////
///Переопределения типов
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef xtl::com_ptr<render::low_level::IBlendState>              BlendStatePtr;
typedef xtl::com_ptr<render::low_level::IBuffer>                  BufferPtr;
typedef xtl::com_ptr<render::low_level::IDepthStencilState>       DepthStencilStatePtr;
typedef xtl::com_ptr<render::low_level::IProgram>                 ProgramPtr;
typedef xtl::com_ptr<render::low_level::IProgramParametersLayout> ProgramParametersLayoutPtr;
typedef xtl::com_ptr<render::low_level::ISamplerState>            SamplerStatePtr;
typedef xtl::com_ptr<render::low_level::IInputLayout>             InputLayoutPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры шейдера
///////////////////////////////////////////////////////////////////////////////////////////////////
struct CommonProgramParameters
{
  math::mat4f view_matrix;       //матрица вида
  math::mat4f projection_matrix; //матрица проекции
};

struct DynamicProgramParameters
{
  float alpha_reference; //параметр для работы альфа-теста
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры вершины необходимые для визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
struct RenderableVertex
{
  math::vec3f position; //положение вершины в пространстве
  math::vec2f texcoord; //текстурные координаты
  math::vec4f color;    //цвет вершины
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры примитива необходимые для визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
struct RenderablePrimitive
{
  float                            alpha_reference; //параметр для альфа-теста
  render::low_level::ITexture*     texture;         //текстура
  mid_level::renderer2d::BlendMode blend_mode;      //режим смешивания цветов
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры спрайта необходимые для визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
struct RenderableSprite
{
  RenderablePrimitive* primitive;                        //ссылка на примитив, которому принадлежит спрайт
  RenderableVertex     vertices [SPRITE_VERTICES_COUNT]; //вершины, описывающие спрайт
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Общие ресурсы
///////////////////////////////////////////////////////////////////////////////////////////////////
class CommonResources : public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    CommonResources (render::low_level::IDevice* device);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение низкоуровневых данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    render::low_level::IBlendState*              GetBlendState        (render::mid_level::renderer2d::BlendMode blend_mode) { return blend_states[blend_mode].get (); }
    render::low_level::IDepthStencilState*       GetDepthStencilState (bool depth_write_enabled);
    render::low_level::IProgram*                 GetDefaultProgram    () { return default_program.get (); }
    render::low_level::IProgram*                 GetAlphaClampProgram () { return alpha_clamp_program.get (); }
    render::low_level::IProgramParametersLayout* GetProgramParametersLayout () { return program_parameters_layout.get (); }
    render::low_level::ISamplerState*            GetSamplerState      () { return sampler.get (); }
    render::low_level::IInputLayout*             GetInputLayout       () { return input_layout.get (); }

  private:
    BlendStatePtr              blend_states [render::mid_level::renderer2d::BlendMode_Num];
    DepthStencilStatePtr       depth_stencil_states [2];
    ProgramPtr                 default_program;
    ProgramPtr                 alpha_clamp_program;
    ProgramParametersLayoutPtr program_parameters_layout;
    SamplerStatePtr            sampler;
    InputLayoutPtr             input_layout;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Двумерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class ImageTexture: virtual public mid_level::renderer2d::ITexture, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ImageTexture (render::low_level::IDevice& device, const media::Image& image);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Размеры текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetWidth  ();
    size_t GetHeight ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Формат
///////////////////////////////////////////////////////////////////////////////////////////////////
    media::PixelFormat GetFormat ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Копирование образа текстуры в картинку
///////////////////////////////////////////////////////////////////////////////////////////////////
    void CaptureImage (media::Image&);    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    render::low_level::ITexture* GetTexture ();

  private:
    typedef xtl::com_ptr<render::low_level::ITexture> TexturePtr;
    
  private:
    TexturePtr texture;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Двумерная текстура с возможностью рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderTargetTexture: virtual public mid_level::renderer2d::ITexture, public RenderTarget
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTargetTexture (render::low_level::IDevice& device, size_t width, size_t height, media::PixelFormat format);
    
  private:
    typedef xtl::com_ptr<render::low_level::IView> ViewPtr;
    
  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание отображения
///////////////////////////////////////////////////////////////////////////////////////////////////
    static ViewPtr CreateView (render::low_level::IDevice& device, size_t width, size_t height, media::PixelFormat format);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер визуализируемых спрайтов
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderableSpriteList
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderableSpriteList  ();
    ~RenderableSpriteList ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение количества спрайтов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Size () { return data_buffer.size (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение вершинного буфера / буфера спрайтов
///////////////////////////////////////////////////////////////////////////////////////////////////
    render::low_level::IBuffer* GetVertexBuffer () { return vertex_buffer.get (); }
    const RenderableSprite**    GetSprites      () { return data_buffer.data (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление спрайтов примитива
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Add (size_t sprites_count, const RenderableSprite* sprites);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Резервирование места для размещения указанного числа спрайтов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Reserve (size_t sprites_count);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сортировка геометрии
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class Predicate> void Sort (Predicate pred)
    {
      stl::sort (data_buffer.data (), data_buffer.data () + data_buffer.size (), pred);
    }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Clear ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление вершинного буфера
///////////////////////////////////////////////////////////////////////////////////////////////////    
    void UpdateVertexBuffer (render::low_level::IDevice&);

  private:
    void SetVertexBufferSize (render::low_level::IDevice&, size_t new_vertices);
    
  private:
    typedef xtl::uninitialized_storage<const RenderableSprite*> SpriteArray;

  private:
    size_t      vertex_buffer_vertices_count; //текущее количество вершин в вершинном буфере
    BufferPtr   vertex_buffer;                //вершинный буфер
    SpriteArray data_buffer;                  //временный буфер с данными геометрии
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Примитив
///////////////////////////////////////////////////////////////////////////////////////////////////
class Primitive: virtual public mid_level::renderer2d::IPrimitive, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Primitive  ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Матрица преобразований
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetTransform (const math::mat4f&);
    void GetTransform (math::mat4f&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка базовой текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                             SetTexture (mid_level::renderer2d::ITexture*);
    mid_level::renderer2d::ITexture* GetTexture ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение низкоуровневой текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    render::low_level::ITexture* GetLowLevelTexture () { return renderable_primitive.texture; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим смешивания цветов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                             SetBlendMode (mid_level::renderer2d::BlendMode blend_mode);
    mid_level::renderer2d::BlendMode GetBlendMode ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка параметра для работы альфа-теста
///////////////////////////////////////////////////////////////////////////////////////////////////
    void  SetAlphaReference (float ref);
    float GetAlphaReference ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Спрайты
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetSpritesCount  ();
    void   GetSprite        (size_t index, mid_level::renderer2d::Sprite& sprite);
    size_t AddSprites       (size_t sprites_count, const mid_level::renderer2d::Sprite* sprites);
    void   RemoveSprites    (size_t first_sprite, size_t sprites_count);
    void   RemoveAllSprites ();
    void   ReserveSprites   (size_t sprites_count);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление спрайтов в буфер
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddSprites (RenderableSpriteList& dst_buffer);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление визуализируемых спрайтов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateRenderableSprites ();

  private:
    typedef stl::vector<mid_level::renderer2d::Sprite>    SpriteArray;
    typedef xtl::uninitialized_storage<RenderableSprite>  RenderableSpriteArray;
    typedef xtl::com_ptr<mid_level::renderer2d::ITexture> TexturePtr;

  private:
    math::mat4f           transform;                      //матрица преобразований примитива
    TexturePtr            texture;                        //текстура
    SpriteArray           sprites;                        //массив спрайтов
    RenderablePrimitive   renderable_primitive;           //параметры, необходимые для визуализации примитива
    RenderableSpriteArray renderable_sprites;             //массив визуализируемых спрайтов
    bool                  need_update_transform;          //необходимо обновить положение вершин
    bool                  need_update_renderable_sprites; //необходимо обновить параметры визуализации спрайтов
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Кадр 2D визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
class Frame: virtual public mid_level::renderer2d::IFrame, public BasicFrame
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Frame (CommonResources* in_common_resources, render::low_level::IDevice* device);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Матрица вида / матрица преобразования
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetViewPoint  (const math::vec3f&);
    void SetProjection (const math::mat4f&);
    void GetViewPoint  (math::vec3f&);
    void GetProjection (math::mat4f&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Примитивы
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t PrimitivesCount ();
    void   AddPrimitive    (mid_level::renderer2d::IPrimitive*);
    void   Clear           ();

  private:
    typedef xtl::com_ptr<Primitive>        PrimitivePtr;
    typedef stl::vector<PrimitivePtr>      PrimitiveArray;
    typedef xtl::com_ptr<CommonResources>  CommonResourcesPtr;

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление вершинных буферов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateVertexBuffers (render::low_level::IDevice&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DrawCore (render::low_level::IDevice* device);

  private:
    CommonProgramParameters  common_program_parameters;  //общие параметры программы рендеринга
    BufferPtr                common_constant_buffer;     //константный буфер для хранения общих параметров программы рендеринга
    BufferPtr                dynamic_constant_buffer;    //константный буфер для хранения динамических параметров программы рендеринга
    PrimitiveArray           primitives;                 //массив примитивов
    CommonResourcesPtr       common_resources;           //общие ресурсы
    RenderableSpriteList     not_blended_sprites;        //спрайты без блендинга
    RenderableSpriteList     blended_sprites;            //спрайты с блендингом
};

}

}

}

}

#endif

