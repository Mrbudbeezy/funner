#ifndef RENDER_MID_LEVEL_LOW_LEVEL_DRIVER_2D_RENDERER_SHARED_HEADER
#define RENDER_MID_LEVEL_LOW_LEVEL_DRIVER_2D_RENDERER_SHARED_HEADER

#include <stl/algorithm>

#include <xtl/common_exceptions.h>

#include <xtl/uninitialized_storage.h>

#include <common/log.h>

#include <media/image.h>

#include <render/low_level/utils.h>

#include <shared/basic_renderer.h>
#include <shared/2d_renderer.h>

namespace render
{

namespace mid_level
{

namespace low_level_driver
{

namespace renderer2d
{

typedef xtl::com_ptr<render::low_level::IBlendState>              BlendStatePtr;
typedef xtl::com_ptr<render::low_level::IBuffer>                  BufferPtr;
typedef xtl::com_ptr<render::low_level::IDepthStencilState>       DepthStencilStatePtr;
typedef xtl::com_ptr<render::low_level::IProgram>                 ProgramPtr;
typedef xtl::com_ptr<render::low_level::IProgramParametersLayout> ProgramParametersLayoutPtr;
typedef xtl::com_ptr<render::low_level::ISamplerState>            SamplerStatePtr;
typedef xtl::com_ptr<render::low_level::IInputLayout>             InputLayoutPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Общие ресурсы
///////////////////////////////////////////////////////////////////////////////////////////////////
class CommonResources : public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    CommonResources (render::low_level::IDevice* device);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение низкоуровневых данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    render::low_level::IBlendState*              GetBlendState        (render::mid_level::renderer2d::BlendMode blend_mode) { return blend_states[blend_mode].get (); }
    render::low_level::IBuffer*                  GetConstantBuffer    () { return constant_buffer.get (); }
    render::low_level::IDepthStencilState*       GetDepthStencilState (bool depth_write_enabled);
    render::low_level::IProgram*                 GetDefaultProgram    () { return default_program.get (); }
    render::low_level::IProgram*                 GetAlphaClampProgram () { return alpha_clamp_program.get (); }
    render::low_level::IProgramParametersLayout* GetProgramParametersLayout () { return program_parameters_layout.get (); }
    render::low_level::ISamplerState*            GetSamplerState      () { return sampler.get (); }
    render::low_level::IInputLayout*             GetInputLayout       () { return input_layout.get (); }

  private:
    BlendStatePtr              blend_states [render::mid_level::renderer2d::BlendMode_Num];
    BufferPtr                  constant_buffer;
    DepthStencilStatePtr       depth_stencil_states [2];
    ProgramPtr                 default_program;
    ProgramPtr                 alpha_clamp_program;
    ProgramParametersLayoutPtr program_parameters_layout;
    SamplerStatePtr            sampler;
    InputLayoutPtr             input_layout;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Двумерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class ImageTexture: virtual public mid_level::renderer2d::ITexture, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ImageTexture  (render::low_level::ITexture*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Размеры текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetWidth  ();
    size_t GetHeight ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Формат
///////////////////////////////////////////////////////////////////////////////////////////////////
    media::PixelFormat GetFormat ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Копирование образа текстуры в картинку
///////////////////////////////////////////////////////////////////////////////////////////////////
    void CaptureImage (media::Image&);    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    render::low_level::ITexture* GetTexture ();

  private:
    typedef xtl::com_ptr<render::low_level::ITexture> ITexturePtr;
    
  private:
    ITexturePtr texture;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Двумерная текстура с возможностью рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderTargetTexture: virtual public mid_level::renderer2d::ITexture, public RenderTarget
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTargetTexture (render::low_level::IView* render_target_view);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Данные о вершине, необходимые для сортировки
///////////////////////////////////////////////////////////////////////////////////////////////////
struct SpriteVertexData
{
  struct SpriteVertex
  {
    math::vec3f position;
    math::vec2f texcoord;
  };

  SpriteVertex                     vertices [4];
  math::vec4f                      color;
  render::low_level::ITexture*     texture;
  mid_level::renderer2d::BlendMode blend_mode;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Примитив
///////////////////////////////////////////////////////////////////////////////////////////////////
class Primitive: virtual public mid_level::renderer2d::IPrimitive, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Primitive  ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Матрица преобразований
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetTransform (const math::mat4f&);
    void GetTransform (math::mat4f&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка базовой текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                             SetTexture (mid_level::renderer2d::ITexture*);
    mid_level::renderer2d::ITexture* GetTexture ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение низкоуровневой текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    render::low_level::ITexture* GetLowLevelTexture () { return low_level_texture; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим смешивания цветов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                             SetBlendMode (mid_level::renderer2d::BlendMode blend_mode);
    mid_level::renderer2d::BlendMode GetBlendMode ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Спрайты
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetSpritesCount  ();
    void   GetSprite        (size_t index, mid_level::renderer2d::Sprite& sprite);
    size_t AddSprites       (size_t sprites_count, const mid_level::renderer2d::Sprite* sprites);
    void   RemoveSprites    (size_t first_sprite, size_t sprites_count);
    void   RemoveAllSprites ();
    void   ReserveSprites   (size_t sprites_count);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение данных для отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    SpriteVertexData* GetSpriteVertexBuffer ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Построение вершинных данных для спрайта
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BuildSpriteVertexData (size_t sprite_index);
    void ComputeSpriteTransorm (size_t sprite_index);

  private:
    typedef stl::vector<mid_level::renderer2d::Sprite>    SpriteArray;
    typedef xtl::uninitialized_storage<SpriteVertexData>  SpriteVertexArray;
    typedef xtl::com_ptr<mid_level::renderer2d::ITexture> TexturePtr;

  private:
    math::mat4f                      transform;
    TexturePtr                       texture;
    render::low_level::ITexture      *low_level_texture;
    mid_level::renderer2d::BlendMode blend_mode;
    SpriteArray                      sprites;
    SpriteVertexArray                sprite_vertex_buffer;
    bool                             dirty_transform;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры шейдера
///////////////////////////////////////////////////////////////////////////////////////////////////
struct ProgramParameters
{
  math::mat4f view_matrix;
  math::mat4f projection_matrix;
  float       alpha_reference;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Данные о вершине, необходимые для вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
struct RenderedSpriteVertex
{
  math::vec3f position;
  math::vec2f texcoord;
  math::vec4f color;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер спрайтов
///////////////////////////////////////////////////////////////////////////////////////////////////
class SpriteBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SpriteBuffer  ();
    ~SpriteBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение количества спрайтов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetSpritesCount () { return data_buffer.size (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение вершинного буфера / буфера спрайтов
///////////////////////////////////////////////////////////////////////////////////////////////////
    render::low_level::IBuffer* GetVertexBuffer () { return vertex_buffer.get (); }    
    const SpriteVertexData**    GetSprites      () { return data_buffer.data (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление спрайтов примитива
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Add (size_t sprites_count, const SpriteVertexData* sprites);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Резервирование места для размещения указанного числа спрайтов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Reserve (size_t sprites_count);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сортировка геометрии
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class Predicate> void Sort (Predicate pred)
    {
      stl::sort (data_buffer.data (), data_buffer.data () + data_buffer.size (), pred);
    }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Clear ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление вершинного буфера
///////////////////////////////////////////////////////////////////////////////////////////////////    
    void UpdateVertexBuffer (render::low_level::IDevice&);    

  private:
    void SetVertexBufferSize (render::low_level::IDevice&, size_t new_vertices);
    
  private:
    typedef xtl::uninitialized_storage<const SpriteVertexData*> SpriteVertexArray;

  private:
    size_t            vertex_buffer_vertices_count; //текущее количество вершин в вершинном буфере
    BufferPtr         vertex_buffer;                //вершинный буфер
    SpriteVertexArray data_buffer;                  //временный буфер с данными геометрии
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Кадр 2D визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
class Frame: virtual public mid_level::renderer2d::IFrame, public BasicFrame
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Frame (CommonResources* in_common_resources, render::low_level::IDevice* device);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Матрица вида / матрица преобразования
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetViewPoint  (const math::vec3f&);
    void SetProjection (const math::mat4f&);
    void GetViewPoint  (math::vec3f&);
    void GetProjection (math::mat4f&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка параметра для работы альфа-теста
///////////////////////////////////////////////////////////////////////////////////////////////////
    void  SetAlphaReference (float ref);
    float GetAlphaReference ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Примитивы
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t PrimitivesCount ();
    void   AddPrimitive    (mid_level::renderer2d::IPrimitive*);
    void   Clear           ();

  private:
    typedef xtl::com_ptr<Primitive>        PrimitivePtr;
    typedef stl::vector<PrimitivePtr>      PrimitiveArray;
    typedef xtl::com_ptr<CommonResources>  CommonResourcesPtr;

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление вершинных буферов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateVertexBuffers (render::low_level::IDevice&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DrawCore (render::low_level::IDevice* device);

  private:
    ProgramParameters  program_parameters;  //параметры программы рендеринга
    PrimitiveArray     primitives;          //массив примитивов
    CommonResourcesPtr common_resources;    //общие ресурсы
    SpriteBuffer       not_blended_sprites; //спрайты без блендинга
    SpriteBuffer       blended_sprites;     //спрайты с блендингом
};

}

}

}

}

#endif

