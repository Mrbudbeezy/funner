#ifndef RENDER_MID_LEVEL_LOW_LEVEL_DRIVER_SHARED_HEADER
#define RENDER_MID_LEVEL_LOW_LEVEL_DRIVER_SHARED_HEADER

#include <climits>

#include <stl/string>
#include <stl/vector>

#include <xtl/common_exceptions.h>
#include <xtl/function.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/reference_counter.h>
#include <xtl/shared_ptr.h>
#include <xtl/string.h>

#include <common/log.h>
#include <common/singleton.h>

#include <media/image.h>

#include <render/low_level/device.h>
#include <render/low_level/driver.h>
#include <render/low_level/utils.h>

#include <render/mid_level/driver.h>
#include <render/mid_level/low_level_driver.h>
#include <render/mid_level/renderer2d.h>

#ifdef _MSC_VER
  #pragma warning (disable : 4250) //'class1' : inherits 'class2::member' via dominance
#endif

namespace render
{

namespace mid_level
{

namespace low_level_driver
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый объект
///////////////////////////////////////////////////////////////////////////////////////////////////
class Object: virtual public IObject, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddRef  ();    
    void Release ();
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип целевого буфера отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
enum RenderTargetType
{
  RenderTargetType_Color,        //буфер цвета
  RenderTargetType_DepthStencil, //буфер попиксельного отсечения
  
  RenderTargetType_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Целевой буфер отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderTarget: virtual public IRenderTarget, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTarget (render::low_level::IView* render_target_view, RenderTargetType type);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип целевого буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTargetType GetType () { return type; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Размеры буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetWidth  ();
    size_t GetHeight ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Копирование образа текстуры в картинку
///////////////////////////////////////////////////////////////////////////////////////////////////
    void CaptureImage (media::Image&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение View
///////////////////////////////////////////////////////////////////////////////////////////////////
    render::low_level::IView* GetView () { return render_target_view.get (); } 
  
  private:
    typedef xtl::com_ptr<render::low_level::IView> IViewPtr;

  private:
    IViewPtr         render_target_view;
    RenderTargetType type;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовая реализация кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class BasicFrame: virtual public IFrame, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    BasicFrame ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Целевые буферы отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    void           SetRenderTargets      (IRenderTarget* render_target, IRenderTarget* depth_stencil_target);
    IRenderTarget* GetRenderTarget       (); //целевой буфер цвета
    IRenderTarget* GetDepthStencilTarget (); //целевой буфер попиксельного отсечения

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры области вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetViewport (const render::mid_level::Viewport&);
    void GetViewport (render::mid_level::Viewport&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры очистки целевых буферов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetClearBuffers      (bool clear_render_target, bool clear_depth_stencil_target);
    void GetClearBuffers      (bool& clear_render_target, bool& clear_depth_stencil_target);
    void SetClearColor        (const math::vec4f& color);
    void SetClearDepthStencil (float depth_value, unsigned char stencil_index);
    void GetClearColor        (math::vec4f& color);
    void GetClearDepthStencil (float& depth_value, unsigned char& stencil_index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Визуализация
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw (render::low_level::IDevice* device, const low_level::Rect& device_viewport);
    
  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void DrawCore (render::low_level::IDevice* device) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление нормированной области вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateNormalizedViewport ();

  private:
    typedef xtl::com_ptr<RenderTarget> RenderTargetPtr;

  private:
    RenderTargetPtr             render_target;
    RenderTargetPtr             depth_stencil_target;
    render::low_level::Viewport viewport;
    float                       normalized_viewport_left;
    float                       normalized_viewport_top;
    float                       normalized_viewport_width;
    float                       normalized_viewport_height;
    render::low_level::Color4f  clear_color;
    float                       clear_depth_value;
    unsigned char               clear_stencil_index;
    bool                        need_clear_render_target;
    bool                        need_clear_depth_stencil_target;
    bool                        need_update_normalized_viewport;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовая система рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class BasicRenderer: virtual public IRenderer, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    BasicRenderer (render::low_level::IDevice* device, render::low_level::ISwapChain* swap_chain);
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetDescription ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Внутренний идентификатор пула ресурсов
///  (необходим для совместного использования ресурсов, созданных на разных IRenderer)
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetResourcePoolId ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение буфера цвета и буфера попиксельного отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
    IRenderTarget* GetColorBuffer ();
    IRenderTarget* GetDepthStencilBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    IRenderTarget* CreateDepthStencilBuffer ();
    IRenderTarget* CreateRenderBuffer       ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление кадра в список отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddFrame (IFrame*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конец отрисовки / сброс отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DrawFrames   ();
    void CancelFrames ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка области вывода для системы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                   SetViewport (const low_level::Rect& viewport);
    const low_level::Rect& GetViewport () const { return viewport; }
    
  private:
    typedef xtl::com_ptr<IRenderTarget>                 RenderTargetPtr;
    typedef xtl::com_ptr<render::low_level::IDevice>    DevicePtr;
    typedef xtl::com_ptr<render::low_level::ISwapChain> SwapChainPtr;
    typedef xtl::com_ptr<BasicFrame>                    FramePtr;
    typedef stl::vector<FramePtr>                       FrameArray;

  protected:
    DevicePtr device;

  private:
    RenderTargetPtr color_buffer;
    RenderTargetPtr depth_stencil_buffer;
    SwapChainPtr    swap_chain;
    FrameArray      frames;
    size_t          resource_pool_id;  
    low_level::Rect viewport;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отладочный драйвер системы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class Driver: virtual public IDriver
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Driver  ();
    ~Driver ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание драйвера
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetDescription ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перечисление доступных систем визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t      GetRenderersCount ();    
    const char* GetRendererName   (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание устройства визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    IRenderer* CreateRenderer (const char* name);    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка области вывода для системы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetViewport (const char* name, const low_level::Rect& viewport);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация систем рендернинга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RegisterRenderer       (const char* name, render::low_level::IDevice* device, render::low_level::ISwapChain* swap_chain);
    void UnregisterRenderer     (const char* name);
    void UnregisterAllRenderers ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddRef  () {}
    void Release () {}

  private:
    void UnregisterDriver ();

  private:
    struct RendererEntry;

    typedef xtl::shared_ptr<RendererEntry> RendererEntryPtr;
    typedef stl::vector<RendererEntryPtr>  RendererEntries;

  private:
    RendererEntries renderer_entries;
};

namespace renderer2d
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Двумерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class ImageTexture: virtual public mid_level::renderer2d::ITexture, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ImageTexture  (render::low_level::ITexture*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Размеры текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetWidth  ();
    size_t GetHeight ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Формат
///////////////////////////////////////////////////////////////////////////////////////////////////
    media::PixelFormat GetFormat ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Копирование образа текстуры в картинку
///////////////////////////////////////////////////////////////////////////////////////////////////
    void CaptureImage (media::Image&);    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    render::low_level::ITexture* GetTexture ();

  private:
    typedef xtl::com_ptr<render::low_level::ITexture> ITexturePtr;
    
  private:
    ITexturePtr texture;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Двумерная текстура с возможностью рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderTargetTexture: virtual public mid_level::renderer2d::ITexture, public RenderTarget
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTargetTexture (render::low_level::IView* render_target_view);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Выводимая вершина
///////////////////////////////////////////////////////////////////////////////////////////////////
struct SpriteVertex
{
  math::vec3f                      position;
  math::vec2f                      texcoord;
  math::vec4f                      color;
  mid_level::renderer2d::ITexture* texture;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Примитив
///////////////////////////////////////////////////////////////////////////////////////////////////
class Primitive: virtual public mid_level::renderer2d::IPrimitive, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Primitive  ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Матрица преобразований
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetTransform (const math::mat4f&);
    void GetTransform (math::mat4f&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка базовой текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                             SetTexture (mid_level::renderer2d::ITexture*);
    mid_level::renderer2d::ITexture* GetTexture ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение низкоуровневой текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    render::low_level::ITexture* GetLowLevelTexture () { return low_level_texture; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим смешивания цветов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                             SetBlendMode (mid_level::renderer2d::BlendMode blend_mode);
    mid_level::renderer2d::BlendMode GetBlendMode ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Спрайты
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetSpritesCount  ();
    void   GetSprite        (size_t index, mid_level::renderer2d::Sprite& sprite);
    size_t AddSprites       (size_t sprites_count, const mid_level::renderer2d::Sprite* sprites);
    void   RemoveSprites    (size_t first_sprite, size_t sprites_count);
    void   RemoveAllSprites ();
    void   ReserveSprites   (size_t sprites_count);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение данных для отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    SpriteVertex* GetVertexBuffer () { return sprite_vertex_buffer.data (); }

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Построение вершинных данных для спрайта
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BuildSpriteVertexData (size_t sprite_index);
    void ComputeSpriteTransorm (size_t sprite_index);

  private:
    typedef stl::vector<mid_level::renderer2d::Sprite>    SpriteArray;
    typedef xtl::uninitialized_storage<SpriteVertex>      SpriteVertexArray;
    typedef xtl::com_ptr<mid_level::renderer2d::ITexture> TexturePtr;

  private:
    math::mat4f                      transform;
    TexturePtr                       texture;
    render::low_level::ITexture      *low_level_texture;
    mid_level::renderer2d::BlendMode blend_mode;
    SpriteArray                      sprites;
    SpriteVertexArray                sprite_vertex_buffer;
    bool                             dirty_transform;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры шейдера
///////////////////////////////////////////////////////////////////////////////////////////////////
struct ProgramParameters
{
  math::mat4f view_matrix;
  math::mat4f projection_matrix;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Общие ресурсы
///////////////////////////////////////////////////////////////////////////////////////////////////
class CommonResources : public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    CommonResources (render::low_level::IDevice* device);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение низкоуровневых данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    render::low_level::IBuffer*     GetConstantBuffer () { return constant_buffer.get (); }
    render::low_level::IBlendState* GetBlendState (render::mid_level::renderer2d::BlendMode blend_mode) { return blend_states[blend_mode].get (); }

  private:
    typedef xtl::com_ptr<render::low_level::IBlendState> BlendStatePtr;
    typedef xtl::com_ptr<render::low_level::IBuffer>     BufferPtr;
  
  private:
    BufferPtr     constant_buffer;
    BlendStatePtr blend_states[render::mid_level::renderer2d::BlendMode_Num];
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Кадр 2D визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
class Frame: virtual public mid_level::renderer2d::IFrame, public BasicFrame
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Frame (CommonResources* in_common_resources, render::low_level::IDevice* device);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Матрица вида / матрица преобразования
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetView       (const math::mat4f&);
    void SetProjection (const math::mat4f&);
    void GetView       (math::mat4f&);
    void GetProjection (math::mat4f&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Примитивы
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t PrimitivesCount ();
    void   AddPrimitive    (mid_level::renderer2d::IPrimitive*);
    void   Clear           ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DrawCore (render::low_level::IDevice* device);

  private:
    typedef xtl::com_ptr<Primitive>                  PrimitivePtr;
    typedef stl::vector<PrimitivePtr>                PrimitiveArray;
    typedef xtl::com_ptr<render::low_level::IBuffer> BufferPtr;
    typedef xtl::com_ptr<CommonResources>            CommonResourcesPtr;

  private:
    math::mat4f        view_tm, proj_tm;
    PrimitiveArray     primitives;
    CommonResourcesPtr common_resources;
    BufferPtr          vertex_buffer;
    size_t             current_vertex_buffer_size;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Система рендеринга 2D-примитивов
///////////////////////////////////////////////////////////////////////////////////////////////////
class Renderer: virtual public mid_level::renderer2d::IRenderer, public BasicRenderer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Renderer  (render::low_level::IDevice* device, render::low_level::ISwapChain* swap_chain);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    mid_level::renderer2d::ITexture*   CreateTexture   (const media::Image& image);
    mid_level::renderer2d::ITexture*   CreateTexture   (size_t width, size_t height, media::PixelFormat pixel_format);
    mid_level::renderer2d::IPrimitive* CreatePrimitive ();
    mid_level::renderer2d::IFrame*     CreateFrame     ();

  private:
    typedef xtl::com_ptr<render::low_level::IProgram>                 ProgramPtr;
    typedef xtl::com_ptr<render::low_level::IProgramParametersLayout> ProgramParametersLayoutPtr;
    typedef xtl::com_ptr<render::low_level::ISamplerState>            SamplerStatePtr;
    typedef xtl::com_ptr<render::low_level::IInputLayout>             InputLayoutPtr;
    typedef xtl::com_ptr<CommonResources>                             CommonResourcesPtr;

  private:
    ProgramPtr                 program;
    ProgramParametersLayoutPtr program_parameters_layout;
    SamplerStatePtr            sampler;
    InputLayoutPtr             input_layout;
    CommonResourcesPtr         common_resources;
};

}

}

}

}

#endif

