#ifndef RENDER_SCENE_HEADER
#define RENDER_SCENE_HEADER

#include <render/layers.h>

namespace render
{

//???возможно следует сделать sharebale объект skeleton

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отрисовываемый объект
///////////////////////////////////////////////////////////////////////////////////////////////////
class Entity
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Entity  ();
    Entity  (const Entity&);
    ~Entity ();

    Entity& operator = (const Entity&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка матрицы преобразований
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetTransform (const math::mat4f&);
    const math::mat4f& Transform    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка матриц соединений
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t             JointsCount () const;
    const math::mat4f* Joints      () const;
          math::mat4f* Joints      ();
    const math::mat4f& Joint       (size_t joint_index) const;
          math::mat4f& Joint       (size_t joint_index); 

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка меша
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetMesh (const media::Mesh&);
    void               SetMesh (const char* name);
    const media::Mesh& Mesh    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Слои, на которых расположен объект
///////////////////////////////////////////////////////////////////////////////////////////////////
    const LayerSet& Layers () const;
          LayerSet& Layers ();

//    void SetTime (size_t index, float time);???

  private:
    struct Impl;
    Impl* impl; 
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип источника света
///////////////////////////////////////////////////////////////////////////////////////////////////
enum LightType
{
  LightType_Point,  //точечный источник света
  LightType_Direct, //направленный цилиндрический источник света
  LightType_Spot,   //направленный конусоидальный источник света

  LightType_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Источник света
///////////////////////////////////////////////////////////////////////////////////////////////////
class Light
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////  
    Light  ();
    Light  (const Light&);
    ~Light ();
    
    Light& operator = (const Light&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип источника света
///////////////////////////////////////////////////////////////////////////////////////////////////  
    void      SetType (LightType type);
    LightType Type    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Положение и направление источника света
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetPosition  (const math::vec3f& position);
    void               SetDirection (const math::vec3f& direction);
    const math::vec3f& Position     () const;
    const math::vec3f& Direction    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Цвет источника света
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetLightColor (const math::vec3f& color);
    const math::vec3f& LightColor    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Затухание (  constant, linear, quadratic)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetAttenuation (const math::vec3f& multiplier);
    const math::vec3f& Attenuation    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры источника света
///////////////////////////////////////////////////////////////////////////////////////////////////
    void  SetRange          (float range);                            //расстояние действия источника света
    void  SetExponent       (float exponent);                         //экспонента затухания направленных источников света
    void  SetDirectRadiuses (float inner_radius, float outer_radius); //радиус затухания (для direct-light)    
    void  SetInnerRadius    (float radius);
    void  SetOuterRadius    (float radius);    
    void  SetSpotAngles     (float inner_angle, float outer_angle);   //углы затухания (для spot-light)
    void  SetInnerAngle     (float angle);
    void  SetOuterAngle     (float angle);
    float Range             () const;
    float Exponent          () const;
    float InnerRadius       () const;
    float OuterRadius       () const;
    float InnerAngle        () const;
    float OuterAngle        () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Участвует ли источник света в построении теней
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetShadows (bool state);
    bool Shadows    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Слои, на которых расположен источник света
///////////////////////////////////////////////////////////////////////////////////////////////////
    const LayerSet& Layers () const;
          LayerSet& Layers ();

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Камера
///////////////////////////////////////////////////////////////////////////////////////////////////
class Camera
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    Camera  ();
    Camera  (const Camera&);
    ~Camera ();

    Camera& operator = (const Camera&);
    
      //+suppress view id???    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка видовой матрицы
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetViewTM (const math::mat4f&);
    const math::mat4f& ViewTM    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка матрицы проецирования
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetProjectionTM (const math::mat4f&);
    const math::mat4f& ProjectionTM    () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка перечислителя сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (IFrame& frame)> SceneEnumFunction;

    void                     SetSceneEnumerator (const SceneEnumFunction& handler);
    const SceneEnumFunction& SceneEnumerator    () const;

  private:
    struct Impl;
    Impl* impl;
};

}

#endif
