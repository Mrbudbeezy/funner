#ifndef RENDER_DX11_DRIVER_SHADER_STAGE_SHARED_HEADER
#define RENDER_DX11_DRIVER_SHADER_STAGE_SHARED_HEADER

#include <D3Dcommon.h>
#include <D3DX11async.h>
#include <D3D11Shader.h>
#include <D3Dcompiler.h>

#include <stl/deque>
#include <stl/hash_map>
#include <stl/vector>

#include <xtl/bind.h>
#include <xtl/function.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/ref.h>
#include <xtl/shared_ptr.h>
#include <xtl/uninitialized_storage.h>

#include <common/file.h>
#include <common/hash.h>
#include <common/string.h>
#include <common/strlib.h>

#include <render/low_level/utils.h>

#include <render/low_level/helpers/program_parameters_layout.h>

#include <shared/error.h>
#include <shared/log.h>
#include <shared/input_layout.h>
#include <shared/shader_manager.h>

#ifdef _MSC_VER
  #pragma warning (disable : 4503) //decorated name length exceeded, name was truncated
#endif

namespace render
{

namespace low_level
{

namespace dx11
{

using helpers::ProgramParameterGroup;

//forwards
class ShaderLibrary;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип шейдера
///////////////////////////////////////////////////////////////////////////////////////////////////
enum ShaderType
{
  ShaderType_Compute,
  ShaderType_Domain,
  ShaderType_Geometry,
  ShaderType_Hull,
  ShaderType_Pixel,
  ShaderType_Vertex,

  ShaderType_Num
};

typedef xtl::shared_ptr<ShaderCode> ShaderCodePtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание параметра шейдера
///////////////////////////////////////////////////////////////////////////////////////////////////
struct ShaderParameter: public ProgramParameter {};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Лэйаут константного буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
class ConstantBufferLayout: public xtl::reference_counter, public xtl::trackable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ConstantBufferLayout  (ID3D11ShaderReflectionConstantBuffer& buffer);
    ~ConstantBufferLayout ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество параметров в буфере
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t                 GetParamsCount () const { return params.size (); }
    const ShaderParameter* GetParams      () const { return params.empty () ? (ShaderParameter*)0 : &params [0]; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип буфера / размер буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    D3D11_CBUFFER_TYPE GetType () const { return type; }
    size_t             GetSize () const { return buffer_size; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение хэша
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetHash () const { return hash; }

  private:
    ConstantBufferLayout (const ConstantBufferLayout&); //no implementation
    ConstantBufferLayout& operator = (const ConstantBufferLayout&); //no implementation

  private:
    typedef stl::vector<ShaderParameter> ShaderParameterArray;

  private:
    ShaderParameterArray params;      //параметры константного буфера
    common::StringArray  strings;     //строки с именами параметров
    D3D11_CBUFFER_TYPE   type;        //тип буфера
    size_t               buffer_size; //размер буфера
    size_t               hash;        //хэш лэйаута для идентификации
};

typedef xtl::intrusive_ptr<ConstantBufferLayout> ConstantBufferLayoutPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Шейдер
///////////////////////////////////////////////////////////////////////////////////////////////////
class Shader: public DeviceObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Shader  (ShaderType shader_type, const ShaderCodePtr& shader_code, ShaderLibrary& library);
    ~Shader ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип шейдера
///////////////////////////////////////////////////////////////////////////////////////////////////
    ShaderType GetType () const { return type; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Объект шейдера
///////////////////////////////////////////////////////////////////////////////////////////////////
    ID3D11DeviceChild& GetHandle () const { return *shader; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Код шейдера
///////////////////////////////////////////////////////////////////////////////////////////////////
    ShaderCode& GetShaderCode () const { return *code; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перечисление константных буферов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t                  GetConstantBufferLayoutsCount () const { return buffer_layouts.size (); }
    ConstantBufferLayoutPtr GetConstantBufferLayout       (size_t index) const;

  private:
    typedef stl::vector<ConstantBufferLayoutPtr> BufferLayoutArray;

  private:
    ShaderType        type;           //тип шейдера
    DxDeviceChildPtr  shader;         //объект шейдера
    ShaderCodePtr     code;           //код шейдера
    BufferLayoutArray buffer_layouts; //лэйауты буферов
};

typedef xtl::com_ptr<Shader> ShaderPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание буфера программы
///////////////////////////////////////////////////////////////////////////////////////////////////
class ProgramBufferLayout: public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ProgramBufferLayout (const ConstantBufferLayoutPtr& in_layout, size_t reserved_count = 0)
      : layout (in_layout)
    {
      slots.reserve (reserved_count);
    }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение лэйаута
///////////////////////////////////////////////////////////////////////////////////////////////////
    const ConstantBufferLayout& GetLayout () const { return *layout; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание слота
///////////////////////////////////////////////////////////////////////////////////////////////////
    struct Slot
    {      
      ShaderType type;
      size_t     slot;

      Slot (ShaderType in_type, size_t in_slot)
        : type (in_type)
        , slot (in_slot)
      {
      }
    };

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перечисление слотов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t      GetSlotsCount () const { return slots.size (); }
    const Slot* GetSlots      () const { return slots.empty () ? (Slot*)0 : &slots [0]; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление слотов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddSlot (const Slot& slot)
    {
      slots.push_back (slot);
    }

  private:
    ProgramBufferLayout (const ProgramBufferLayout&); //no implementation
    ProgramBufferLayout& operator = (const ProgramBufferLayout&); //no implementation

  private:
    typedef stl::vector<Slot> SlotArray;

  private:
    ConstantBufferLayoutPtr layout; //исходный лэйаут
    SlotArray               slots;  //слоты
};

typedef xtl::intrusive_ptr<ProgramBufferLayout> ProgramBufferLayoutPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Программа
///////////////////////////////////////////////////////////////////////////////////////////////////
class Program: virtual public IProgram, public DeviceObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Program  (ShaderLibrary& library, size_t shaders_count, const ShaderDesc* shader_descs, const LogFunction& error_log);
    ~Program ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка программы в контекст
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (ID3D11DeviceContext& context);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание входного лэйаута
///////////////////////////////////////////////////////////////////////////////////////////////////
    DxInputLayoutPtr CreateInputLayout (const D3D11_INPUT_ELEMENT_DESC* descs, size_t descs_count);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перечисление константных буферов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t                     GetConstantBufferLayoutsCount () const { return buffer_layouts.size (); }
    const ProgramBufferLayout& GetConstantBufferLayout       (size_t index) const;

  private:
    struct ShaderSlot
    {
      ShaderPtr          holder;
      ID3D11DeviceChild* shader;

      ShaderSlot () : shader () {}
    };

    template <class T, ShaderType Type> T* Get ();

    typedef stl::vector<ProgramBufferLayoutPtr> BufferLayoutArray;

  private:
    ShaderSlot        shaders [ShaderType_Num]; //использованные шейдеры
    BufferLayoutArray buffer_layouts;           //лэйауты буферов
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Лэйаут входных параметров программы
///////////////////////////////////////////////////////////////////////////////////////////////////
class ProgramParametersLayout: public helpers::ProgramParametersLayout, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ProgramParametersLayout (const ProgramParametersLayoutDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск параметра
///////////////////////////////////////////////////////////////////////////////////////////////////
    const ProgramParameter* FindParameter (const char* name) const;

  private:
    typedef stl::hash_map<stl::hash_key<const char*>, const ProgramParameter*> ParameterMap;

  private:
    ParameterMap params;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исходный константный буфер
///////////////////////////////////////////////////////////////////////////////////////////////////
class SourceConstantBuffer: virtual public IBuffer, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SourceConstantBuffer (const BufferDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (BufferDesc&);

    UsageMode GetUsageMode () const { return desc.usage_mode; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Чтение / запись из буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t offset, size_t size, const void* data);
    void GetData (size_t offset, size_t size, void* data);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Указатель на данные буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    const void* GetDataPointer () const { return buffer.data (); }
    size_t      GetDataSize    () const { return buffer.size (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Хэш данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetHash () const;

  private:
    xtl::uninitialized_storage<char> buffer;           //буфер в системной памяти
    BufferDesc                       desc;             //описание буфера
    mutable size_t                   hash;             //хэш
    mutable bool                     need_update_hash; //хэш требует обновления
};

typedef xtl::com_ptr<SourceConstantBuffer> SourceConstantBufferPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Синхронизатор буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
class ShaderBuffersSynchronizer: public xtl::reference_counter, public xtl::trackable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Вспомогательные структуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    struct Chunk
    {
      size_t slot;       //индекс слота
      size_t src_offset; //смещение в исходном буфере
      size_t dst_offset; //смещение в результирующем буфере
      size_t size;       //размер блока

      Chunk () : slot (), src_offset (), dst_offset (), size () {}

      bool operator < (const Chunk&) const;
    };

    struct Slot
    {
      size_t first_chunk;          //индекс первого блока
      size_t min_src_buffer_size;  //минимальный размер буфера

      Slot () : first_chunk (), min_src_buffer_size () {}
    };

    typedef stl::vector<Chunk> ChunkArray;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ShaderBuffersSynchronizer (const ProgramParametersLayout& src_layout, const ConstantBufferLayout& dst_layout);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение минимального размера буфера для указанного слота
/// (без проверок корректности аргументов)
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetMinSourceBufferSize      (size_t slot_index) const { return slots [slot_index].min_src_buffer_size; }
    size_t GetMinDestinationBufferSize ()                  const { return min_dst_buffer_size; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение слотов и блоков
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t       GetChunksCount () const { return chunks.size (); }
    const Chunk* GetChunks      () const { return chunks.empty () ? (Chunk*)0 : &chunks [0]; }
    const Slot*  GetSlots       () const { return &slots [0]; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Копирование
/// (без проверок корректности аргументов)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void CopyTo (size_t slot_index, const char* src_buffer, char* dst_buffer) const
    {
      const Slot&  slot  = slots [slot_index];
      const Chunk* chunk = &chunks [0] + slot.first_chunk;

      for (; chunk->slot == slot_index; chunk++)
      {
        memcpy (dst_buffer + chunk->dst_offset, src_buffer + chunk->src_offset, chunk->size);
      }
    }

  private:
    ChunkArray chunks;                                     //блоки синхронизации
    Slot       slots [DEVICE_CONSTANT_BUFFER_SLOTS_COUNT]; //соответствие слоты константного буфера
    size_t     min_dst_buffer_size;                        //минимальный размер результирующего буфера
};

typedef xtl::intrusive_ptr<ShaderBuffersSynchronizer> ShaderBuffersSynchronizerPtr;

class TargetConstantBuffer;

typedef xtl::com_ptr<TargetConstantBuffer> TargetConstantBufferPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Прототип целевого буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
class TargetConstantBufferPrototype: public xtl::reference_counter, public xtl::trackable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TargetConstantBufferPrototype  (ShaderLibrary& library, const ProgramParametersLayout& src_layout, ProgramBufferLayout& dst_layout);
    ~TargetConstantBufferPrototype ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    TargetConstantBufferPtr CreateBuffer (const DeviceManager& device_manager, const SourceConstantBufferPtr buffers [DEVICE_CONSTANT_BUFFER_SLOTS_COUNT]) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение списка индексов константных буферов
///////////////////////////////////////////////////////////////////////////////////////////////////
    unsigned char        GetSourceBuffersCount   () const { return indices.size (); }
    const unsigned char* GetSourceBuffersIndices () const { return indices.empty () ? (unsigned char*)0 : &indices [0]; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение минимального размера буфера для указанного слота
/// (без проверок корректности аргументов)
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetMinSourceBufferSize      (size_t index) const { return synchronizer.GetMinSourceBufferSize (indices [index]); }
    size_t GetMinDestinationBufferSize ()             const { return synchronizer.GetMinDestinationBufferSize (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Синхронизация
/// (без проверок корректности)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void CopyTo (size_t index, const char* src_buffer, char* dst_buffer) const
    {
      synchronizer.CopyTo (indices [index], src_buffer, dst_buffer);
    }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Биндинг
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (ID3D11Buffer& buffer, ID3D11Buffer* context_buffers [ShaderType_Num][DEVICE_CONSTANT_BUFFER_SLOTS_COUNT]) const;

  private:
    typedef stl::vector<unsigned char> IndexArray;
    typedef ProgramBufferLayout::Slot  Slot;

  private:
    ShaderBuffersSynchronizer& synchronizer; //синхронизатор
    ProgramBufferLayout&       dst_layout;   //целевой лэйаут
    IndexArray                 indices;      //индексы
    size_t                     slots_count;  //количество слотов
    const Slot*                slots;        //слоты
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Целевой буфер
///////////////////////////////////////////////////////////////////////////////////////////////////
class TargetConstantBuffer: public DeviceObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TargetConstantBuffer  (const DeviceManager&, TargetConstantBufferPrototype& prototype, const SourceConstantBufferPtr buffers [DEVICE_CONSTANT_BUFFER_SLOTS_COUNT]);
    ~TargetConstantBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Биндинг
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (ID3D11DeviceContext&, ID3D11Buffer* context_buffers [ShaderType_Num][DEVICE_CONSTANT_BUFFER_SLOTS_COUNT]);

  private:
    struct SourceBufferDesc
    {
      SourceConstantBuffer* buffer; //исходный буфер
      size_t                hash;   //хэш искходного буфера

      SourceBufferDesc (SourceConstantBuffer* in_buffer)
        : buffer (in_buffer)
        , hash ()
      {
      }
    };

    typedef stl::vector<SourceBufferDesc> BufferDescArray;

  private:
    TargetConstantBufferPrototype& prototype;   //прототип
    DxBufferPtr                    dst_buffer;  //целевой буфер  
    BufferDescArray                src_buffers; //исходные буферы
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Программа, устанавливаемая в контекст
///////////////////////////////////////////////////////////////////////////////////////////////////
/*class BindableProgram: public xtl::reference_counter, public xtl::trackable
{
  public:

  private:
    

  private:
    Program&                 program;           //исходная программа
    ProgramParametersLayout& parameters_layout; //расположение параметров
};*/

///////////////////////////////////////////////////////////////////////////////////////////////////
///Библиотека шейдеров
///////////////////////////////////////////////////////////////////////////////////////////////////
class ShaderLibrary: public DeviceObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ShaderLibrary  (const DeviceManager& device_manager);
    ~ShaderLibrary ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание шейдера
///////////////////////////////////////////////////////////////////////////////////////////////////
    ShaderPtr CreateShader (const ShaderDesc& shader_desc, const LogFunction& error_log);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск лэйаута константного буфера по хэшу
///////////////////////////////////////////////////////////////////////////////////////////////////
    ConstantBufferLayoutPtr FindConstantBufferLayout (size_t hash) const; 

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление / удаление лэйаута константного буфера по хэшу
///////////////////////////////////////////////////////////////////////////////////////////////////
    ConstantBufferLayoutPtr AddConstantBufferLayout    (const ConstantBufferLayoutPtr& layout);
    void                    RemoveConstantBufferLayout (size_t hash);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение синхронизатора
///////////////////////////////////////////////////////////////////////////////////////////////////
    ShaderBuffersSynchronizer& GetSynchronizer (const ProgramParametersLayout& src_layout, const ConstantBufferLayout& dst_layout);

  private:
    typedef stl::pair<const ProgramParametersLayout*, const ConstantBufferLayout*> SyncLayoutPair;

    void RemoveShaderByHash (size_t hash);
    void RemoveSynchronizer (const SyncLayoutPair&);

  private:
    typedef stl::hash_map<size_t, Shader*>                              ShaderMap;
    typedef stl::hash_map<size_t, ConstantBufferLayout*>                BufferLayoutMap;
    typedef stl::hash_map<SyncLayoutPair, ShaderBuffersSynchronizerPtr> SyncLayoutMap;

  private:
    ShaderMap       shaders;         //шейдеры
    BufferLayoutMap buffer_layouts;  //лэйауты константных буферов
    SyncLayoutMap   layout_syncs;    //синхронизаторы лэйаутов
};

}

}

}

namespace stl
{

inline size_t hash (const stl::pair<const render::low_level::dx11::ProgramParametersLayout*, const render::low_level::dx11::ConstantBufferLayout*>& p)
{
  return common::crc32 (&p.first, sizeof (p.first), common::crc32 (&p.second, sizeof (p.second)));
}

}

#endif
