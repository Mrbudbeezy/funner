#ifndef RENDER_DX11_DRIVER_SOURCES_HEADER
#define RENDER_DX11_DRIVER_SOURCES_HEADER

#include <cmath>

#include <D3D11.h>

#include <stl/string>
#include <stl/vector>

#include <xtl/bind.h>
#include <xtl/common_exceptions.h>
#include <xtl/intrusive_ptr.h>

#include <common/component.h>
#include <common/strlib.h>
#include <common/utf_converter.h>

#include <render/low_level/device.h>
#include <render/low_level/driver.h>
#include <render/low_level/utils.h>

#include <render/low_level/helpers/object.h>
#include <render/low_level/helpers/property_list.h>

#include <shared/log.h>
#include <shared/error.h>
#include <shared/object.h>
#include <shared/render_target_manager.h>
#include <shared/swap_chain.h>

namespace render
{

namespace low_level
{

namespace dx11
{

class Adapter;
class Context;

using helpers::PropertyList;

typedef xtl::com_ptr<Adapter> AdapterPtr;
typedef xtl::com_ptr<Context> ContextPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Устройство вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
class Output: virtual public IOutput, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Output  (const DxOutputPtr& output);
    ~Output ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор устройства вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    IDXGIOutput& GetHandle ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение имени
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetName ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение списка видео-режимов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetModesCount ();
    void   GetModeDesc   (size_t mode_index, OutputModeDesc& mode_desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текущего видео-режима
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetCurrentMode     (const OutputModeDesc&);
    void GetCurrentMode     (OutputModeDesc&);
    void RestoreDefaultMode ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление гамма-коррекцией
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetGammaRamp (const Color3f table [256]);
    void GetGammaRamp (Color3f table [256]);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Список свойств устройства вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    IPropertyList* GetProperties ();

  private:
    typedef stl::vector<OutputModeDesc> ModeArray;

  private:
    DxOutputPtr  output;     //устройство вывода
    stl::string  name;       //имя устройства
    PropertyList properties; //свойства устройства
    ModeArray    modes;      //режимы
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Адаптер
///////////////////////////////////////////////////////////////////////////////////////////////////
class Adapter: virtual public IAdapter, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Adapter  (const DxFactoryPtr& factory, const char* name, const char* dll_path, const char* init_string);
    Adapter  (const DxAdapterPtr& adapter);
    ~Adapter ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя адаптера / путь к модулю / описание / дескриптор модуля
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetName        ();
    const char* GetPath        ();
    const char* GetDescription ();
    HMODULE     GetModule      ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ссылка на адаптер DX11
///////////////////////////////////////////////////////////////////////////////////////////////////
    IDXGIAdapter& GetHandle ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перечисление доступных устройств вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t   GetOutputsCount ();
    IOutput* GetOutput       (size_t index);
    Output*  FindOutput      (IDXGIOutput* output);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Список свойств адаптера
///////////////////////////////////////////////////////////////////////////////////////////////////
    IPropertyList* GetProperties ();

  private:
    void Init ();

  private:
    typedef xtl::com_ptr<Output>   OutputPtr;
    typedef stl::vector<OutputPtr> OutputArray;

  private:
    DxAdapterPtr adapter;      //адаптер          
    stl::string  name;         //имя адаптера
    stl::string  path;         //путь к адаптеру
    PropertyList properties;   //свойства адаптера
    OutputArray  outputs;      //устройства вывода
    HMODULE      module;       //дескриптор модуля
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Первичная цепочка обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChain: public ISwapChainImpl
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChain  (const DxFactoryPtr& factory, const AdapterPtr& adapter, const DxDevicePtr& device, const SwapChainDesc& desc);
    ~SwapChain ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение адаптера
///////////////////////////////////////////////////////////////////////////////////////////////////
    IAdapter* GetAdapter ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Низкоуровневый дескриптор
///////////////////////////////////////////////////////////////////////////////////////////////////
    IDXGISwapChain& GetHandle ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (SwapChainDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение устройства вывода с максимальным размером области перекрытия
///////////////////////////////////////////////////////////////////////////////////////////////////
    IOutput* GetContainingOutput ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / взятие состояния full-screen mode
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetFullscreenState (bool state);
    bool GetFullscreenState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен текущего заднего буфера и переднего буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Present ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Список свойств цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
    IPropertyList* GetProperties ();
    
  private:
    AdapterPtr     adapter;    //адаптер
    DxSwapChainPtr swap_chain; //цепочка обмена
    SwapChainDesc  desc;       //дескриптор цепочки обмена
    PropertyList   properties; //свойства цепочки обмена
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контекст отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
class Context: virtual public IDeviceContext, public DeviceObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Context  (const DxContextPtr& context, const DeviceManager& device_manager);
    ~Context ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Низкоуровневый дескриптор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ID3D11DeviceContext& GetHandle ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Указание границ запроса
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Begin (IQuery* async);
    void End   (IQuery* async);
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление входным уровнем (input-stage)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void          ISSetInputLayout  (IInputLayout* state);
    void          ISSetVertexBuffer (size_t vertex_buffer_slot,  IBuffer* buffer);
    void          ISSetIndexBuffer  (IBuffer* buffer);
    IInputLayout* ISGetInputLayout  ();
    IBuffer*      ISGetVertexBuffer (size_t vertex_buffer_slot);
    IBuffer*      ISGetIndexBuffer  ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление шейдерными уровнями (shader-stage)
/// в случае несовпадения расположения переменных в программе и лэйауте - генерируется исключение
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                      SSSetProgram                 (IProgram* program);
    void                      SSSetProgramParametersLayout (IProgramParametersLayout* parameters_layout);
    void                      SSSetSampler                 (size_t sampler_slot, ISamplerState* state);
    void                      SSSetTexture                 (size_t sampler_slot, ITexture* texture);
    void                      SSSetConstantBuffer          (size_t buffer_slot, IBuffer* buffer);
    IProgramParametersLayout* SSGetProgramParametersLayout ();
    IProgram*                 SSGetProgram                 ();
    ISamplerState*            SSGetSampler                 (size_t sampler_slot);
    ITexture*                 SSGetTexture                 (size_t sampler_slot);
    IBuffer*                  SSGetConstantBuffer          (size_t buffer_slot);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление растеризатором (rasterizer-stage)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void              RSSetState    (IRasterizerState* state);
    void              RSSetViewport (size_t render_target_slot, const Viewport& viewport);
    void              RSSetScissor  (size_t render_target_slot, const Rect& scissor_rect);
    IRasterizerState* RSGetState    ();
    const Viewport&   RSGetViewport (size_t render_target_slot);
    const Rect&       RSGetScissor  (size_t render_target_slot);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление выходным уровнем (output-stage)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                OSSetBlendState        (IBlendState* state);
    void                OSSetDepthStencilState (IDepthStencilState* state);
    void                OSSetStencilReference  (size_t reference);
    void                OSSetRenderTargets     (size_t views_count, IView** render_target_view, IView* depth_stencil_view);
    void                OSSetRenderTargetView  (size_t render_target_slot, IView* view);
    void                OSSetDepthStencilView  (IView* view);
    IBlendState*        OSGetBlendState        ();
    IDepthStencilState* OSGetDepthStencilState ();
    size_t              OSGetStencilReference  ();
    IView*              OSGetRenderTargetView  (size_t render_target_slot);
    IView*              OSGetDepthStencilView  ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление уровнем вывода вершин
///////////////////////////////////////////////////////////////////////////////////////////////////
    void     SOSetTargets      (size_t buffers_count, IBuffer** buffers, const size_t* offsets);
    void     SOSetTarget       (size_t stream_output_slot, IBuffer* buffer, size_t offset);
    IBuffer* SOGetTarget       (size_t stream_output_slot);
    size_t   SOGetTargetOffset (size_t stream_output_slot);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка буферов отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    void ClearRenderTargetView (size_t render_target_slot, const Color4f& color);
    void ClearDepthStencilView (size_t clear_flags, float depth, unsigned char stencil);
    void ClearViews            (size_t clear_flags, size_t render_targets_count, const size_t* render_target_indices, const Color4f* colors, float depth, unsigned char stencil);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Генерация мип-уровней текстуры (необходимо для текстур в которые ведется рендеринг)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GenerateMips (ITexture* texture);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление предикатами отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    void        SetPredication    (IPredicate* predicate, bool predicate_value);
    IPredicate* GetPredicate      ();
    bool        GetPredicateValue ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование примитивов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DrawAuto             (PrimitiveType primitive_type);
    void Draw                 (PrimitiveType primitive_type, size_t first_vertex, size_t vertices_count);
    void DrawIndexed          (PrimitiveType primitive_type, size_t first_index, size_t indices_count, size_t base_vertex);
    void DrawInstanced        (PrimitiveType primitive_type, size_t vertex_count_per_instance, size_t instance_count, size_t first_vertex, size_t first_instance_location);
    void DrawIndexedInstanced (PrimitiveType primitive_type, size_t index_count_per_instance, size_t instance_count, size_t first_index, size_t base_vertex, size_t first_instance_location);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ожидание завершения выполнения буфера команд
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Flush ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Выполнение списка команд
///////////////////////////////////////////////////////////////////////////////////////////////////
    ICommandList* FinishCommandList  (bool restore_state);
    void          ExecuteCommandList (ICommandList* list, bool restore_state);

  private:
    DxContextPtr        context;               //контекст отрисовки
    RenderTargetContext render_target_context; //контекст целей отрисовки
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Устройство отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
class Device: virtual public IDevice, public Object
{
  public:  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Device  (const AdapterPtr& adapter, const char* init_string);
    ~Device ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора устройства / адаптера
///////////////////////////////////////////////////////////////////////////////////////////////////
    ID3D11Device& GetHandle  ();
    AdapterPtr    GetAdapter ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя устройства
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetName ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение возможностей устройства
///////////////////////////////////////////////////////////////////////////////////////////////////
    void        GetCaps                        (DeviceCaps&);
    const char* GetCapString                   (DeviceCapString);
    const char* GetVertexAttributeSemanticName (VertexAttributeSemantic semantic);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    IInputLayout*             CreateInputLayout             (const InputLayoutDesc&);
    IProgramParametersLayout* CreateProgramParametersLayout (const ProgramParametersLayoutDesc&);
    IRasterizerState*         CreateRasterizerState         (const RasterizerDesc&);
    IBlendState*              CreateBlendState              (const BlendDesc&);
    IDepthStencilState*       CreateDepthStencilState       (const DepthStencilDesc&);
    ISamplerState*            CreateSamplerState            (const SamplerDesc&);
    IBuffer*                  CreateBuffer                  (const BufferDesc&);
    IProgram*                 CreateProgram                 (size_t shaders_count, const ShaderDesc* shader_descs, const LogFunction& error_log);
    ITexture*                 CreateTexture                 (const TextureDesc&);
    ITexture*                 CreateTexture                 (const TextureDesc&, const TextureData&);
    ITexture*                 CreateTexture                 (const TextureDesc&, IBuffer* buffer, size_t buffer_offset, const size_t* mip_sizes);
    ITexture*                 CreateRenderTargetTexture     (ISwapChain* swap_chain, size_t buffer_index);
    ITexture*                 CreateDepthStencilTexture     (ISwapChain* swap_chain);
    IView*                    CreateView                    (ITexture* texture, const ViewDesc&);
    IPredicate*               CreatePredicate               ();
    IQuery*                   CreateQuery                   (QueryType type);
    IStateBlock*              CreateStateBlock              (const StateBlockMask& mask);
    IDeviceContext*           CreateDeferredContext         ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Список свойств устройства отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    IPropertyList* GetProperties ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение непосредственного контекста выполнения операций
///////////////////////////////////////////////////////////////////////////////////////////////////
    IDeviceContext* GetImmediateContext ();

  private:
    ITexture* CreateTexture (const TextureDesc&, const TextureData*);

  private:
    AdapterPtr                         adapter;               //адаптер устройства
    PropertyList                       properties;            //свойства устройства
    DxDevicePtr                        device;                //устройство отрисовки
    stl::auto_ptr<DeviceManager>       device_manager;        //менеджер устройства
    ContextPtr                         immediate_context;     //непосредственный конеткст отрисовки
    stl::auto_ptr<RenderTargetManager> render_target_manager; //менеджер целей рендеринга
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация драйвера для DX11
///////////////////////////////////////////////////////////////////////////////////////////////////
class Driver: virtual public IDriver, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Driver  ();
    ~Driver ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание драйвера
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetDescription ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение возможностей драйвера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetCaps (DriverCaps&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перечисление доступных адаптеров
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t    GetAdaptersCount ();
    IAdapter* GetAdapter       (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание адаптера
///////////////////////////////////////////////////////////////////////////////////////////////////
    IAdapter* CreateAdapter (const char* name, const char* path, const char* init_string);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
    ISwapChain* CreateSwapChain (size_t prefered_adapters_count, IAdapter** prefered_adapters, const SwapChainDesc& desc);
    ISwapChain* CreateSwapChain (IDevice* device, const SwapChainDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание устройства отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    IDevice* CreateDevice (ISwapChain* swap_chain, const char* init_string);
    IDevice* CreateDevice (size_t prefered_adapters_count, IAdapter** prefered_adapters, const char* init_string);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка функции отладочного протоколирования драйвера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetDebugLog (const LogFunction&);
    const LogFunction& GetDebugLog ();

  private:
    void RegisterAdapter   (IAdapter*);
    void UnregisterAdapter (IAdapter*);

  private: 
    typedef stl::vector<IAdapter*>  AdapterWeakArray;
    typedef xtl::com_ptr<Adapter>   AdapterPtr;
    typedef stl::vector<AdapterPtr> AdapterArray;

  private:
    DxFactoryPtr     factory;             //фабрика DXGI
    AdapterArray     adapters;            //адаптеры отрисовки
    AdapterWeakArray registered_adapters; //зарегистрированные адаптеры отрисовки
    Log              log;                 //поток отладочного протоколирования
    LogFunction      dummy_log_fn;        //функция отладочного протоколирования
};

}

}

}

#endif
