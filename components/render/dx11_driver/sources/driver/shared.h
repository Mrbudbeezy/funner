#ifndef RENDER_DX11_DRIVER_SOURCES_HEADER
#define RENDER_DX11_DRIVER_SOURCES_HEADER

#include <cmath>

#include <D3D11.h>
#include <D3Dcompiler.h>

#include <stl/string>
#include <stl/vector>

#include <xtl/bind.h>
#include <xtl/common_exceptions.h>
#include <xtl/intrusive_ptr.h>

#include <common/action_queue.h>
#include <common/component.h>
#include <common/lockable.h>
#include <common/property_map.h>
#include <common/strlib.h>
#include <common/utf_converter.h>

#include <syslib/dll.h>
#include <syslib/mutex.h>

#include <render/low_level/device.h>
#include <render/low_level/driver.h>
#include <render/low_level/utils.h>

#include <render/low_level/helpers/object.h>
#include <render/low_level/helpers/property_list.h>

#include <shared/library.h>
#include <shared/log.h>
#include <shared/error.h>
#include <shared/input_manager.h>
#include <shared/object.h>
#include <shared/output_manager.h>
#include <shared/query_manager.h>
#include <shared/render_target_manager.h>
#include <shared/shader_manager.h>
#include <shared/texture_manager.h>
#include <shared/swap_chain.h>

namespace render
{

namespace low_level
{

namespace dx11
{

class Adapter;
class Context;

using helpers::PropertyList;

typedef xtl::com_ptr<Adapter> AdapterPtr;
typedef xtl::com_ptr<Context> ContextPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Устройство вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
class Output: virtual public IOutput, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Output  (const DxOutputPtr& output);
    ~Output ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор устройства вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    IDXGIOutput& GetHandle ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение имени
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetName ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение списка видео-режимов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetModesCount ();
    void   GetModeDesc   (size_t mode_index, OutputModeDesc& mode_desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текущего видео-режима
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetCurrentMode     (const OutputModeDesc&);
    void GetCurrentMode     (OutputModeDesc&);
    void RestoreDefaultMode ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление гамма-коррекцией
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetGammaRamp (const Color3f table [256]);
    void GetGammaRamp (Color3f table [256]);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Список свойств устройства вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    IPropertyList* GetProperties ();

  private:
    typedef stl::vector<OutputModeDesc> ModeArray;

  private:
    DxOutputPtr  output;     //устройство вывода
    stl::string  name;       //имя устройства
    PropertyList properties; //свойства устройства
    ModeArray    modes;      //режимы
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Адаптер
///////////////////////////////////////////////////////////////////////////////////////////////////
class Adapter: virtual public IAdapter, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Adapter  (const DxFactoryPtr& factory, const char* name, const char* dll_path, const char* init_string);
    Adapter  (const DxAdapterPtr& adapter);
    ~Adapter ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя адаптера / путь к модулю / описание / дескриптор модуля
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetName        ();
    const char* GetPath        ();
    const char* GetDescription ();
    HMODULE     GetModule      ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ссылка на адаптер DX11
///////////////////////////////////////////////////////////////////////////////////////////////////
    IDXGIAdapter& GetHandle ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перечисление доступных устройств вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t   GetOutputsCount ();
    IOutput* GetOutput       (size_t index);
    Output*  FindOutput      (IDXGIOutput* output);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Список свойств адаптера
///////////////////////////////////////////////////////////////////////////////////////////////////
    IPropertyList* GetProperties ();

  private:
    void Init ();

  private:
    typedef xtl::com_ptr<Output>   OutputPtr;
    typedef stl::vector<OutputPtr> OutputArray;

  private:
    DxAdapterPtr adapter;      //адаптер          
    stl::string  name;         //имя адаптера
    stl::string  path;         //путь к адаптеру
    PropertyList properties;   //свойства адаптера
    OutputArray  outputs;      //устройства вывода
    HMODULE      module;       //дескриптор модуля
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Первичная цепочка обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChain: public ISwapChainImpl
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChain  (const DxFactoryPtr& factory, const AdapterPtr& adapter, const DxDevicePtr& device, const SwapChainDesc& desc);
    ~SwapChain ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение адаптера
///////////////////////////////////////////////////////////////////////////////////////////////////
    IAdapter* GetAdapter ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Низкоуровневый дескриптор
///////////////////////////////////////////////////////////////////////////////////////////////////
    IDXGISwapChain& GetHandle ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (SwapChainDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение устройства вывода с максимальным размером области перекрытия
///////////////////////////////////////////////////////////////////////////////////////////////////
    IOutput* GetContainingOutput ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / взятие состояния full-screen mode
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetFullscreenState (bool state);
    bool GetFullscreenState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен текущего заднего буфера и переднего буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Present ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Список свойств цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
    IPropertyList* GetProperties ();
    
  private:
    AdapterPtr     adapter;    //адаптер
    DxSwapChainPtr swap_chain; //цепочка обмена
    SwapChainDesc  desc;       //дескриптор цепочки обмена
    PropertyList   properties; //свойства цепочки обмена
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ресурсы инициализации
///////////////////////////////////////////////////////////////////////////////////////////////////
struct InitialResources
{
  IViewPtr              render_target_view;
  IViewPtr              depth_stencil_view;
  IBlendStatePtr        blend_state;
  IDepthStencilStatePtr depth_stencil_state;
  IRasterizerStatePtr   rasterizer_state;
  InputLayoutPtr        input_layout;
  Viewport              viewport;
  Rect                  scissor;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние контекста
///////////////////////////////////////////////////////////////////////////////////////////////////
struct ContextState
{
  RenderTargetContextState   render_target_context_state;   //состояние контекста целей отрисовки
  TextureManagerContextState texture_manager_context_state; //состояние контекста менеджера текстур
  InputManagerContextState   input_manager_context_state;   //состояние контекста менеджера входного уровня
  ShaderManagerContextState  shader_manager_context_state;  //состояние контекста менеджера шейдеров
  OutputManagerContextState  output_manager_context_state;  //состояние контекста менеджера выходного уровня
  QueryManagerContextState   query_manager_context_state;   //состояние контекста менеджера запросов

///Конструктор
  ContextState (const DeviceManager&);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контекст отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
class Context: public IDeviceContextImpl
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Context  (const DxContextPtr& context, const DeviceManager& device_manager, ShaderLibrary& shader_library, const InitialResources& initial_resources, const DefaultResources& default_resources);
    ~Context ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Низкоуровневый дескриптор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ID3D11DeviceContext& GetHandle ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление входным уровнем (input-stage)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void          ISSetInputLayout  (IInputLayout* state);
    void          ISSetVertexBuffer (size_t vertex_buffer_slot,  IBuffer* buffer);
    void          ISSetIndexBuffer  (IBuffer* buffer);
    IInputLayout* ISGetInputLayout  ();
    IBuffer*      ISGetVertexBuffer (size_t vertex_buffer_slot);
    IBuffer*      ISGetIndexBuffer  ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление шейдерными уровнями (shader-stage)
/// в случае несовпадения расположения переменных в программе и лэйауте - генерируется исключение
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                      SSSetProgram                 (IProgram* program);
    void                      SSSetProgramParametersLayout (IProgramParametersLayout* parameters_layout);
    void                      SSSetSampler                 (size_t sampler_slot, ISamplerState* state);
    void                      SSSetTexture                 (size_t sampler_slot, ITexture* texture);
    void                      SSSetConstantBuffer          (size_t buffer_slot, IBuffer* buffer);
    IProgramParametersLayout* SSGetProgramParametersLayout ();
    IProgram*                 SSGetProgram                 ();
    ISamplerState*            SSGetSampler                 (size_t sampler_slot);
    ITexture*                 SSGetTexture                 (size_t sampler_slot);
    IBuffer*                  SSGetConstantBuffer          (size_t buffer_slot);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление растеризатором (rasterizer-stage)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void              RSSetState    (IRasterizerState* state);
    void              RSSetViewport (size_t render_target_slot, const Viewport& viewport);
    void              RSSetScissor  (size_t render_target_slot, const Rect& scissor_rect);
    IRasterizerState* RSGetState    ();
    const Viewport&   RSGetViewport (size_t render_target_slot);
    const Rect&       RSGetScissor  (size_t render_target_slot);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление выходным уровнем (output-stage)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                OSSetBlendState        (IBlendState* state);
    void                OSSetDepthStencilState (IDepthStencilState* state);
    void                OSSetStencilReference  (size_t reference);
    void                OSSetRenderTargets     (size_t views_count, IView** render_target_view, IView* depth_stencil_view);
    void                OSSetRenderTargetView  (size_t render_target_slot, IView* view);
    void                OSSetDepthStencilView  (IView* view);
    IBlendState*        OSGetBlendState        ();
    IDepthStencilState* OSGetDepthStencilState ();
    size_t              OSGetStencilReference  ();
    IView*              OSGetRenderTargetView  (size_t render_target_slot);
    IView*              OSGetDepthStencilView  ();
    bool                RenderTargetsChanged   () const { return render_targets_changed; }
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление уровнем вывода вершин
///////////////////////////////////////////////////////////////////////////////////////////////////
    void     SOSetTargets      (size_t buffers_count, IBuffer** buffers, const size_t* offsets);
    void     SOSetTarget       (size_t stream_output_slot, IBuffer* buffer, size_t offset);
    IBuffer* SOGetTarget       (size_t stream_output_slot);
    size_t   SOGetTargetOffset (size_t stream_output_slot);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка буферов отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    void ClearRenderTargetView (size_t render_target_slot, const Color4f& color);
    void ClearDepthStencilView (size_t clear_flags, float depth, unsigned char stencil);
    void ClearViews            (size_t clear_flags, size_t render_targets_count, const size_t* render_target_indices, const Color4f* colors, float depth, unsigned char stencil);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Генерация мип-уровней текстуры (необходимо для текстур в которые ведется рендеринг)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GenerateMips (ITexture* texture);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление предикатами отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    void        SetPredication    (IPredicate* predicate, bool predicate_value);
    IPredicate* GetPredicate      ();
    bool        GetPredicateValue ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование примитивов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DrawAuto             (PrimitiveType primitive_type);
    void Draw                 (PrimitiveType primitive_type, size_t first_vertex, size_t vertices_count);
    void DrawIndexed          (PrimitiveType primitive_type, size_t first_index, size_t indices_count, size_t base_vertex);
    void DrawInstanced        (PrimitiveType primitive_type, size_t vertex_count_per_instance, size_t instance_count, size_t first_vertex, size_t first_instance_location);
    void DrawIndexedInstanced (PrimitiveType primitive_type, size_t index_count_per_instance, size_t instance_count, size_t first_index, size_t base_vertex, size_t first_instance_location);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ожидание завершения выполнения буфера команд
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Flush ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Выполнение списка команд
///////////////////////////////////////////////////////////////////////////////////////////////////
    ICommandList* FinishCommandList  (bool restore_state);
    void          ExecuteCommandList (ICommandList* list, bool restore_state);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Копирование состояний
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Capture (const StateBlockMask&, ContextState&) const;
    void Apply   (const StateBlockMask&, const ContextState&);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка состояния подуровней в контекст
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();
    void PrepareDraw (PrimitiveType type);

  private:
    DxContextPtr          context;                 //контекст отрисовки
    RenderTargetContext   render_target_context;   //контекст целей отрисовки
    TextureManagerContext texture_manager_context; //контекст менеджера текстур
    InputManagerContext   input_manager_context;   //контекст менеджера входного уровня
    ShaderManagerContext  shader_manager_context;  //контекст менеджера шейдеров
    OutputManagerContext  output_manager_context;  //контекст менеджера выходного уровня
    QueryManagerContext   query_manager_context;   //контекст менеджера запросов
    PrimitiveType         current_primitive_type;  //текущий тип примитивов
    bool                  render_targets_changed;  //были ли изменены целевые буферы
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отладочный слой устройства
///////////////////////////////////////////////////////////////////////////////////////////////////
class DeviceDebugLayer: public xtl::noncopyable, private common::Lockable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    DeviceDebugLayer  (const DxDevicePtr& device);
    ~DeviceDebugLayer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Остановка
///////////////////////////////////////////////////////////////////////////////////////////////////
    void StopAndJoin ();

  private:
    void UpdateMessages ();
    void UpdateMessagesCore ();

    typedef xtl::uninitialized_storage<char> Buffer;

  private:
    Log            log;                      //поток отладочного протоколирования
    DxDevicePtr    device;                   //устройство отрисовки
    DxInfoQueuePtr info_queue;               //очередь информационных сообщений
    common::Action update_action;            //действие обновления сообщений
    UINT64         processed_messages_count; //количество обработанных сообщений
    Buffer         message_buffer;           //буфер сообщения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Устройство отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
class Device: virtual public IDevice, public Object
{
  public:  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Device  (const Library& library, const AdapterPtr& adapter, const char* init_string);
    ~Device ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора устройства / адаптера
///////////////////////////////////////////////////////////////////////////////////////////////////
    ID3D11Device& GetHandle  ();
    AdapterPtr    GetAdapter ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя устройства
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetName ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение возможностей устройства
///////////////////////////////////////////////////////////////////////////////////////////////////
    void        GetCaps                        (DeviceCaps&);
    const char* GetCapString                   (DeviceCapString);
    const char* GetVertexAttributeSemanticName (VertexAttributeSemantic semantic);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    IInputLayout*             CreateInputLayout             (const InputLayoutDesc&);
    IProgramParametersLayout* CreateProgramParametersLayout (const ProgramParametersLayoutDesc&);
    IRasterizerState*         CreateRasterizerState         (const RasterizerDesc&);
    IBlendState*              CreateBlendState              (const BlendDesc&);
    IDepthStencilState*       CreateDepthStencilState       (const DepthStencilDesc&);
    ISamplerState*            CreateSamplerState            (const SamplerDesc&);
    IBuffer*                  CreateBuffer                  (const BufferDesc&, const void* data);
    IProgram*                 CreateProgram                 (size_t shaders_count, const ShaderDesc* shader_descs, const LogFunction& error_log);
    ITexture*                 CreateTexture                 (const TextureDesc&);
    ITexture*                 CreateTexture                 (const TextureDesc&, const TextureData&);
    ITexture*                 CreateTexture                 (const TextureDesc&, IBuffer* buffer, size_t buffer_offset, const size_t* mip_sizes);
    ITexture*                 CreateRenderTargetTexture     (ISwapChain* swap_chain, size_t buffer_index);
    ITexture*                 CreateDepthStencilTexture     (ISwapChain* swap_chain);
    IView*                    CreateView                    (ITexture* texture, const ViewDesc&);
    IPredicate*               CreatePredicate               ();
    IQuery*                   CreateQuery                   (QueryType type);
    IStateBlock*              CreateStateBlock              (const StateBlockMask& mask);
    IDeviceContext*           CreateDeferredContext         ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Список свойств устройства отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    IPropertyList* GetProperties ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение непосредственного контекста выполнения операций
///////////////////////////////////////////////////////////////////////////////////////////////////
    IDeviceContext* GetImmediateContext ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Инициализация целевых буферов (в случае отсутствия буферов по умолчанию)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void InitRenderTargets (SwapChain&);

  private:
    ITexture* CreateTexture   (const TextureDesc&, const TextureData*);
    void      InitDefaults    ();
    void      StartDebugLayer ();
    void      StopDebugLayer  ();

  private:
    Library                            library;               //библиотека драйвера
    AdapterPtr                         adapter;               //адаптер устройства
    PropertyList                       properties;            //свойства устройства
    DxDevicePtr                        device;                //устройство отрисовки
    stl::auto_ptr<DeviceManager>       device_manager;        //менеджер устройства
    ContextPtr                         immediate_context;     //непосредственный конеткст отрисовки
    stl::auto_ptr<RenderTargetManager> render_target_manager; //менеджер целей рендеринга
    stl::auto_ptr<TextureManager>      texture_manager;       //менеджер текстур
    stl::auto_ptr<InputManager>        input_manager;         //менеджер входного уровня
    stl::auto_ptr<ShaderManager>       shader_manager;        //менеджер шейдеров
    stl::auto_ptr<OutputManager>       output_manager;        //менеджер выходного уровня
    stl::auto_ptr<QueryManager>        query_manager;         //менеджер запросов
    DefaultResources                   default_resources;     //ресурсы по умолчанию
    InitialResources                   initial_resources;     //ресурсы инициализации
    stl::auto_ptr<DeviceDebugLayer>    debug_layer;           //отладочный слой
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация драйвера для DX11
///////////////////////////////////////////////////////////////////////////////////////////////////
class Driver: virtual public IDriver, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Driver  ();
    ~Driver ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание драйвера
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetDescription ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение возможностей драйвера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetCaps (DriverCaps&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перечисление доступных адаптеров
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t    GetAdaptersCount ();
    IAdapter* GetAdapter       (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание адаптера
///////////////////////////////////////////////////////////////////////////////////////////////////
    IAdapter* CreateAdapter (const char* name, const char* path, const char* init_string);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
    ISwapChain* CreateSwapChain (size_t prefered_adapters_count, IAdapter** prefered_adapters, const SwapChainDesc& desc);
    ISwapChain* CreateSwapChain (IDevice* device, const SwapChainDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание устройства отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    IDevice* CreateDevice (ISwapChain* swap_chain, const char* init_string);
    IDevice* CreateDevice (size_t prefered_adapters_count, IAdapter** prefered_adapters, const char* init_string);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка функции отладочного протоколирования драйвера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetDebugLog (const LogFunction&);
    const LogFunction& GetDebugLog ();

  private:
    void RegisterAdapter   (IAdapter*);
    void UnregisterAdapter (IAdapter*);

  private: 
    typedef stl::vector<IAdapter*>  AdapterWeakArray;
    typedef xtl::com_ptr<Adapter>   AdapterPtr;
    typedef stl::vector<AdapterPtr> AdapterArray;

  private:
    Library          library;             //библиотека драйвера
    DxFactoryPtr     factory;             //фабрика DXGI
    AdapterArray     adapters;            //адаптеры отрисовки
    AdapterWeakArray registered_adapters; //зарегистрированные адаптеры отрисовки
    Log              log;                 //поток отладочного протоколирования
    LogFunction      dummy_log_fn;        //функция отладочного протоколирования
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Блок состояний устройства отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
class StateBlock: virtual public IStateBlock, public DeviceObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    StateBlock  (const DeviceManager& manager, const StateBlockMask&);
    ~StateBlock ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение маски блока
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetMask (StateBlockMask&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Захват настроек устройства
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Capture (IDeviceContext* context);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Применение настроек устройства
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Apply (IDeviceContext* context);

  private:
    ContextState   state; //состояние    
    StateBlockMask mask;  //маска состояний
};

}

}

}

#endif
