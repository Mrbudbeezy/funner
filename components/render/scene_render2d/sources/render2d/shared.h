#ifndef SCENE_GRAPH_RENDER2D_HEADER
#define SCENE_GRAPH_RENDER2D_HEADER

#include <cfloat>

#include <stl/hash_map>

#include <xtl/common_exceptions.h>
#include <xtl/function.h>
#include <xtl/reference_counter.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/connection.h>
#include <xtl/bind.h>
#include <xtl/visitor.h>
#include <xtl/iterator.h>
#include <xtl/token_parser.h>
#include <xtl/trackable.h>

#include <math/utility.h>

#include <common/component.h>
#include <common/log.h>
#include <common/strlib.h>
#include <common/property_map.h>

#include <media/compressed_image.h>
#include <media/image.h>
#include <media/font.h>
#include <media/rfx/material_library.h>
#include <media/rfx/sprite_material.h>
#include <media/video.h>

#include <sg/camera.h>
#include <sg/height_map.h>
#include <sg/page_curl.h>
#include <sg/scene.h>
#include <sg/sprite.h>
#include <sg/text_line.h>

#include <render/low_level/device.h>
#include <render/low_level/state.h>

#include <render/mid_level/low_level_renderer.h>
#include <render/mid_level/renderer2d.h>

#include <render/custom_render.h>

namespace render
{

namespace obsolete
{

namespace render2d
{

//forward declaration
class Render;

typedef mid_level::renderer2d::IPrimitive    IPrimitive;
typedef mid_level::renderer2d::IRenderer     IRenderer;
typedef mid_level::renderer2d::IFrame        IFrame;
typedef mid_level::renderer2d::ITexture      ITexture;
typedef mid_level::IRenderTarget             IRenderTarget;
typedef mid_level::renderer2d::BlendMode     BlendMode;
typedef xtl::com_ptr<IPrimitive>             PrimitivePtr;
typedef xtl::com_ptr<IRenderer>              RendererPtr;
typedef xtl::com_ptr<IFrame>                 FramePtr;
typedef xtl::com_ptr<ITexture>               TexturePtr;
typedef xtl::com_ptr<IRenderTarget>          RenderTargetPtr;
typedef xtl::com_ptr<IRenderQuery>           RenderQueryPtr;
typedef media::rfx::obsolete::SpriteMaterial SpriteMaterial;
typedef SpriteMaterial::Pointer              SpriteMaterialPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Объект, требующий обновления при рендеринге entity
///////////////////////////////////////////////////////////////////////////////////////////////////
class IRenderablePrerequisite: public xtl::reference_counter
{
  public:
    virtual ~IRenderablePrerequisite () {}  
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Update () = 0;
};

typedef xtl::intrusive_ptr<IRenderablePrerequisite> PrerequisitePtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый визуализируемый объект
///////////////////////////////////////////////////////////////////////////////////////////////////
class Renderable: public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
            Renderable  (scene_graph::Entity*);
    virtual ~Renderable () {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw (IFrame& frame);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Информация для обновления видео текстур
///////////////////////////////////////////////////////////////////////////////////////////////////
    void  SetVideoPosition (float position);
    float VideoPosition    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление объектов, требующих пререндеринга
///////////////////////////////////////////////////////////////////////////////////////////////////  
    void AddPrerender (const PrerequisitePtr&);

  private:
    void UpdateNotify ();    

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об изменениях в объекте
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Update () {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void DrawCore (IFrame& frame) = 0;
    
  private:
    typedef stl::vector<PrerequisitePtr> PrerequisiteList;

  private:
    xtl::auto_connection on_update_connection;  //соединение на сигнал оповещения об обновлении объекта
    bool                 need_update;           //флаг необходимости обновления внутренних структур данных объекта
    float                video_position;        //позиция для видео текстур
    PrerequisiteList     prerender;             //список объектов, требующих предварительного рендеринга
    scene_graph::Entity* entity;                //ссылка на объект
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Модель, состоящая из спрайтов
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderableSpriteModel: public Renderable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderableSpriteModel (scene_graph::SpriteModel* model, Render& render);
    ~RenderableSpriteModel ();

  private:
    void Update ();
    void DrawCore (IFrame&);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Модель, описанная картой высот
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderableHeightMap: public Renderable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderableHeightMap (scene_graph::HeightMap* model, Render& render);
    ~RenderableHeightMap ();

  private:
    void Update ();
    void DrawCore (IFrame&);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подготовленные к рендерингу шрифт
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderableFont
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderableFont (const char* font_name, Render& in_render);
    ~RenderableFont ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение шрифта
///////////////////////////////////////////////////////////////////////////////////////////////////
    const media::Font& GetFont () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    ITexture* GetTexture () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение размера самой большой стороны глифа
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetMaxGlyphSide () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение спрайта по индексу
///////////////////////////////////////////////////////////////////////////////////////////////////
    const render::mid_level::renderer2d::Sprite& GetSprite (size_t index) const;
      //ввести другую структуру!!!!

  private:
    typedef xtl::uninitialized_storage<render::mid_level::renderer2d::Sprite> SpritesBuffer;

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Линия текста
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderableTextLine: public Renderable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderableTextLine (scene_graph::TextLine* text_line, Render& render);
    ~RenderableTextLine ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление линии текста
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Update ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка нового шрифта
///////////////////////////////////////////////////////////////////////////////////////////////////
    void PreprocessFont ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование линии текста
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DrawCore (IFrame&);

  private:
    typedef xtl::uninitialized_storage<render::mid_level::renderer2d::Sprite> SpritesBuffer;

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сетка страницы
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderablePageCurlMesh : public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderablePageCurlMesh  (low_level::IDevice& device, const math::vec2ui& grid_size);
    ~RenderablePageCurlMesh ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Трансформация страницы
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Curl (const math::vec2f& corner_position, scene_graph::PageCurlCorner corner, float curl_x,
               float radius, float angle, size_t find_best_curl_steps, float binding_mismatch_weight);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рассчет цвета вершин
///////////////////////////////////////////////////////////////////////////////////////////////////
    void CalculateShadow (bool front);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка параметров
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetColor     (const math::vec4ub& color);
    void SetSize      (const math::vec2f&  size);
    void SetTexCoords (float min_s, float min_t, float max_s, float max_t);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw (low_level::IDevice& device);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение информации после трансформации
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool               HasRightSideBendPosition    ();
    bool               HasLeftSideBendPosition     ();
    bool               HasBottomSideBendPosition   ();
    bool               HasTopSideBendPosition      ();
    const math::vec3f& GetRightSideBendPosition    ();
    const math::vec3f& GetLeftSideBendPosition     ();
    const math::vec3f& GetTopSideBendPosition      ();
    const math::vec3f& GetBottomSideBendPosition   ();
    const math::vec3f& GetRightSideDetachPosition  ();
    const math::vec3f& GetLeftSideDetachPosition   ();
    const math::vec3f& GetTopSideDetachPosition    ();
    const math::vec3f& GetBottomSideDetachPosition ();
    bool               HasRightSideDetachPosition  ();
    bool               HasLeftSideDetachPosition   ();
    bool               HasTopSideDetachPosition    ();
    bool               HasBottomSideDetachPosition ();
    const math::vec3f& GetCornerPosition           (scene_graph::PageCurlCorner corner);

  private:
    RenderablePageCurlMesh (const RenderablePageCurlMesh&);             //no impl
    RenderablePageCurlMesh& operator = (const RenderablePageCurlMesh&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перелистывание страницы
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderablePageCurl: public Renderable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderablePageCurl (scene_graph::PageCurl* page_curl, Render& render);
    ~RenderablePageCurl ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Update ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DrawCore (IFrame&);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Область вывода рендера
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderView: public IRenderView, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderView  (scene_graph::Scene*, Render*);
    ~RenderView ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Целевые буферы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void           SetRenderTargets      (IRenderTarget* render_target, IRenderTarget* depth_stencil_target);
    IRenderTarget* GetRenderTarget       ();
    IRenderTarget* GetDepthStencilTarget ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка области вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetViewport (const render::obsolete::Rect& rect, float min_depth, float max_depth);
    void GetViewport (render::obsolete::Rect& out_rect, float& min_depth, float& max_depth);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка камеры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                 SetCamera (scene_graph::Camera*);
    scene_graph::Camera* GetCamera ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / чтение свойств
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetProperty (const char* name, const char* value);
    void GetProperty (const char* name, size_t buffer_size, char* value_buffer);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddRef  ();
    void Release ();

  private:
    typedef xtl::intrusive_ptr<Render> RenderPtr;

  private:
    RenderPtr            render; //рендер
    FramePtr             frame;  //кадр
    scene_graph::Scene*  scene;  //сцена
    scene_graph::Camera* camera; //камера
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рендер двумерной сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class Render: public ICustomSceneRender, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Render  (mid_level::IRenderer*);
    ~Render ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание областей вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    IRenderView* CreateRenderView (scene_graph::Scene* scene);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с ресурсами
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadResource   (const char* tag, const char* file_name);
    void UnloadResource (const char* tag, const char* file_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Протоколирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetLogHandler (const LogFunction&);
    const LogFunction& GetLogHandler ();

    void LogPrintf (const char* format, ...);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание дочерних запросов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                 SetQueryHandler (const QueryFunction&);
    const QueryFunction& GetQueryHandler ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddRef  ();
    void Release ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение системы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    const RendererPtr& Renderer () const { return renderer; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с кэшем
///////////////////////////////////////////////////////////////////////////////////////////////////
    Renderable*     GetRenderable (scene_graph::SpriteModel*);  // дублирование!!!
    Renderable*     GetRenderable (scene_graph::HeightMap*);    // дублирование!!!
    Renderable*     GetRenderable (scene_graph::TextLine*);     // дублирование!!!
    Renderable*     GetRenderable (scene_graph::PageCurl*);     // дублирование!!!
    ITexture*       GetTexture    (const char* file_name, bool need_alpha, Renderable* renderable = 0);
    SpriteMaterial* GetMaterial   (const char* name);
    RenderableFont* GetFont       (const char* name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление кадра на отрисовку
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddFrame (IFrame*);

  private:
    typedef xtl::intrusive_ptr<Renderable> RenderablePtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с кэшем примитивов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void InsertRenderable (scene_graph::Entity*, const RenderablePtr&);
    void RemoveRenderable (scene_graph::Entity*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с ресурсами
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadMaterialLibrary   (const char* file_name);
    void UnloadMaterialLibrary (const char* file_name);
    void InsertMaterial        (const char* id, const SpriteMaterialPtr&);
    void RemoveMaterial        (const char* id);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание текстур
///////////////////////////////////////////////////////////////////////////////////////////////////
    TexturePtr CreateTexture        (const char* file_name, bool need_alpha, bool& has_alpha, bool& is_shared, Renderable* renderable, PrerequisitePtr& prerender);
    TexturePtr CreateDynamicTexture (const char* name, PrerequisitePtr& prerender);
    TexturePtr CreateVideoTexture   (const char* name, Renderable* renderable, PrerequisitePtr& prerender);

  private:
    struct RenderableHolder
    {
      RenderablePtr        renderable;
      xtl::auto_connection on_destroy;

      RenderableHolder (const RenderablePtr& in_renderable)
        : renderable (in_renderable) {}
    };

    struct TextureHolder
    {
      TexturePtr      base_texture;   //базовая текстура
      TexturePtr      alpha_texture;  //альфа-текстура
      PrerequisitePtr prerender;      //пререндер

      TextureHolder (const TexturePtr& in_base_texture, const TexturePtr& in_alpha_texture, const PrerequisitePtr& in_prerender) 
        : base_texture (in_base_texture)
        , alpha_texture (in_alpha_texture)
        , prerender (in_prerender)
      { }
    };

    typedef stl::hash_map<scene_graph::Entity*, RenderableHolder>        RenderableMap;
    typedef stl::hash_map<stl::hash_key<const char*>, SpriteMaterialPtr> MaterialMap;
    typedef stl::hash_map<stl::hash_key<const char*>, TextureHolder>     TextureMap;
    typedef xtl::shared_ptr<RenderableFont>                              RenderableFontPtr;
    typedef stl::hash_map<stl::hash_key<const char*>, RenderableFontPtr> RenderableFontMap;

  private:
    LogFunction       log_handler;       //функция протоколирования
    QueryFunction     query_handler;     //функция создания дочерних запросов
    RendererPtr       renderer;          //система рендеринга
    RenderableMap     renderables_cache; //кэш визуализируемых объектов
    MaterialMap       materials;         //материалы
    TextureMap        textures;          //текстуры
    RenderableFontMap fonts;             //шрифты
};

}

}

}

#endif
