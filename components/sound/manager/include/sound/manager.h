#ifndef SOUND_MANAGER_HEADER
#define SOUND_MANAGER_HEADER

#include <xtl/functional_fwd>
#include <xtl/trackable.h>
#include <stl/auto_ptr.h>
#include <math/vector.h>
#include <sound/listener.h>

namespace sound
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///События излучателя звука
///////////////////////////////////////////////////////////////////////////////////////////////////
enum EmitterEvent
{
  EmitterEvent_OnDestroy,          //вызывается непосредственно перед удалением излучателя
  EmitterEvent_OnActivate,         //излучатель активирован
  EmitterEvent_OnDeactivate,       //излучателя деактивирован
  EmitterEvent_OnUpdateVolume,     //изменена громкость звука
  EmitterEvent_OnUpdateProperties, //изменены параметры излучателя звука

  EmitterEvent_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Излучатель звука
///////////////////////////////////////////////////////////////////////////////////////////////////
class Emitter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Emitter  ();
    ~Emitter ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Источник звука
///////////////////////////////////////////////////////////////////////////////////////////////////
    void        SetSource (const char* source_name);
    const char* Source    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Указание номера сэмпла на источнике звука
///////////////////////////////////////////////////////////////////////////////////////////////////
    void   SetSampleIndex (size_t sample_index);  //при проигрывании в менеджере устанавливается индекс сэмпла равный остатку от деления sample_index на общее количество сэмплов
    size_t SampleIndex    () const;               //индекс, установленный в SetSampleIndex. По умолчанию 0

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка добавочной громкости звука
///////////////////////////////////////////////////////////////////////////////////////////////////
    void  SetVolume (float volume);
    float Volume    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка динамических параметров излучателя
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetPosition  (const math::vec3f&);
    void SetDirection (const math::vec3f&);
    void SetVelocity  (const math::vec3f&);

    const math::vec3f& Position  () const;
    const math::vec3f& Direction () const;
    const math::vec3f& Velocity  () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление активностью
///  - первый вызов Activate генерирует событие EmitterEvent_OnActivate
///  - последний вызов Deactivate генерирует событие EmitterEvent_OnDeactivate
///  - излучатель является активным до тех пор, пока проигрывается хотя бы в одном менеджере
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Activate   ();
    void Deactivate ();
    bool IsActive   () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подписка на события
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (Emitter&, EmitterEvent)> EventHandler;

    xtl::connection RegisterEventHandler (EmitterEvent, const EventHandler&);

  private:
    Emitter (const Emitter&);             //no impl
    Emitter& operator = (const Emitter&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер проигрывания звуков
///////////////////////////////////////////////////////////////////////////////////////////////////
class SoundManager
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SoundManager  (const char* driver_mask, const char* device_mask, const char* init_string="");
    ~SoundManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Уровень громкости
///////////////////////////////////////////////////////////////////////////////////////////////////
    void  SetVolume (float volume);
    float Volume    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Блокировка проигрывания звука
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetMute (bool state);
    bool IsMuted () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проигрывание звуков
///////////////////////////////////////////////////////////////////////////////////////////////////
    void  PlaySound        (Emitter& emitter, float offset=0.0f);
    void  StopSound        (Emitter& emitter);
    float Tell             (Emitter&) const;
    float Duration         (Emitter&) const;
    bool  IsLooping        (Emitter&) const;
    bool  IsPlaying        (Emitter&) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Применение операции ко всем слушателям
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (Emitter&)>       EmitterHandler;
    typedef xtl::function<void (const Emitter&)> ConstEmitterHandler;

    void ForEachEmitter (const EmitterHandler&);
    void ForEachEmitter (const ConstEmitterHandler&) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Применение операции ко всем слушателям c заданным типом
///////////////////////////////////////////////////////////////////////////////////////////////////
    void ForEachEmitter (const char* type, const EmitterHandler&);
    void ForEachEmitter (const char* type, const ConstEmitterHandler&) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация обработчиков события удаления объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    xtl::connection RegisterDestroyHandler (xtl::trackable::slot_type& handler);
    xtl::connection RegisterDestroyHandler (const xtl::trackable::function_type& handler);
    xtl::connection RegisterDestroyHandler (const xtl::trackable::function_type& handler, xtl::trackable& trackable);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка слушателя
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                   SetListener (const sound::Listener&);
    const sound::Listener& Listener    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка/выгрузка библиотек звуков
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadSoundLibrary (const char* file_name);
    void UnloadSoundLibrary (const char* file_name);

  private:
    SoundManager (const SoundManager&); //no impl
    SoundManager& operator = (const SoundManager&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

}

#endif
