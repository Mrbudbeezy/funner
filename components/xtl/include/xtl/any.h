#ifndef XTL_ANY_HEADER
#define XTL_ANY_HEADER

#include <exception>
#include <typeinfo>
#include <xtl/utility>

namespace xtl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исключение: ошибка приведения any-типа данных
///////////////////////////////////////////////////////////////////////////////////////////////////
class bad_any_cast: public std::bad_cast
{
  public:
    virtual const char* what () const throw () { return "xtl::bad_any_cast"; }
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обёртка для хранения объектов различных типов
///////////////////////////////////////////////////////////////////////////////////////////////////
class any
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
                       any  ();
    template <class T> any  (const T& value);
                       any  (const any&);
                       ~any ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    any& operator = (const any&);
    
    template <class T> any& operator = (const T& value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool empty () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип и данные
///////////////////////////////////////////////////////////////////////////////////////////////////    
    const std::type_info& type () const;

    template <class T>       T* content ();
    template <class T> const T* content () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    any& swap (any&);
                       
  private: 
    struct holder;
    
    template <class T> struct holder_impl;

    holder* content_ptr;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (any&, any&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Приведение типов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>       T* any_cast (any*);
template <class T> const T* any_cast (const any*);
template <class T>       T  any_cast (any&);
template <class T> const T  any_cast (const any&);

#include <xtl/detail/type_traits/refptr.inl>
#include <xtl/detail/any.inl>

}

#endif
