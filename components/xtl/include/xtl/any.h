#ifndef XTL_ANY_HEADER
#define XTL_ANY_HEADER

#include <exception>
#include <typeinfo>
#include <xtl/dynamic_cast_root.h>
#include <xtl/lexical_cast.h>
#include <xtl/default_cast_type.h>
#include <xtl/type.h>
#include <xtl/type_traits> //for is_polymorphic, remove_reference
#include <xtl/ref.h>

namespace stl
{

//forward declarations
template <class T> class auto_ptr;

}

namespace xtl
{

namespace detail
{

//implementation forwards
struct any_holder;

}

//forward declaration
template <class T> class shared_ptr;
template <class T> class com_ptr;

template <class T, template <class > class Strategy>  class intrusive_ptr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исключение: ошибка приведения any-типа данных
///////////////////////////////////////////////////////////////////////////////////////////////////
class bad_any_cast: public std::bad_cast
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Виды ошибок
///////////////////////////////////////////////////////////////////////////////////////////////////
    enum cast_error
    {
      bad_cast,              //неизвестная ошибка приведения
      bad_direct_cast,       //ошибка прямого приведения типов
      bad_const_cast,        //ошибка понижения квалификаторов типа
      bad_dynamic_cast,      //ошибка динамического приведения типов
      bad_to_string_cast,    //ошибка лексикографического приведения типа к строке
      bad_to_value_cast,     //ошибка лексикографического приведения типа из строки
      bad_to_reference_cast  //ошибка приведения значения к ссылке (невозможность приведения к ссылке в to_value)
    };
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    bad_any_cast (cast_error error_id = bad_cast);
    bad_any_cast (cast_error error_id, const std::type_info& source_type, const std::type_info& target_type);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исходный и целевой типы
///////////////////////////////////////////////////////////////////////////////////////////////////
    const std::type_info& source_type () const;
    const std::type_info& target_type () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вид ошибки
///////////////////////////////////////////////////////////////////////////////////////////////////
    cast_error error () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сообщение
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* what () const throw ();

  private:
    cast_error           error_id;
    const std::type_info *source, *target;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обёртка для хранения объектов различных типов
///////////////////////////////////////////////////////////////////////////////////////////////////
class any
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    any  ();
    any  (const any&);
    ~any ();
                       
    template <class T> any (const T& value, bool ref_counted=false);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    any& operator = (const any&);
    
    template <class T> any& operator = (const T& value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool empty () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип и данные
///////////////////////////////////////////////////////////////////////////////////////////////////
    const std::type_info& type () const;

    template <class T>       T* content ();
    template <class T> const T* content () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Приведение
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> const T cast () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Лексикографическое приведение
///////////////////////////////////////////////////////////////////////////////////////////////////
    void to_string   (stl::string& buffer) const;
    void set_content (const stl::string& buffer);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    any& swap (any&);
    
  private:
    template <class T>
    static detail::any_holder* create_holder (const T&, bool ref_counted);
                       
  private: 
    detail::any_holder* content_ptr;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (any&, any&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание any с подсчётом ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> any make_ref_any (const T&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Приведение типов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>       T* any_cast (any*);
template <class T> const T* any_cast (const any*);
template <class T>       T  any_cast (any&);
template <class T> const T  any_cast (const any&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Многоуровневое приведение типов:
///   - попытка приведений квалификаторов (const, volataile, const volataile)
///   - попытка dynamic_cast приведений (для типов приводимых к dynamic_cast_root)
///   - попытка лексикографических приведений (lexical_cast)
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> const T any_multicast (const any&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение приводимого значения. Используется как базовое при работе any_multicast
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> T& get_castable_value (T&);
template <class T> T& get_castable_value (T*);
template <class T> T& get_castable_value (stl::auto_ptr<T>&);
template <class T> T& get_castable_value (shared_ptr<T>&);
template <class T> T& get_castable_value (com_ptr<T>&);
template <class T> T& get_castable_value (reference_wrapper<T>&);

template <class T, template <class > class Strategy>
T& get_castable_value (intrusive_ptr<T, Strategy>&);

char*    get_castable_value (char*);
wchar_t* get_castable_value (wchar_t*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Лексикографическое приведение типов any (без изменения типа any)
///////////////////////////////////////////////////////////////////////////////////////////////////
void to_string (stl::string& buffer, const volatile any& value);
void to_value  (const stl::string& buffer, volatile any& value);

#include <xtl/detail/any.inl>

}

#endif
