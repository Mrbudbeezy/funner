#ifndef XTL_ANY_HEADER
#define XTL_ANY_HEADER

#include <exception>
#include <typeinfo>
#include <xtl/dynamic_cast_root.h>
#include <xtl/lexical_cast.h>
#include <xtl/default_cast_type.h>
#include <xtl/type.h>
#include <xtl/type_traits> //for is_polymorphic, remove_reference

namespace stl
{

//forward declarations
template <class T> class auto_ptr;

}

namespace xtl
{

namespace detail
{

//implementation forwards
struct any_holder;

}

//forward declaration
template <class T>                  class shared_ptr;
template <class T, class Strategy>  class intrusive_ptr;
template <class T>                  class com_ptr;
template <class T>                  class reference_wrapper;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исключение: ошибка приведения any-типа данных
///////////////////////////////////////////////////////////////////////////////////////////////////
class bad_any_cast: public std::bad_cast
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    bad_any_cast ();
    bad_any_cast (const std::type_info& source_type, const std::type_info& target_type);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исходный и целевой типы
///////////////////////////////////////////////////////////////////////////////////////////////////
    const std::type_info& source_type () const;
    const std::type_info& target_type () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сообщение
///////////////////////////////////////////////////////////////////////////////////////////////////    
    const char* what () const throw () { return "xtl::bad_any_cast"; }

  private:
    const std::type_info *source, *target;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исключение: ошибка приведения any-типа данных (при const_cast приведении)
///////////////////////////////////////////////////////////////////////////////////////////////////
class bad_any_const_cast: public bad_any_cast
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    bad_any_const_cast () {}
    bad_any_const_cast (const std::type_info& source_type, const std::type_info& target_type);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сообщение
///////////////////////////////////////////////////////////////////////////////////////////////////    
    const char* what () const throw () { return "xtl::bad_any_const_cast"; }
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исключение: ошибка приведения any-типа данных (при dynamic_cast приведении)
///////////////////////////////////////////////////////////////////////////////////////////////////
class bad_any_dynamic_cast: public bad_any_cast
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    bad_any_dynamic_cast () {}
    bad_any_dynamic_cast (const std::type_info& source_type, const std::type_info& target_type);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сообщение
///////////////////////////////////////////////////////////////////////////////////////////////////    
    const char* what () const throw () { return "xtl::bad_any_dynamic_cast"; }
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исключение: ошибка приведения any-типа данных (при lexical_cast приведении)
///////////////////////////////////////////////////////////////////////////////////////////////////
class bad_any_lexical_cast: public bad_any_cast
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    bad_any_lexical_cast () {}
    bad_any_lexical_cast (const std::type_info& source_type, const std::type_info& target_type);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сообщение
///////////////////////////////////////////////////////////////////////////////////////////////////    
    const char* what () const throw () { return "xtl::bad_any_lexical_cast"; }
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обёртка для хранения объектов различных типов
///////////////////////////////////////////////////////////////////////////////////////////////////
class any
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    any  ();
    any  (const any&);
    ~any ();
                       
    template <class T> any (const T& value, bool ref_counted=false);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    any& operator = (const any&);
    
    template <class T> any& operator = (const T& value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool empty () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип и данные
///////////////////////////////////////////////////////////////////////////////////////////////////
    const std::type_info& type () const;

    template <class T>       T* content ();
    template <class T> const T* content () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Приведение
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> const T cast () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Лексикографическое приведение
///////////////////////////////////////////////////////////////////////////////////////////////////
    void to_string   (stl::string& buffer) const;
    void set_content (const stl::string& buffer);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    any& swap (any&);
    
  private:
    template <class T>
    static detail::any_holder* create_holder (const T&, bool ref_counted);
                       
  private: 
    detail::any_holder* content_ptr;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (any&, any&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание any с подсчётом ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> any make_ref_any (const T&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Приведение типов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>       T* any_cast (any*);
template <class T> const T* any_cast (const any*);
template <class T>       T  any_cast (any&);
template <class T> const T  any_cast (const any&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Многоуровневое приведение типов:
///   - попытка приведений квалификаторов (const, volataile, const volataile)
///   - попытка dynamic_cast приведений (для типов приводимых к dynamic_cast_root)
///   - попытка лексикографических приведений (lexical_cast)
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> const T any_multicast (const any&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение приводимого значения. Используется как базовое при работе any_multicast
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> T& get_castable_value (T&);

template <class T>                 T& get_castable_value (T*);
template <class T>                 T& get_castable_value (stl::auto_ptr<T>&);
template <class T>                 T& get_castable_value (shared_ptr<T>&);
template <class T, class Strategy> T& get_castable_value (intrusive_ptr<T, Strategy>&);
template <class T>                 T& get_castable_value (com_ptr<T>&);
template <class T>                 T& get_castable_value (reference_wrapper<T>&);

char*    get_castable_value (char*);
wchar_t* get_castable_value (wchar_t*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Лексикографическое приведение типов any (без изменения типа any)
///////////////////////////////////////////////////////////////////////////////////////////////////
void to_string (stl::string& buffer, const volatile any& value);
void to_value  (const stl::string& buffer, volatile any& value);

#include <xtl/detail/any.inl>

}

#endif
