#ifndef XTL_TRACKABLE_PTR_HEADER
#define XTL_TRACKABLE_PTR_HEADER

#include <xtl/trackable.h>
#include <xtl/default_cast_type.h>

namespace xtl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исключение возникающее при обращении к недействительному указателю
///////////////////////////////////////////////////////////////////////////////////////////////////
class bad_trackable_ptr: public std::exception
{
  public:
    const char* what () const throw () { return "xtl::bad_trackable_ptr"; }
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///"Слабый" указатель, сбрасывающийся при удалении хранимого объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
class trackable_ptr
{
  typedef T* (trackable_ptr::*unspecified_bool_type)() const;
  public:
    typedef T                        element_type;
    typedef T*                       pointer;
    typedef T&                       reference;
    typedef trackable::slot_type     slot_type;
    typedef trackable::function_type function_type;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    trackable_ptr ();
    trackable_ptr (pointer);
    trackable_ptr (const trackable_ptr&);

    template <class T1> trackable_ptr (T1*);
    template <class T1> trackable_ptr (const trackable_ptr<T1>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    trackable_ptr& operator = (pointer);
    trackable_ptr& operator = (const trackable_ptr&);

    template <class T1> trackable_ptr& operator = (T1*);
    template <class T1> trackable_ptr& operator = (const trackable_ptr<T1>&);

    void reset ();
    void reset (pointer);

    template <class T1> void reset (T1*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Операции доступа
///////////////////////////////////////////////////////////////////////////////////////////////////
    pointer   get         () const;
    reference operator *  () const;
    pointer   operator -> () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Информация о состоянии указателя
///////////////////////////////////////////////////////////////////////////////////////////////////
    operator unspecified_bool_type () const { return ptr ? &trackable_ptr::get : 0; }
    bool     operator !            () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление/удаление обработчиков изменения состояния указателя
///////////////////////////////////////////////////////////////////////////////////////////////////
    connection connect (const function_type&);
    connection connect (slot_type&);

    template <class Fn> void disconnect (Fn);

    void disconnect_all ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сравнение
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T1> bool operator == (const trackable_ptr<T1>&) const;
    template <class T1> bool operator == (const T1*) const;
    template <class T1> bool operator != (const trackable_ptr<T1>&) const;
    template <class T1> bool operator != (const T1*) const;

  private:
    void update ();

  private:
    typedef signal<void ()> signal_type;

  private:
    pointer     ptr;
    slot_type   on_destroy;
    signal_type notification;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сравнение
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T1, class T2> bool operator == (const T1*, const trackable_ptr<T2>&);
template <class T1, class T2> bool operator != (const T1*, const trackable_ptr<T2>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение trackable-объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
trackable& get_trackable (trackable&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение указателя
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> T* get_pointer (trackable_ptr<T>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Переопределение таблиц типов для указателя
///////////////////////////////////////////////////////////////////////////////////////////////////
namespace type_traits
{

template <class T> struct is_pointer;
template <class T> struct remove_pointer;

template <class T> struct is_pointer<trackable_ptr<T> >     { enum { value = true }; };
template <class T> struct remove_pointer<trackable_ptr<T> > { typedef T type; };

}

#include <xtl/detail/trackable_ptr.inl>

}

#endif
