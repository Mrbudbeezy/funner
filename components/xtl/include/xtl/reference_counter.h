#ifndef XTL_REFERENCE_COUNTER_HEADER
#define XTL_REFERENCE_COUNTER_HEADER

#include <cstddef>

#include <xtl/checked_delete.h>
#include <xtl/interlocked.h>

namespace xtl
{

namespace reference_counter_namespace //для защиты от ADL
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Счётчик ссылок (multithread-safely)
///////////////////////////////////////////////////////////////////////////////////////////////////
class reference_counter
{
  typedef bool (reference_counter::*safe_bool)() const;
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    reference_counter (size_t start_counter = 1);
    reference_counter (const reference_counter&);

    reference_counter& operator = (const reference_counter&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t use_count () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool empty () const;

    operator safe_bool () const { return use_count () ? &reference_counter::empty : 0; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Увеличение / уменьшение количества ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void increment ();
    bool decrement (); //возвращает true, если counter стал равен нулю

  private:
    size_t counter;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Увеличение / уменьшение количества ссылок с вызовом пользовательского функтора при потере ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
                               void addref  (reference_counter&);
template <class Fn>            void release (reference_counter&, Fn fn);
                               void addref  (reference_counter*);
template <class Fn>            void release (reference_counter*, Fn fn);
template <class Ptr>           void release (const Ptr& ptr); //удаление объекта в случае потери ссылок
template <class Ptr, class Fn> void release (const Ptr& ptr, Fn deleter);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Взаимодействие с intrusive_ptr
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> void intrusive_ptr_add_ref (T*);
template <class T> void intrusive_ptr_release (T*);

#include <xtl/detail/reference_counter.inl>

#ifdef XTL_HAS_INTERLOCKED
  #include <xtl/detail/reference_counter_interlocked.inl>
#else
  #include <xtl/detail/reference_counter_nothreads.inl>
#endif

}

using xtl::reference_counter_namespace::reference_counter;

}

#endif
