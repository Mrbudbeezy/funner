#ifndef XTL_ITERATOR_HEADER
#define XTL_ITERATOR_HEADER

#include <stl/iterator_traits.h>

namespace xtl
{

namespace detail
{

//implementation forwards
template <class T> struct iterator_interface;

}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый класс исключений итераторов
///////////////////////////////////////////////////////////////////////////////////////////////////
struct iterator_exception: public std::exception
{
  const char* what () const throw () { return "xtl::iterator_exception"; }
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исключение: неверная операция (категория инстанцированного итератора не позволяет выполнить указанную операцию)
///////////////////////////////////////////////////////////////////////////////////////////////////
struct bad_iterator_operation: public iterator_exception
{
  const char* what () const throw () { return "xtl::bad_iterator_operation"; }
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исключение: попытка взятия значения в пустом итераторе
///////////////////////////////////////////////////////////////////////////////////////////////////
struct bad_iterator_dereference: public bad_iterator_operation
{
  const char* what () const throw () { return "xtl::bad_iterator_dereference"; }
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Полиморфный итератор
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
class iterator
{
  typedef bool (iterator::*safe_bool)() const;
  public:
    typedef T                               value_type;
    typedef size_t                          size_type;
    typedef ptrdiff_t                       difference_type;
    typedef T*                              pointer;
    typedef T&                              reference;
    typedef stl::bidirectional_iterator_tag iterator_category;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    iterator  ();
    iterator  (const iterator&);
    ~iterator ();
    
    template <class Iter> iterator (Iter);
    template <class Iter> iterator (Iter iter, Iter first, Iter last);
    template <class T1>   iterator (const iterator<T1>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    iterator& operator = (const iterator&);

    template <class T1>   iterator& operator = (const iterator<T1>&);
    template <class Iter> iterator& operator = (Iter);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка
///////////////////////////////////////////////////////////////////////////////////////////////////
    void clear ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool empty () const;

    operator safe_bool () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Селекторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    reference operator  * () const;
    pointer   operator -> () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Инкремент / декремент
///////////////////////////////////////////////////////////////////////////////////////////////////
    iterator& operator ++ ();
    iterator& operator -- ();
    iterator  operator ++ (int);
    iterator  operator -- (int);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сравнение
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool operator == (const iterator&) const;
    bool operator != (const iterator&) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void swap (iterator&);

  private:
    typedef detail::iterator_interface<T> iterator_interface;

    iterator_interface* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> void swap (iterator<T>&, iterator<T>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание итератора
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Iter> iterator<typename stl::iterator_traits<Iter>::value_type> make_iterator (Iter);

template <class Iter>
iterator<typename stl::iterator_traits<Iter>::value_type> make_iterator (Iter iter, Iter first, Iter last);

template <class Container>
iterator<typename Container::value_type> make_iterator (Container& c, size_t offset);

template <class Container>
iterator<const typename Container::value_type> make_iterator (const Container& c, size_t offset);

#include <xtl/detail/iterator.inl>

}

#endif
