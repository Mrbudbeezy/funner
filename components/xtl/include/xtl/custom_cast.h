#ifndef XTL_CUSTOM_CAST_HEADER
#define XTL_CUSTOM_CAST_HEADER

#include <memory.h>
#include <string.h>

#include <xtl/any_cast_exception.h>
#include <xtl/singleton_default.h>
#include <xtl/type_traits>

namespace xtl
{

namespace detail
{

//implementation forwards
struct custom_ref_caster_type_info;

}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Приведение типов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class From, class To> struct static_caster;
template <class From, class To> struct dynamic_caster;
template <class From, class To> struct reinterpret_caster;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Декларация возможности приведения типов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class FromT, class ToT = FromT, template <class, class> class CastTag = static_caster>
class declcast;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение конвертера
///////////////////////////////////////////////////////////////////////////////////////////////////
class custom_ref_caster
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
                          custom_ref_caster ();
    template <class From> custom_ref_caster (From& value);
    template <class From> custom_ref_caster (From*& value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Приведение типа
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class To> To   cast     () const;
    template <class To> bool has_cast () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool empty () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип элемента
///////////////////////////////////////////////////////////////////////////////////////////////////
    const std::type_info& type () const;

  private:
    void*                                      source;
    const detail::custom_ref_caster_type_info* source_type;
};

template <class From>
custom_ref_caster make_custom_ref_caster (From& value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Приведение типа
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class To, class From> To custom_cast (From&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка возможности приведения
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class From, class To> bool has_custom_cast ();

#include <xtl/detail/custom_cast.inl>

}

#endif

