#ifndef XTL_LOCK_PTR_HEADER
#define XTL_LOCK_PTR_HEADER

namespace xtl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Указатель, запирающий объект на время существования указателя
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, class Ptr=T*>
class lock_ptr
{
  typedef Ptr (lock_ptr::*unspecified_bool_type)() const;
  public:
    typedef T   element_type;
    typedef Ptr pointer;
    typedef T&  reference;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    lock_ptr  ();
    lock_ptr  (const pointer&);
    lock_ptr  (const lock_ptr&);
    ~lock_ptr ();    

    template <class T1>             lock_ptr (T1*);
    template <class T1, class Ptr1> lock_ptr (const lock_ptr<T1, Ptr1>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    lock_ptr& operator = (const pointer&);
    lock_ptr& operator = (const lock_ptr&);

    template <class T1>             lock_ptr& operator = (T1*);
    template <class T1, class Ptr1> lock_ptr& operator = (const lock_ptr<T1, Ptr1>&);

    void reset ();
    void reset (const pointer&);

    template <class T1> void reset (T1*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Операции доступа
///////////////////////////////////////////////////////////////////////////////////////////////////
    pointer   get         () const;
    reference operator *  () const;
    pointer   operator -> () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Информация о состоянии указателя
///////////////////////////////////////////////////////////////////////////////////////////////////
    operator unspecified_bool_type () const { return ptr ? &lock_ptr::get : 0; }
    bool     operator !            () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сравнение
///////////////////////////////////////////////////////////////////////////////////////////////////
                                    bool operator == (const pointer&) const;
    template <class T1, class Ptr1> bool operator == (const lock_ptr<T1, Ptr1>&) const;    
    template <class T1>             bool operator == (const T1*) const;
                                    bool operator != (const pointer&) const;    
    template <class T1, class Ptr1> bool operator != (const lock_ptr<T1, Ptr1>&) const;
    template <class T1>             bool operator != (const T1*) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void swap (lock_ptr&);

  private:
    void lock_object ();
    void unlock_object ();

  private:
    pointer ptr;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, class Ptr>
void swap (lock_ptr<T, Ptr>&, lock_ptr<T, Ptr>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сравнение
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, class Ptr> bool operator == (const typename lock_ptr<T, Ptr>::pointer&, const lock_ptr<T, Ptr>&);
template <class T, class Ptr> bool operator != (const typename lock_ptr<T, Ptr>::pointer&, const lock_ptr<T, Ptr>&);

template <class T1, class T2, class Ptr2> bool operator == (const T1*, const lock_ptr<T2, Ptr2>&);
template <class T1, class T2, class Ptr2> bool operator != (const T1*, const lock_ptr<T2, Ptr2>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение указателя
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, class Ptr> T* get_pointer (lock_ptr<T, Ptr>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Переопределение таблиц типов для указателя
///////////////////////////////////////////////////////////////////////////////////////////////////
namespace type_traits
{

template <class T> struct is_pointer;
template <class T> struct remove_pointer;

template <class T> struct is_pointer<lock_ptr<T> >     { enum { value = true }; };
template <class T> struct remove_pointer<lock_ptr<T> > { typedef T type; };

}

#include <xtl/detail/lock_ptr.inl>

}

#endif
