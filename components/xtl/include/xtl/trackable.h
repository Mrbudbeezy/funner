#ifndef XTL_TRACKABLE_HEADER
#define XTL_TRACKABLE_HEADER

#include <xtl/signal.h>

namespace xtl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Объект, оповещающий о своём удалении
///////////////////////////////////////////////////////////////////////////////////////////////////
class trackable
{
  public:
    typedef slot<void ()>     slot_type;
    typedef function<void ()> function_type;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    trackable  () {}
    trackable  (const trackable&) {}
    ~trackable ();

    trackable& operator = (const trackable&) { return *this; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление/удаление обработчиков удаления объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    connection connect_tracker (const function_type& handler);
    connection connect_tracker (slot_type& handler);
    connection connect_tracker (const function_type& handler, trackable& owner);
    connection connect_tracker (const connection&); //разрыв соединения при удалении объекта

    template <class Fn> void disconnect_tracker (Fn);

    void disconnect_all_trackers ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество обработчиков
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t num_trackers () const;

  private:
    typedef signal<void ()> signal_type;

  private:
    signal_type sig;
};

#include <xtl/detail/trackable.inl>

}

#endif
