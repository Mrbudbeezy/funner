#ifndef XTL_STRING_BUFFER_HEADER
#define XTL_STRING_BUFFER_HEADER

#include <xtl/uninitialized_storage.h>
#include <xtl/string.h>

namespace xtl
{

template <class T, class Allocator=typename stl::default_allocator<T>::allocator_type>
class basic_string_buffer: private uninitialized_storage<T, Allocator>
{
  typedef uninitialized_storage<T, Allocator> base;
  public:
    typedef typename base::value_type      value_type;
    typedef typename base::allocator_type  allocator_type;
    typedef typename base::pointer         pointer;
    typedef typename base::const_pointer   const_pointer;
    typedef typename base::size_type       size_type;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    basic_string_buffer () {}
    basic_string_buffer (const allocator_type&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Аллокатор
///////////////////////////////////////////////////////////////////////////////////////////////////
    allocator_type get_allocator () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Размер буфера / объём буфера (количество доступной памяти)
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_type size     () const;
    size_type capacity () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool empty () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Данные
///////////////////////////////////////////////////////////////////////////////////////////////////
    const_pointer data  () const;
          pointer data  ();
    const_pointer c_str () const { return data (); }
          pointer c_str ()       { return data (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Изменение размера буфера / резервирование памяти
///////////////////////////////////////////////////////////////////////////////////////////////////
    void resize  (size_type new_size, bool need_copy = true);
    void reserve (size_type new_size, bool need_copy = true);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void clear ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление строки
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_type append         (const_pointer string);
    size_type append         (const_pointer string, size_type length);
    size_type append_format  (const_pointer format, ...);
    size_type append_vformat (const_pointer format, va_list args);

    basic_string_buffer& operator += (const_pointer string);
    basic_string_buffer  operator +  (const_pointer string) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void swap (basic_string_buffer&);
    
  private:
    void terminate_string ();
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, class Allocator>
void swap (basic_string_buffer<T, Allocator>&, basic_string_buffer<T, Allocator>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Псевдонимы
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef basic_string_buffer<char> string_buffer;

#include <xtl/detail/string_buffer.inl>

}

#endif
