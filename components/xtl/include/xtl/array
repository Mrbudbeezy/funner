/*
    XTL fixed-size array
*/

#ifndef XTL_ARRAY_HEADER
#define XTL_ARRAY_HEADER

#include <stl/stdexcept>
#include <stl/reverse_iterator.h>
#include <stl/algorithm>

namespace xtl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///STL-like массив фиксированного размера
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, size_t N>
class array
{
  public:
    T elems [N]; // массив фиксированного размера из N элементов

  public:
    typedef T                                     value_type;
    typedef T*                                    iterator;
    typedef const T*                              const_iterator;
    typedef T&                                    reference;
    typedef const T&                              const_reference;
    typedef size_t                                size_type;
    typedef ptrdiff_t                             difference_type;
    typedef stl::reverse_iterator<iterator>       reverse_iterator;
    typedef stl::reverse_iterator<const_iterator> const_reverse_iterator;

    enum { static_size = N };

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание c преобразованием типа
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T2> array& operator = (const array<T2, N>& rhs);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание одного значения для всех элементов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void assign (const value_type& value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Прямой доступ к данным (только чтение)
///////////////////////////////////////////////////////////////////////////////////////////////////
    const value_type* data () const;
          value_type* data ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Использование как С массива (чтение/запись)
///////////////////////////////////////////////////////////////////////////////////////////////////
    value_type* c_array (); //???

///////////////////////////////////////////////////////////////////////////////////////////////////
///Информация о размере
///////////////////////////////////////////////////////////////////////////////////////////////////
    static size_type size     (); //размер массива
    static size_type max_size (); //максимальный размер массива (для совместимости с stl::vector)
    static bool      empty    (); //проверка на пустоту

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поддержка итераторов
///////////////////////////////////////////////////////////////////////////////////////////////////
    iterator       begin ();
    const_iterator begin () const;
    iterator       end   ();
    const_iterator end   () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поддержка реверсных итераторов
///////////////////////////////////////////////////////////////////////////////////////////////////
    reverse_iterator       rbegin ();
    reverse_iterator       rend   ();
    const_reverse_iterator rbegin () const;
    const_reverse_iterator rend   () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к элементу (operator[])
///////////////////////////////////////////////////////////////////////////////////////////////////
    reference       operator [] (size_type i);
    const_reference operator [] (size_type i) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к элементу с проверкой диапазона (at())
///////////////////////////////////////////////////////////////////////////////////////////////////
    reference       at (size_type i);
    const_reference at (size_type i) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к первому (front) и последнему (back) элементам
///////////////////////////////////////////////////////////////////////////////////////////////////
    reference front ();
    reference back  ();

    const_reference front () const;
    const_reference back  () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен (за линейное время)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void swap (array&);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка диапазона
///////////////////////////////////////////////////////////////////////////////////////////////////
    void rangecheck (size_type);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Специализация массива фиксированной длины для N=0
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> class array<T, 0>
{
  public:
    typedef T                                     value_type;
    typedef T*                                    iterator;
    typedef const T*                              const_iterator;
    typedef T&                                    reference;
    typedef const T&                              const_reference;
    typedef size_t                                size_type;
    typedef ptrdiff_t                             difference_type;
    typedef stl::reverse_iterator<iterator>       reverse_iterator;
    typedef stl::reverse_iterator<const_iterator> const_reverse_iterator;    

    enum { static_size = 0 };
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание c преобразованием типа
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T2> array& operator = (const array<T2,0>& rhs);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание одного значения для всех элементов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void assign (const value_type& value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Прямой доступ к данным (только чтение)
///////////////////////////////////////////////////////////////////////////////////////////////////
    const value_type* data () const;
          value_type* data ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Использование как С массива (чтение/запись)
///////////////////////////////////////////////////////////////////////////////////////////////////
    value_type* c_array (); //???

///////////////////////////////////////////////////////////////////////////////////////////////////
///Информация о размере
///////////////////////////////////////////////////////////////////////////////////////////////////
    static size_type size     ();
    static size_type max_size ();
    static bool      empty    ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поддержка итераторов
///////////////////////////////////////////////////////////////////////////////////////////////////
    iterator       begin ();
    const_iterator begin () const;
    iterator       end   ();
    const_iterator end   () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поддержка реверсных итераторов
///////////////////////////////////////////////////////////////////////////////////////////////////
    reverse_iterator       rbegin ();
    reverse_iterator       rend   ();
    const_reverse_iterator rbegin () const;
    const_reverse_iterator rend   () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к элементу (operator[])
///////////////////////////////////////////////////////////////////////////////////////////////////
    reference       operator [] (size_type i);
    const_reference operator [] (size_type i) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к элементу с проверкой диапазона (at())
///////////////////////////////////////////////////////////////////////////////////////////////////
    reference       at (size_type i);
    const_reference at (size_type i) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к первому (front) и последнему (back) элементам
///////////////////////////////////////////////////////////////////////////////////////////////////
    reference       front ();
    reference       back  ();
    const_reference front () const;
    const_reference back  () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен (за линейное время)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void swap (array&);    

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка диапазона
///////////////////////////////////////////////////////////////////////////////////////////////////
    static reference failed_rangecheck ();
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сравнение
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, size_t N> bool operator == (const array<T, N>& x, const array<T, N>& y);
template <class T, size_t N> bool operator <  (const array<T, N>& x, const array<T, N>& y);
template <class T, size_t N> bool operator != (const array<T, N>& x, const array<T, N>& y);
template <class T, size_t N> bool operator >  (const array<T, N>& x, const array<T, N>& y);
template <class T, size_t N> bool operator <= (const array<T, N>& x, const array<T, N>& y);
template <class T, size_t N> bool operator >= (const array<T, N>& x, const array<T, N>& y);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, size_t N>
void swap (array<T, N>& x, array<T, N>& y);

#include <xtl/detail/array.inl>

}

namespace tr1
{

using xtl::array;

}

#endif
