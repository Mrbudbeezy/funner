#ifndef XTL_ARRAY_HEADER
#define XTL_ARRAY_HEADER

#include <exception>
#include <stl/reverse_iterator.h>
#include <stl/algorithm>
#include <xtl/utility>

namespace xtl
{

template <class T, size_t N>
class array
{
  public:
    T elems [N];    // массив фиксированного размера из N элементов

  public:

    typedef T         value_type;
    typedef T*        iterator;
    typedef const T*  const_iterator;
    typedef T&        reference;
    typedef const T&  const_reference;
    typedef size_t    size_type;
    typedef ptrdiff_t difference_type;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поддержка итераторов
///////////////////////////////////////////////////////////////////////////////////////////////////
    iterator       begin ();
    const_iterator begin () const;
    iterator       end   ();
    const_iterator end   () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поддержка реверсных итераторов
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef stl::reverse_iterator<iterator> reverse_iterator;
    typedef stl::reverse_iterator<const_iterator> const_reverse_iterator;

    reverse_iterator rbegin ();
    reverse_iterator rend   ();

    const_reverse_iterator rbegin () const;
    const_reverse_iterator rend   () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к элементу (operator[])
///////////////////////////////////////////////////////////////////////////////////////////////////
    reference       operator[] (size_type i);
    const_reference operator[] (size_type i) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к элементу с проверкой диапазона (at())
///////////////////////////////////////////////////////////////////////////////////////////////////
    reference       at (size_type i);
    const_reference at (size_type i) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к первому (front) и последнему (back) элементам
///////////////////////////////////////////////////////////////////////////////////////////////////
    reference front ();
    reference back  ();

    const_reference front () const;
    const_reference back  () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Информация о размере
///////////////////////////////////////////////////////////////////////////////////////////////////
    static size_type size ();

    static bool empty ();

    static size_type max_size ();

    enum { static_size = N };

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен (за линейное время)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void swap (array<T,N>& y);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Прямой доступ к данным (только чтение)
///////////////////////////////////////////////////////////////////////////////////////////////////
    const T* data () const;
          T* data ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Использование как С массива (чтение/запись)
///////////////////////////////////////////////////////////////////////////////////////////////////
    T* c_array ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание c преобразованием типа
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T2>
    array<T,N>& operator= (const array<T2,N>& rhs);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание одного значения для всех элементов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void assign (const T& value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка диапазона
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void rangecheck (size_type i);
};

template <class T>
class array <T, 0>
{
  public:

    typedef T         value_type;
    typedef T*        iterator;
    typedef const T*  const_iterator;
    typedef T&        reference;
    typedef const T&  const_reference;
    typedef size_t    size_type;
    typedef ptrdiff_t difference_type;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поддержка итераторов
///////////////////////////////////////////////////////////////////////////////////////////////////
    iterator       begin ();
    const_iterator begin () const;
    iterator       end   ();
    const_iterator end   () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поддержка реверсных итераторов
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef stl::reverse_iterator<iterator> reverse_iterator;
    typedef stl::reverse_iterator<const_iterator> const_reverse_iterator;

    reverse_iterator rbegin ();
    reverse_iterator rend   ();

    const_reverse_iterator rbegin () const;
    const_reverse_iterator rend   () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к элементу (operator[])
///////////////////////////////////////////////////////////////////////////////////////////////////
    reference       operator[] (size_type i);
    const_reference operator[] (size_type i) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к элементу с проверкой диапазона (at())
///////////////////////////////////////////////////////////////////////////////////////////////////
    reference       at (size_type i);
    const_reference at (size_type i) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к первому (front) и последнему (back) элементам
///////////////////////////////////////////////////////////////////////////////////////////////////
    reference front ();
    reference back  ();

    const_reference front () const;
    const_reference back  () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Информация о размере
///////////////////////////////////////////////////////////////////////////////////////////////////
    static size_type size ();

    static bool empty ();

    static size_type max_size ();

    enum { static_size = 0 };

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен (за линейное время)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void swap (array<T,0>& y);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Прямой доступ к данным (только чтение)
///////////////////////////////////////////////////////////////////////////////////////////////////
    const T* data () const;
          T* data ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Использование как С массива (чтение/запись)
///////////////////////////////////////////////////////////////////////////////////////////////////
    T* c_array ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание c преобразованием типа
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T2>
    array<T,0>& operator= (const array<T2,0>& rhs);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание одного значения для всех элементов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void assign (const T& value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка диапазона
///////////////////////////////////////////////////////////////////////////////////////////////////
  static reference failed_rangecheck ();
};

#include <xtl/detail/array.inl>

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сравнение
///////////////////////////////////////////////////////////////////////////////////////////////////
template<class T, size_t N>
bool operator== (const array<T,N>& x, const array<T,N>& y);

template<class T, size_t N>
bool operator< (const array<T,N>& x, const array<T,N>& y);

template<class T, size_t N>
bool operator!= (const array<T,N>& x, const array<T,N>& y);

template<class T, size_t N>
bool operator> (const array<T,N>& x, const array<T,N>& y);

template<class T, size_t N>
bool operator<= (const array<T,N>& x, const array<T,N>& y);

template<class T, size_t N>
bool operator>= (const array<T,N>& x, const array<T,N>& y);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен (глобальный)
///////////////////////////////////////////////////////////////////////////////////////////////////
template<class T, size_t N>
void swap (array<T,N>& x, array<T,N>& y);

}

#endif
