#ifndef XTL_UNINITIALIZED_BUFFER_HEADER
#define XTL_UNINITIALIZED_BUFFER_HEADER

#include <stl/alloc.h>
#include <cstring>

namespace xtl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обёртка для хранения неинициализированных данных
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, class Allocator=typename stl::default_allocator<T>::allocator_type>
class uninitialized_storage: private Allocator
{
  public:
    typedef T                                      value_type;
    typedef Allocator                              allocator_type;
    typedef typename allocator_type::pointer       pointer;
    typedef typename allocator_type::const_pointer const_pointer;    
    typedef typename allocator_type::size_type     size_type;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////  
    uninitialized_storage  (const allocator_type& = allocator_type::create ());
    uninitialized_storage  (size_type size, const allocator_type& = allocator_type::create ());
    uninitialized_storage  (const uninitialized_storage&);
    ~uninitialized_storage ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    uninitialized_storage& operator = (const uninitialized_storage&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Аллокатор
///////////////////////////////////////////////////////////////////////////////////////////////////
    allocator_type get_allocator () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Размер буфера / объём буфера (количество доступной памяти)  (в элементах)
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_type size     () const;
    size_type capacity () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool empty () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Данные
///////////////////////////////////////////////////////////////////////////////////////////////////
    const_pointer data () const;
          pointer data ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Изменение размера буфера / резервирование памяти (в элементах)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void resize  (size_type new_size, bool need_copy = true);
    void reserve (size_type new_size, bool need_copy = true);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void swap (uninitialized_storage&);
  
  private:
    pointer start, finish, end_of_storage;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, class Allocator>
void swap (uninitialized_storage<T, Allocator>&, uninitialized_storage<T, Allocator>&);

#include <xtl/detail/uninitialized_storage.inl>

}

#endif
