#ifndef DESIGN_SIGNAL_HEADER
#define DESIGN_SIGNAL_HEADER

#include <design/functraits.h>
#include <design/refcount.h>
#include <design/linked_ptr.h>
#include <design/intrusive_ptr.h>
#include <design/tuple.h>
#include <design/utility.h>
#include <new>

namespace design
{

namespace detail
{

//implementation forwards
class connection_impl;
template <class Signature> struct signal_invoker;

}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Аккумулятор по умолчанию - оператор ','
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Result> struct default_signal_accumulator
{
  template <class T> Result operator () (const Result& result,const T& value) const
  {
    return result, value;
  }
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Аккумулятор результата распространения сигнала
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Result,class Fn=default_signal_accumulator<Result> >
class signal_accumulator
{
  public:
    typedef Result result_type;

    template <class T> signal_accumulator (const T& init_value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Аккумулирование нового значения
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> void operator () (const T& value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение результата
///////////////////////////////////////////////////////////////////////////////////////////////////        
    result_type operator () () const { return result; }

  private:
    result_type result;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Класс характеризующий состояние соединения
///////////////////////////////////////////////////////////////////////////////////////////////////
class connection
{
  template <class Signature,class Accumulator> friend class signal;
  public:
    connection  ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка факта наличия соединения
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool connected () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Досрочное завершение соединения
///////////////////////////////////////////////////////////////////////////////////////////////////
    void disconnect ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Блокирование соединения
///////////////////////////////////////////////////////////////////////////////////////////////////
    void block   ();
    void unblock ();
    bool blocked () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сравнение соединений
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool operator == (const connection&) const;
    bool operator != (const connection&) const;
    
  private:
    connection (detail::connection_impl&);

  private:  
    intrusive_ptr<detail::connection_impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Соединение автоматически разрывающееся после входа из блока
///////////////////////////////////////////////////////////////////////////////////////////////////
class scoped_connection: public connection //auto_connection!!!
{
  public:
    ~scoped_connection () { disconnect (); }
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сигнал
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Signature,class Accumulator=signal_accumulator <typename type_manip::function_traits<Signature>::result_type> >
class signal: public type_manip::function_traits<Signature>
{
  private:
    struct dummy { void nonnull () {} };

    typedef void (dummy::*safe_bool)();

  public:
    typedef Signature                                        signature_type;
    typedef Accumulator                                      accumulator_type;
    typedef typename type_manip::function_traits<Signature>  traits_type;
    typedef typename traits_type::result_type                result_type;
    typedef typename traits_type::argument<1>::type          arg1_type;
    typedef typename traits_type::argument<2>::type          arg2_type;
    typedef typename traits_type::argument<3>::type          arg3_type;
    typedef typename traits_type::argument<4>::type          arg4_type;
    typedef typename traits_type::argument<5>::type          arg5_type;
    typedef typename traits_type::argument<6>::type          arg6_type;
    typedef typename traits_type::argument<7>::type          arg7_type;
    typedef typename traits_type::argument<8>::type          arg8_type;
    typedef typename traits_type::argument<9>::type          arg9_type;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    signal  ();
    signal  (const signal&);
    ~signal ();

    template <class Accumulator1> signal (const signal<Signature,Accumulator1>&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    signal& operator = (const signal&);
    
    template <class Accumulator1> signal& operator = (const signal<Signature,Accumulator1>&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool empty () const;

    operator safe_bool () const { return empty () ? 0 : &dummy::nonnull; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Соединение / отсоединение обработчиков сигнала
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class Fn>               connection connect    (Fn);
    template <class Ptr,class MemFun> connection connect    (const Ptr&,MemFun);
    template <class Fn>               void       disconnect (Fn);
    template <class Ptr,class MemFun> void       disconnect (const Ptr&,MemFun);

    void disconnect_all (); //или clear!!!

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вызов
///////////////////////////////////////////////////////////////////////////////////////////////////
    result_type operator () () const;
    result_type operator () (arg1_type) const;
    result_type operator () (arg1_type,arg2_type) const;
    result_type operator () (arg1_type,arg2_type,arg3_type) const;
    result_type operator () (arg1_type,arg2_type,arg3_type,arg4_type) const;
    result_type operator () (arg1_type,arg2_type,arg3_type,arg4_type,arg5_type) const;
    result_type operator () (arg1_type,arg2_type,arg3_type,arg4_type,arg5_type,arg6_type) const;
    result_type operator () (arg1_type,arg2_type,arg3_type,arg4_type,arg5_type,arg6_type,arg7_type) const;
    result_type operator () (arg1_type,arg2_type,arg3_type,arg4_type,arg5_type,arg6_type,arg7_type,arg8_type) const;
    result_type operator () (arg1_type,arg2_type,arg3_type,arg4_type,arg5_type,arg6_type,arg7_type,arg8_type,arg9_type) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class Accumulator1> void swap (signal<Signature,Accumulator1>&);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип обработчика сигнала и указатель на него
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef detail::signal_invoker<Signature> invoker_type;
    typedef linked_ptr<invoker_type*>         invoker_pointer;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с соединением / распространение сигнала
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class Fn>    invoker_type* connect_internal    (const Fn&);
    template <class Fn>    void          disconnect_internal (const Fn&);
    template <class Tuple> result_type   invoke              (const Tuple&) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Копирование обработчиков
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class Accumulator1> void clone (const signal<Signature,Accumulator1>&);

  private:
    invoker_pointer first;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Signature,class Accumulator1,class Accumulator2>
void swap (signal<Signature,Accumulator1>&,signal<Signature,Accumulator2>&);

#ifndef DESIGN_INVOKER_HEADER
#define DESIGN_INVOKER_HEADER
  #include <design/impl/invoker.inl>
#endif

#include <design/impl/signal.inl>

}

#endif
