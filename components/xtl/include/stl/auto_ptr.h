/*
    MySTL auto_ptr
*/

#ifndef MYSTL_AUTO_PTR_HEADER
#define MYSTL_AUTO_PTR_HEADER

#include <cstddef>

#include <stl/config.h>

namespace stl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Структура необходимая для реализации auto_ptr
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> 
struct auto_ptr_ref
{
  auto_ptr_ref (T* p);

  T* ptr;  
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Объект-указатель, предназначенный для борьбы с "утечками" памяти
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
class auto_ptr
{
  typedef T* auto_ptr::* unspecified_bool_type;
  public:
    typedef T element_type;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    explicit auto_ptr  (element_type* = 0) throw ();
             auto_ptr  (auto_ptr&) throw ();
             auto_ptr  (auto_ptr_ref<T>) throw ();
             ~auto_ptr ();
             
    template <class T1> auto_ptr (auto_ptr<T1>&) throw ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    auto_ptr& operator = (auto_ptr&) throw ();
    auto_ptr& operator = (auto_ptr_ref<T>) throw ();
    
    template <class T1> auto_ptr& operator = (auto_ptr<T1>&) throw ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Преобразование к совместимым auto_ptr<T>
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T1> operator auto_ptr_ref<T1> () throw ();
    template <class T1> operator auto_ptr<T1> () throw ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Операции доступа к объекту
///////////////////////////////////////////////////////////////////////////////////////////////////
    element_type& operator *  () const throw ();
    element_type* operator -> () const throw ();
    element_type* get         () const throw ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка на 0
///////////////////////////////////////////////////////////////////////////////////////////////////
    operator unspecified_bool_type () const throw () { return ptr ? &auto_ptr::ptr : 0; } //неявное приведение типа для проверки if (p)
    bool     operator !            () const throw ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отказ от владения (объект не удаляется)
///////////////////////////////////////////////////////////////////////////////////////////////////
    element_type* release () throw ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Смена владеемого объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    void reset (element_type* = 0) throw ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void swap (auto_ptr&);

  private:
    T* ptr;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
void swap (auto_ptr<T>&, auto_ptr<T>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Взятие значения указателя (нестандартная функция)
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> T* get_pointer (const auto_ptr<T>&);

#include <stl/detail/auto_ptr.inl>

}

#endif
