/*
    MySTL iterator   
*/

#ifndef __MYSTL_ITERATOR__
#define __MYSTL_ITERATOR__

#include <cstddef>

namespace stl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Категории итераторов
///////////////////////////////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag: public input_iterator_tag {};
struct bidirectional_iterator_tag: public forward_iterator_tag {};
struct random_access_iterator_tag: public bidirectional_iterator_tag {};

//тэги "ложных" итераторов
struct int_iterator_tag {};
struct float_iterator_tag {};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Таблица конфигурации итераторов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Iterator>
struct iterator_traits 
{
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type        value_type;
  typedef typename Iterator::difference_type   difference_type;
  typedef typename Iterator::pointer           pointer;
  typedef typename Iterator::reference         reference;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Специализации конфигураций итераторов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T,class Category> 
struct iterator_traits_base
{
  typedef Category  iterator_category;
  typedef T         value_type;
  typedef ptrdiff_t difference_type;
  typedef T*        pointer;
  typedef T&        reference;
};

template <class T>
struct iterator_traits<T*> 
{
  typedef random_access_iterator_tag iterator_category;
  typedef T                          value_type;
  typedef ptrdiff_t                  difference_type;
  typedef T*                         pointer;
  typedef T&                         reference;
};

template <class T>
struct iterator_traits<const T*> 
{
  typedef random_access_iterator_tag iterator_category;
  typedef T                          value_type;
  typedef ptrdiff_t                  difference_type;
  typedef const T*                   pointer;
  typedef const T&                   reference;
};

template <> struct iterator_traits<bool>:           public iterator_traits_base<bool,int_iterator_tag> {};
template <> struct iterator_traits<char>:           public iterator_traits_base<char,int_iterator_tag> {};
template <> struct iterator_traits<signed char>:    public iterator_traits_base<signed char,int_iterator_tag> {};
template <> struct iterator_traits<unsigned char>:  public iterator_traits_base<unsigned char,int_iterator_tag> {};
template <> struct iterator_traits<short>:          public iterator_traits_base<short,int_iterator_tag> {};
template <> struct iterator_traits<unsigned short>: public iterator_traits_base<unsigned short,int_iterator_tag> {};
template <> struct iterator_traits<int>:            public iterator_traits_base<int,int_iterator_tag> {};
template <> struct iterator_traits<unsigned int>:   public iterator_traits_base<unsigned int,int_iterator_tag> {};
template <> struct iterator_traits<long>:           public iterator_traits_base<long,int_iterator_tag> {};
template <> struct iterator_traits<unsigned long>:  public iterator_traits_base<unsigned long,int_iterator_tag> {};
template <> struct iterator_traits<float>:          public iterator_traits_base<float,float_iterator_tag> {};
template <> struct iterator_traits<double>:         public iterator_traits_base<double,float_iterator_tag> {};
template <> struct iterator_traits<long double>:    public iterator_traits_base<long double,float_iterator_tag> {};

#ifndef NO_WCHAR
template <> struct iterator_traits<wchar_t>:        public iterator_traits_base<wchar_t,int_iterator_tag> {};
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание итератора
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Category,class T,class Distance=ptrdiff_t,class Pointer=T*,class Reference=T&>
struct iterator 
{
  typedef Category  iterator_category;
  typedef T         value_type;
  typedef Distance  difference_type;
  typedef Pointer   pointer;
  typedef Reference reference;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Итератор обратного перебора
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Iterator>
class reverse_iterator 
{
  public:
    typedef typename iterator_traits<Iterator>::value_type        value_type;
    typedef typename iterator_traits<Iterator>::difference_type   difference_type;
    typedef typename iterator_traits<Iterator>::pointer           pointer;
    typedef typename iterator_traits<Iterator>::reference         reference;
    typedef typename iterator_traits<Iterator>::iterator_category iterator_category;
    typedef Iterator                                              iterator_type;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
             reverse_iterator () {}    
    explicit reverse_iterator (iterator_type);
             reverse_iterator (const reverse_iterator&);
             
    template <class Iter> reverse_iterator (const reverse_iterator<Iter>&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Переход к базовому итератору
///////////////////////////////////////////////////////////////////////////////////////////////////
    iterator_type base () const { return current; }
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Операции доступа и индексирования
///////////////////////////////////////////////////////////////////////////////////////////////////
    reference operator *  () const;  
    reference operator [] (difference_type i) const;
    pointer   operator -> () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Арифметические операции
///////////////////////////////////////////////////////////////////////////////////////////////////
    reverse_iterator&      operator ++ ();
    reverse_iterator&      operator -- ();
    reverse_iterator&      operator += (difference_type);
    reverse_iterator&      operator -= (difference_type);                  
    const reverse_iterator operator ++ (int);  
    const reverse_iterator operator -- (int);    
    const reverse_iterator operator +  (difference_type) const;
    const reverse_iterator operator -  (difference_type) const;  
    difference_type        operator -  (const reverse_iterator&) const;    
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сравнение двух итераторов обратного перебора
///////////////////////////////////////////////////////////////////////////////////////////////////                  
    bool operator == (const reverse_iterator&) const;
    bool operator != (const reverse_iterator&) const;
    bool operator >= (const reverse_iterator&) const;
    bool operator <= (const reverse_iterator&) const;
    bool operator >  (const reverse_iterator&) const;
    bool operator <  (const reverse_iterator&) const;

  private:
    Iterator current;
};

template <class Iter> 
reverse_iterator<Iter> operator + (typename reverse_iterator<Iter>::difference_type n,const reverse_iterator<Iter>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Итератор вставки в хвост контейнера
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Container>
class back_insert_iterator 
{
  public:
    typedef Container           container_type;
    typedef output_iterator_tag iterator_category;
    typedef void                value_type;
    typedef void                difference_type;
    typedef void                pointer;
    typedef void                reference;

    explicit back_insert_iterator (container_type&);

    back_insert_iterator& operator = (const typename container_type::value_type&);

    back_insert_iterator& operator  * ()    { return *this; }
    back_insert_iterator& operator ++ ()    { return *this; }
    back_insert_iterator& operator ++ (int) { return *this; }

  protected:
    container_type* container;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Итератор вставки в начало контейнера
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Container>
class front_insert_iterator 
{
  public:
    typedef Container           container_type;
    typedef output_iterator_tag iterator_category;
    typedef void                value_type;
    typedef void                difference_type;
    typedef void                pointer;
    typedef void                reference;

    explicit front_insert_iterator (container_type&);

    front_insert_iterator& operator = (const typename container_type::value_type&);

    front_insert_iterator& operator  * ()    { return *this; }
    front_insert_iterator& operator ++ ()    { return *this; }
    front_insert_iterator& operator ++ (int) { return *this; }

  protected:
    container_type* container;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Итератор вставки в произвольную позицию контейнера
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Container>
class insert_iterator 
{
  public:
    typedef Container           container_type;
    typedef output_iterator_tag iterator_category;
    typedef void                value_type;
    typedef void                difference_type;
    typedef void                pointer;
    typedef void                reference;

    explicit insert_iterator (container_type&,typename container_type::iterator pos);

    insert_iterator& operator = (const typename container_type::value_type&);

    insert_iterator& operator  * ()    { return *this; }
    insert_iterator& operator ++ ()    { return *this; }
    insert_iterator& operator ++ (int) { return *this; }

  protected:
    container_type* container;
    typename container_type::iterator pos;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Операции над итераторами
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Iter> 
typename iterator_traits<Iter>::difference_type distance (Iter first,Iter last);

template <class Iter,class Distance> void distance (Iter first,Iter last,Distance& n);
template <class Iter,class Distance> void advance  (Iter&,Distance n); 

///////////////////////////////////////////////////////////////////////////////////////////////////
///Категория итератора
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Iter> 
typename iterator_traits<Iter>::iterator_category iterator_category ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение итераторов вставки
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Container> 
back_insert_iterator<Container> back_inserter (Container&);

template <class Container> 
front_insert_iterator<Container> front_inserter (Container&);

template <class Container,class Iter> 
insert_iterator<Container> inserter (Container&,Iter pos);

#include <stl/detail/stl/iterator.inl>

}

#endif
