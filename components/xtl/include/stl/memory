/*
    MySTL memory managment              
*/

#ifndef __MYSTL_MEMORY__
#define __MYSTL_MEMORY__

#include <stl/alloc.h>
#include <stl/tempbuf.h>
#include <stl/iterator>

namespace stl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Структура необходимая для реализации auto_ptr
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> 
struct auto_ptr_ref
{
  auto_ptr_ref (T* p);
  
  T* ptr;  
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Объект-указатель, предназначенный для борьбы с "утечками" памяти
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
class auto_ptr
{
  public:
    typedef T element_type;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    explicit auto_ptr  (element_type* = NULL) throw ();
             auto_ptr  (auto_ptr&) throw ();
             auto_ptr  (auto_ptr_ref<T>) throw ();
             ~auto_ptr ();
             
    template <class T1> auto_ptr (auto_ptr<T1>&) throw ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    auto_ptr& operator = (auto_ptr&) throw ();
    auto_ptr& operator = (auto_ptr_ref<T>) throw ();
    
    template <class T1> auto_ptr& operator = (auto_ptr<T1>&) throw ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Преобразование к совместимым auto_ptr<T>
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T1> operator auto_ptr_ref<T1> () throw ();
    template <class T1> operator auto_ptr<T1> () throw ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Операции доступа к объекту
///////////////////////////////////////////////////////////////////////////////////////////////////
    element_type& operator *  () const throw ();
    element_type* operator -> () const throw ();
    element_type* get         () const throw ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отказ от владения (объект не удаляется)
///////////////////////////////////////////////////////////////////////////////////////////////////
    element_type* release () throw ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Смена владеемого объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    void reset (element_type* = NULL) throw ();

  private:
    T* ptr;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Взятие значения указателя (нестандартная функция)
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> T* get_pointer (const auto_ptr<T>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Итератор конструирования в неинициализированной области памяти
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class ForwardIterator,class T=typename iterator_traits<ForwardIterator>::value_type>
class raw_storage_iterator
{
  public:
    typedef output_iterator_tag iterator_category;
    typedef void                value_type;
    typedef void                difference_type;
    typedef void                pointer;
    typedef void                reference;  

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор и присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    explicit raw_storage_iterator (ForwardIterator);

    raw_storage_iterator& operator = (const T&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Итерации
///////////////////////////////////////////////////////////////////////////////////////////////////
    raw_storage_iterator& operator ++ ();
    raw_storage_iterator  operator ++ (int);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Операции доступа
///////////////////////////////////////////////////////////////////////////////////////////////////
    raw_storage_iterator& operator * ();
  
  private:
    ForwardIterator iter;
};

#include <stl/detail/stl/memory.inl>

}

#endif
