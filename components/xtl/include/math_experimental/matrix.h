#ifndef MATHLIB_MATRIX_HEADER
#define MATHLIB_MATRIX_HEADER
#include <math_experimental/forward.h>
#include "functional.h"
#include <stddef.h>


#ifdef _MSC_VER  
  #pragma pack(push,1)
#endif

#ifdef minor
#undef minor
#endif




namespace math
{

//forward declaration
template <class Type> class quat;
template <class Type, size_t Size> class vec;



/////////////////////////////////////////////////////////////////////////////////////////////
///Матрица
/////////////////////////////////////////////////////////////////////////////////////////////
template <class Type, size_t SizeX, size_t SizeY/*=SizeX*/>
class matrix
{
  public:
    typedef vec<Type, SizeY>              vector;     //вектор строка
    typedef typename vector::value_type value_type; //тип элементов
    
    enum { size_y = SizeY, 
           size_x = SizeX,  
           size   = SizeX };

////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
////////////////////////////////////////////////////////////////////////////////////////////
    matrix ();
    matrix (const matrix& src);
    matrix (const Type& a);  //a будет записано на главной диагонали
    matrix (const Type* a);                                            
    
    template <class T1, class T2,  class Fn>
      matrix(const T1& a, const T2& b, Fn fn);

    template <class T1,  class Fn>
      matrix(const T1& src, Fn fn);


      //для использования оптимизации возвращаемого значения
//    template <class T1>           matrix (const T1&, void (*eval)(matrix&, const T1&));

////////////////////////////////////////////////////////////////////////////////////////////
///Индексирование
////////////////////////////////////////////////////////////////////////////////////////////
  const vec<Type, SizeX>  column  (size_t j) const;

        vector& operator [] (size_t index)       { return x [index]; }
  const vector& operator [] (size_t index) const { return x [index]; }

////////////////////////////////////////////////////////////////////////////////////////////
///Унарные операции
////////////////////////////////////////////////////////////////////////////////////////////
  const matrix   operator -  () const;

////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
////////////////////////////////////////////////////////////////////////////////////////////
    matrix&  operator = (const Type& src);
    matrix&  operator = (const matrix& src);

////////////////////////////////////////////////////////////////////////////////////////////
///Основные арифметические операции
////////////////////////////////////////////////////////////////////////////////////////////
    matrix&      operator += (const matrix& a);
    matrix&      operator -= (const matrix& a);
    matrix&      operator *= (const Type& a);
    matrix&      operator /= (const Type& a);

    const matrix operator *  (const Type& a) const;
    const matrix operator /  (const Type& a) const; 


///////////////////////////////////////////////////////////////////////////////////////////

    const matrix operator +  (const matrix& m) const;
    const matrix operator -  (const matrix& m) const;

///////////////////////////////////////////////

    template<size_t Size2Y>  
     const matrix<Type, SizeX, Size2Y> operator *  (const matrix<Type, SizeY, Size2Y>& b) const;



//////////////////////////////////////////////////////////////////////////////////////////

    friend const matrix operator * (const Type& a, const matrix& m) { return m*a; }

////////////////////////////////////////////////////////////////////////////////////////////
///Отношения между матрицами
////////////////////////////////////////////////////////////////////////////////////////////
    bool operator == (const matrix& v) const;
    bool operator != (const matrix& v) const;             


////////////////////////////////////////////////////////////////////////////////////////////
///Удаление строки/столбца
////////////////////////////////////////////////////////////////////////////////////////////
  
   const matrix<Type, SizeX-1, SizeY>   remove_row        (size_t row)                const; 
   const matrix<Type, SizeX, SizeY-1>   remove_column     (size_t column)             const;
   const matrix<Type, SizeX-1, SizeY-1> remove_row_column (size_t row, size_t column) const;

////////////////////////////////////////////////////////////////////////////////////////////
///Транспонирование матрицы
////////////////////////////////////////////////////////////////////////////////////////////
   const matrix<Type, SizeY, SizeX>  transpose ();

////////////////////////////////////////////////////////////////////////////////////////////
  private:
    vector x [SizeX];  

};

////////////////////////////////////////////////////////////////////////////////////////////
///Перемножение мартиц
////////////////////////////////////////////////////////////////////////////////////////////

template<class T, size_t Size>
matrix<T, Size, Size>& operator *= (matrix<T, Size, Size>& left, const matrix<T, Size, Size>& right);

////////////////////////////////////////////////////////////////////////////////////////////
///Деление матриц
////////////////////////////////////////////////////////////////////////////////////////////

template<class T, size_t Size>
const matrix<T, Size>& operator /  (const matrix<T, Size>& left, const matrix<T, Size>& right);

template<class T, size_t Size>
matrix<T, Size>&       operator /= (matrix<T, Size>& left, const matrix<T, Size>& right);


////////////////////////////////////////////////////////////////////////////////////////////
///Преобразование матрицы в кватернион
////////////////////////////////////////////////////////////////////////////////////////////

template <class T>
const quat<T> matrix_to_quat (const matrix<T, 3>& m);

template <class T>
const quat<T> matrix_to_quat (const matrix<T, 4>& m);


////////////////////////////////////////////////////////////////////////////////////////////
///Определитель
////////////////////////////////////////////////////////////////////////////////////////////

template<class T, size_t Size>
const T det (const matrix<T, Size, Size>& src);

////////////////////////////////////////////////////////////////////////////////////////////
///Треугольный вид
////////////////////////////////////////////////////////////////////////////////////////////
    
template<class T, size_t Size>
const matrix<T, Size, Size> three_angle_view  (const matrix<T, Size, Size>& src, int& num_of_changes);

////////////////////////////////////////////////////////////////////////////////////////////
///Математическое дополнение
////////////////////////////////////////////////////////////////////////////////////////////

template<class T, size_t Size>
const T mathematical_add (const matrix<T, Size>& src,  size_t row, size_t column);

////////////////////////////////////////////////////////////////////////////////////////////
///Обратная матрица
////////////////////////////////////////////////////////////////////////////////////////////

template<class T, size_t Size>
const matrix<T, Size> invert (const matrix<T, Size>& src);

////////////////////////////////////////////////////////////////////////////////////////////
///Норимнование матрицы
////////////////////////////////////////////////////////////////////////////////////////////

template<class T, size_t Size>
const matrix<T, Size> normalize (const matrix<T, Size>& src);

////////////////////////////////////////////////////////////////////////////////////////////
///Основные типы
////////////////////////////////////////////////////////////////////////////////////////////

typedef matrix<float,2,2>         mat2f;
typedef matrix<float,3,3>         mat3f;
typedef matrix<float,4,4>         mat4f;
typedef matrix<double,2,2>        mat2d;
typedef matrix<double,3,3>        mat3d;
typedef matrix<double,4,4>        mat4d;
typedef matrix<int,2,2>           mat2i;
typedef matrix<int,3,3>           mat3i;
typedef matrix<int,4,4>           mat4i;

#include <math_experimental/impl/matrix.inl>

#ifdef _MSC_VER
  #pragma pack(pop)
#endif

}



#endif
