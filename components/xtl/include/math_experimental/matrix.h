#ifndef __MATHLIB_MATRIX__
#define __MATHLIB_MATRIX__

#ifdef _MSC_VER  
  #pragma pack(push,1)
#endif

#ifdef minor
#undef minor
#endif




namespace math
{

template <class type> class quat;


namespace detail
{
template <class T, size_t SizeX,size_t SizeY> 
  vec<T, SizeY>& get_component (math::matrix<T, SizeX,SizeY>& v, size_t index);

template <class T, size_t SizeX,size_t SizeY> 
  const vec<T, SizeY>& get_component (const math::matrix<T, SizeX,SizeY>& v, size_t index);

}

/////////////////////////////////////////////////////////////////////////////////////////////
///Матрица
/////////////////////////////////////////////////////////////////////////////////////////////
template <class type,size_t sizeX,size_t sizeY=sizeX>
class matrix
{
  public:
    typedef vec<type,sizeY>              vector;     //вектор строка
    typedef typename vector::value_type value_type; //тип элементов
    
    enum { SizeY = sizeY,
           SizeX = sizeX, 
           Size  = sizeX }; //исправить!!

////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
////////////////////////////////////////////////////////////////////////////////////////////
    matrix ();
    matrix (const matrix<type,sizeX,sizeY>& src);
    matrix (const type& a);  //a будет записано на главной диагонали
    matrix (const type*);                                            
    matrix (const quat<type>&);   //только для матриц 3-го и 4-го порядка

    template <class Fn>
      matrix(const matrix<type,sizeX,sizeY>& a,const matrix<type,sizeX,sizeY>& b,Fn fn);

    template <class T1, class Fn>
      matrix(const T1& src,Fn fn);


      //для использования оптимизации возвращаемого значения
      template <class T1>           matrix (const T1&,void (*eval)(matrix&,const T1&));
//    template <class T1,class T2>  matrix (const T1&,const T2&,void (*eval)(matrix&,const T1&,const T2&));

////////////////////////////////////////////////////////////////////////////////////////////
///Индексирование
////////////////////////////////////////////////////////////////////////////////////////////
  const vec<type,sizeX>  column  (size_t j) const;

        vector& operator [] (size_t index)       { return x [index]; }
  const vector& operator [] (size_t index) const { return x [index]; }

////////////////////////////////////////////////////////////////////////////////////////////
///Унарные операции
////////////////////////////////////////////////////////////////////////////////////////////
//const matrix&  operator +  () const;
  const matrix   operator -  () const;

////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
////////////////////////////////////////////////////////////////////////////////////////////
/*  matrix&  operator = (const quat<type>&);  //только для матриц 3-го и 4-го порядка
  matrix&  operator = (const type&);*/

////////////////////////////////////////////////////////////////////////////////////////////
///Основные арифметические операции
////////////////////////////////////////////////////////////////////////////////////////////
    matrix&      operator += (const matrix&);
    matrix&      operator -= (const matrix&);
    matrix&	 operator *= (const type& a);
    matrix&	 operator /= (const type&);

    const matrix operator *  (const type& a) const;
    const matrix operator /  (const type&)   const; 


///////////////////////////////////////////////////////////////////////////////////////////

    const matrix operator +  (const matrix&) const;
    const matrix operator -  (const matrix&) const;

///////////////////////////////////////////////

    template<size_t size2Y>
     const matrix<type,sizeX,size2Y> operator *  (const matrix<type,sizeY,size2Y>&);

    template<class T,size_t size>
     friend matrix<T,size>&          operator *= (matrix<T,size>&,const matrix<T,size>&);

    template<class T,size_t size>
     friend const matrix<T,size>     operator /  (const matrix<T,size>&,const matrix<T,size>&);

    template<class T,size_t size>
     friend matrix<T,size>&	     operator /= (matrix<T,size>&,const matrix<T,size>&);

//////////////////////////////////////////////////////////////////////////////////////////

    friend const matrix operator * (const type& a,const matrix& m) { return m*a; }

////////////////////////////////////////////////////////////////////////////////////////////
///Умножение на вектор (матрица строка - вектор столбец)
////////////////////////////////////////////////////////////////////////////////////////////
/*    const vec<type,size>   operator * (const vec<type,size>&) const;
    const vec<type,size-1> operator * (const vec<type,size-1>&) const;*/

////////////////////////////////////////////////////////////////////////////////////////////
///Отношения между матрицами
////////////////////////////////////////////////////////////////////////////////////////////
  bool operator == (const matrix&) const;
  bool operator != (const matrix&) const;             


////////////////////////////////////////////////////////////////////////////////////////////
///Удаление строки/столбца
////////////////////////////////////////////////////////////////////////////////////////////
  
   const matrix<type,sizeX-1,sizeY> delete_row(size_t) const; 
   const matrix<type,sizeX,sizeY-1> delete_column(size_t) const;
   const matrix<type,sizeX-1,sizeY-1> delete_row_column(size_t,size_t) const;

////////////////////////////////////////////////////////////////////////////////////////////
///Транспонирование / инвертирование / нормализация матрицы
////////////////////////////////////////////////////////////////////////////////////////////
   const matrix<type,sizeY,sizeX>  transpose ();

/*
	Утилиты
*/

    template<class T,size_t size>
     friend const T det(const matrix<T,size,size>&);
    
    template<class T,size_t size>
     friend const matrix<T,size,size> three_angle_view(const matrix<T,size,size>&);

    template<class T,size_t size>
     friend const T mathematical_add(const matrix<T,size>&, size_t,size_t);

    template<class T,size_t size>
     friend const matrix<T,size> invert(const matrix<T,size>&);

    template<class T,size_t size>
     friend const matrix<T,size> normalize(const matrix<T,size>&);

////////////////////////////////////////////////////////////////////////////////////////////
  private:
    vector x [sizeX];  

};

#ifdef _MSC_VER
  #pragma pack(pop)
#endif

////////////////////////////////////////////////////////////////////////////////////////////
///Утилиты
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
///Взятие транспонированнной матрицы 
////////////////////////////////////////////////////////////////////////////////////////////
/*template <class type,size_t size>
matrix<type,size> transpose (const matrix<type,size>&);

////////////////////////////////////////////////////////////////////////////////////////////
///Взятие обратной матрицы
////////////////////////////////////////////////////////////////////////////////////////////
template <class type,size_t size>
matrix<type,size> invert (const matrix<type,size>&);

////////////////////////////////////////////////////////////////////////////////////////////
///Взятие нормированной матрицы
////////////////////////////////////////////////////////////////////////////////////////////
template <class type,size_t size>
matrix<type,size> normalize (const matrix<type,size>&);

////////////////////////////////////////////////////////////////////////////////////////////
///Определитель (для квадратной матрицы)
////////////////////////////////////////////////////////////////////////////////////////////
template <class type,size_t size> 
type det (const matrix<type,size>&);

////////////////////////////////////////////////////////////////////////////////////////////
///Минор
////////////////////////////////////////////////////////////////////////////////////////////
template <class type,size_t size>
type minor (const matrix<type,size>&,size_t,size_t);

////////////////////////////////////////////////////////////////////////////////////////////
///Сравнение матриц
////////////////////////////////////////////////////////////////////////////////////////////
template <class type,size_t size> 
bool equal (const matrix<type,size>&,const matrix<type,size>&,const type& eps);*/
/*namespace detail
{

/////////////////////////////////////////////////////////////////////////////////////////////
///Вспомогательные операции
/////////////////////////////////////////////////////////////////////////////////////////////

template <class T, size_t SizeX,size_t SizeY> math::vec<T, SizeY>& get_component (math::matrix<T, SizeX,SizeY>& v, size_t index);

template <class T, size_t SizeX,size_t SizeY> const math::vec<T, SizeY>& get_component (const math::matrix<T, SizeX,SizeY>& v, size_t index);
} */

}

#endif
