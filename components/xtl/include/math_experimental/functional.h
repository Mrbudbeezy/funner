
namespace math
{
////////////////////////////////////////////////////////////////////////////////////////////////////////
//Определение одноместного функтора
/////////////////////////////////////////////////////////////////////////////////////////////////////////
template <class Arg,class Result=Arg>
struct unary_function 
{
  typedef Arg    argument_type;
  typedef Result result_type;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//Определение двуместного функтора
/////////////////////////////////////////////////////////////////////////////////////////////////////////
template <class Arg1,class Arg2=Arg1,class Result=Arg1> 
struct binary_function 
{
  typedef Arg1   first_argument_type;
  typedef Arg2   second_argument_type;
  typedef Result result_type;
};

/*
    Арифметико-логические операции 
    Расширение: assign_* - операции вида *=, +=, etc 
*/

/////////////////////////////////////////////////////////////////////////////////////////////////////////
///Сложение
/////////////////////////////////////////////////////////////////////////////////////////////////////////
template <class Arg1,class Arg2=Arg1,class Result=Arg1>
struct plus: public binary_function<Arg1,Arg2,Result>
{
  Result operator () (const Arg1&,const Arg2&) const;
};


/////////////////////////////////////////////////////////////////////////////////////////////////////////
///Вычитание
/////////////////////////////////////////////////////////////////////////////////////////////////////////
template <class Arg1,class Arg2=Arg1,class Result=Arg1>
struct minus: public binary_function<Arg1,Arg2,Result>
{
  Result operator () (const Arg1&,const Arg2&) const;
};



/////////////////////////////////////////////////////////////////////////////////////////////////////////
///Умножение
/////////////////////////////////////////////////////////////////////////////////////////////////////////
template <class Arg1,class Arg2=Arg1,class Result=Arg1>
struct multiplies: public binary_function<Arg1,Arg2,Result>
{
  Result operator () (const Arg1&,const Arg2&) const;
};



/////////////////////////////////////////////////////////////////////////////////////////////////////////
///Деление
/////////////////////////////////////////////////////////////////////////////////////////////////////////
template <class Arg1,class Arg2=Arg1,class Result=Arg1>
struct divides: public binary_function<Arg1,Arg2,Result>
{
  Result operator () (const Arg1&,const Arg2&) const;
};


/////////////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
/////////////////////////////////////////////////////////////////////////////////////////////////////////
template <class Arg,class Result>
struct assign: public unary_function<Arg,Result>
{
  Result operator() (const Arg&) const;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////
///Унарный минус
/////////////////////////////////////////////////////////////////////////////////////////////////////////
template <class Arg,class Result=Arg>
struct negate: public unary_function<Arg,Result>
{
  Result operator () (const Arg&) const;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////
///Отношение равенства (==)
/////////////////////////////////////////////////////////////////////////////////////////////////////////
template <class Arg1,class Arg2=Arg1,class Eps=Arg1> 
struct equal_to: public binary_function<Arg1,Arg2,bool> 
{
  bool operator () (const Arg1& a,const Arg2& b,const Eps& eps=Eps(0)) const;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////
///Отношение неравенства (!=)
/////////////////////////////////////////////////////////////////////////////////////////////////////////
template <class Arg1,class Arg2=Arg1,class Eps=Arg1> 
struct not_equal_to: public binary_function<Arg1,Arg2,bool> 
{
  bool operator () (const Arg1& a,const Arg2& b,const Eps& eps=Eps(0)) const;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////
///Отношение "меньше" (<)
/////////////////////////////////////////////////////////////////////////////////////////////////////////
template <class Arg1,class Arg2=Arg1,class Eps=Arg1> 
struct less: public binary_function<Arg1,Arg2,bool> 
{
  bool operator () (const Arg1& a,const Arg2& b,const Eps& eps=Eps(0)) const;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////
///Отношение "больше" (>)
/////////////////////////////////////////////////////////////////////////////////////////////////////////
template <class Arg1,class Arg2=Arg1,class Eps=Arg1> 
struct greater: public binary_function<Arg1,Arg2,bool> 
{
  bool operator () (const Arg1& a,const Arg2& b,const Eps& eps=Eps(0)) const;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////
///Отношение "не больше" (<=)
/////////////////////////////////////////////////////////////////////////////////////////////////////////
template <class Arg1,class Arg2=Arg1,class Eps=Arg1> 
struct less_equal: public binary_function<Arg1,Arg2,bool> 
{
  bool operator () (const Arg1& a,const Arg2& b,const Eps& eps=Eps(0)) const;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////
///Отношение "не меньше" (>=)
/////////////////////////////////////////////////////////////////////////////////////////////////////////
template <class Arg1,class Arg2=Arg1,class Eps=Arg1> 
struct greater_equal: public binary_function<Arg1,Arg2,bool> 
{
  bool operator () (const Arg1& a,const Arg2& b,const Eps& eps=Eps(0)) const;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////
///Модуль значения
/////////////////////////////////////////////////////////////////////////////////////////////////////////
template <class Arg,class Result=Arg>
struct absol: public unary_function<Arg,Result>
{
  Result operator () (const Arg&) const;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////
///Минимум
/////////////////////////////////////////////////////////////////////////////////////////////////////////

template <class Arg1,class Arg2=Arg1,class Result=Arg1>
struct min_fn: public binary_function<Arg1,Arg2,Result>
{
  Result operator () (const Arg1&,const Arg2&) const;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////
///Максимум
/////////////////////////////////////////////////////////////////////////////////////////////////////////

template <class Arg1,class Arg2=Arg1,class Result=Arg1>
struct max_fn: public binary_function<Arg1,Arg2,Result>
{
  Result operator () (const Arg1&,const Arg2&) const;
};

}
