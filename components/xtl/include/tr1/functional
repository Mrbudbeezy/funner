/*
    TR1 functionals
*/

#ifndef MYTR1_FUNCTIONAL_HEADER
#define MYTR1_FUNCTIONAL_HEADER

#include <tr1/tuple>
#include <tr1/funcall.h>

namespace tr1
{

namespace detail
{

//implementation forwards
template <class Ret, class Fn, class T1=null_type, class T2=null_type, class T3=null_type, class T4=null_type,
          class T5=null_type, class T6=null_type, class T7=null_type, class T8=null_type, class T9=null_type>
struct binder;

struct unspecified_result;

}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Определение типа возвращаемого значения функции
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class FunctionCallType> struct result_of;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обёртка над ссылкой
///Отличие от стандарта: класс не наследуется от unary_function/binary_function, не имеет result_type
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> class reference_wrapper
{
  public:
    typedef T type;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    explicit reference_wrapper (T&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Операторы доступа
///////////////////////////////////////////////////////////////////////////////////////////////////
    operator T&  () const;
    T&       get () const;

  private:
    T* ptr;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание reference_wrapper
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> reference_wrapper<T>       ref  (T&);
template <class T> reference_wrapper<const T> cref (const T&);
template <class T> reference_wrapper<T>       ref  (reference_wrapper<T>);
template <class T> reference_wrapper<const T> cref (reference_wrapper<T>);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка reference_wrapper
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> struct remove_reference_wrapper;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подстановщик аргументов функциональных объектов
///////////////////////////////////////////////////////////////////////////////////////////////////
namespace placeholders
{

template <size_t I> struct argument {};

static argument<1> _1;
static argument<2> _2;
static argument<3> _3;
static argument<4> _4;
static argument<5> _5;
static argument<6> _6;
static argument<7> _7;
static argument<8> _8;
static argument<9> _9;

}

namespace
{
  using namespace placeholders;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка свойств типа
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> struct is_placeholder;     //является ли тип подстановщиком аргементов функционального объекта
template <class T> struct is_bind_expression; //является ли тип выражением, полученным после вызова bind

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание bind-выражений
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Ret, class Fn>
detail::binder<Ret, Fn> bind (Fn);

template <class Ret, class Fn, class T1>
detail::binder<Ret, Fn, T1> bind (Fn, T1);

template <class Ret, class Fn, class T1, class T2>
detail::binder<Ret, Fn, T1, T2> bind (Fn, T1, T2);

template <class Ret, class Fn, class T1, class T2, class T3>
detail::binder<Ret, Fn, T1, T2, T3> bind (Fn, T1, T2, T3);

template <class Ret, class Fn, class T1, class T2, class T3, class T4>
detail::binder<Ret, Fn, T1, T2, T3, T4> bind (Fn, T1, T2, T3, T4);

template <class Ret, class Fn, class T1, class T2, class T3, class T4, class T5>
detail::binder<Ret, Fn, T1, T2, T3, T4, T5> bind (Fn, T1, T2, T3, T4, T5);

template <class Ret, class Fn, class T1, class T2, class T3, class T4, class T5, class T6>
detail::binder<Ret, Fn, T1, T2, T3, T4, T5, T6> bind (Fn, T1, T2, T3, T4, T5, T6);

template <class Ret, class Fn, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
detail::binder<Ret, Fn, T1, T2, T3, T4, T5, T6, T7> bind (Fn, T1, T2, T3, T4, T5, T6, T7);

template <class Ret, class Fn, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
detail::binder<Ret, Fn, T1, T2, T3, T4, T5, T6, T7, T8> bind (Fn, T1, T2, T3, T4, T5, T6, T7, T8);

template <class Ret, class Fn, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
detail::binder<Ret, Fn, T1, T2, T3, T4, T5, T6, T7, T8, T9> bind (Fn, T1, T2, T3, T4, T5, T6, T7, T8, T9);

template <class Fn>
detail::binder<detail::unspecified_result, Fn> bind (Fn);

template <class Fn, class T1>
detail::binder<detail::unspecified_result, Fn, T1> bind (Fn, T1);

template <class Fn, class T1, class T2>
detail::binder<detail::unspecified_result, Fn, T1, T2> bind (Fn, T1, T2);

template <class Fn, class T1, class T2, class T3>
detail::binder<detail::unspecified_result, Fn, T1, T2, T3> bind (Fn, T1, T2, T3);

template <class Fn, class T1, class T2, class T3, class T4>
detail::binder<detail::unspecified_result, Fn, T1, T2, T3, T4> bind (Fn, T1, T2, T3, T4);

template <class Fn, class T1, class T2, class T3, class T4, class T5>
detail::binder<detail::unspecified_result, Fn, T1, T2, T3, T4, T5> bind (Fn, T1, T2, T3, T4, T5);

template <class Fn, class T1, class T2, class T3, class T4, class T5, class T6>
detail::binder<detail::unspecified_result, Fn, T1, T2, T3, T4, T5, T6> bind (Fn, T1, T2, T3, T4, T5, T6);

template <class Fn, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
detail::binder<detail::unspecified_result, Fn, T1, T2, T3, T4, T5, T6, T7> bind (Fn, T1, T2, T3, T4, T5, T6, T7);

template <class Fn, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
detail::binder<detail::unspecified_result, Fn, T1, T2, T3, T4, T5, T6, T7, T8> bind (Fn, T1, T2, T3, T4, T5, T6, T7, T8);

template <class Fn, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
detail::binder<detail::unspecified_result, Fn, T1, T2, T3, T4, T5, T6, T7, T8, T9> bind (Fn, T1, T2, T3, T4, T5, T6, T7, T8, T9);

#include <tr1/detail/fn_utils.inl>
#include <tr1/detail/bind.inl>

}

#endif
