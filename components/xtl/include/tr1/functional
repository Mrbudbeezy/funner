/*
    TR1 functionals
*/

#ifndef MYTR1_FUNCTIONAL_HEADER
#define MYTR1_FUNCTIONAL_HEADER

#include <tr1/functional_traits.h>
#include <mpl/utility.h>

namespace tr1
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Определение типа возвращаемого значения функции
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class FunctionCallType> struct result_of;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обёртка над ссылкой
///Отличие от стандарта: класс не наследуется от unary_function/binary_function, не имеет result_type
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> class reference_wrapper
{
  public:
    typedef T type;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    explicit reference_wrapper (T&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Операторы доступа
///////////////////////////////////////////////////////////////////////////////////////////////////
    operator T&  () const;
    T&       get () const;

  private:
    T* ptr;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка reference_wrapper
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> struct remove_reference_wrapper;

template <class T> reference_wrapper<T>       ref  (T&);
template <class T> reference_wrapper<const T> cref (const T&);
template <class T> reference_wrapper<T>       ref  (reference_wrapper<T>);
template <class T> reference_wrapper<const T> cref (reference_wrapper<T>);

/*
    Диспетчеризация вызовов функциональных объектов
*/

//перегрузка для функционального объекта без аргументов
template <class Fn>
typename result_of<Fn()>::type funcall (Fn);

//перегрузка для функционального объекта с 1-м аргументом
template <class Fn, class T1>
typename result_of<Fn(T1)>::type funcall (Fn, T1);

//перегрузка для функционального объекта с 2-мя аргументами
template <class Fn, class T1, class T2>
typename result_of<Fn(T1, T2)>::type funcall (Fn, T1, T2);

//перегрузка для функционального объекта с 3-мя аргументами
template <class Fn, class T1, class T2, class T3>
typename result_of<Fn(T1, T2, T3)>::type funcall (Fn, T1, T2, T3);

//перегрузка для функционального объекта с 4-мя аргументами
template <class Fn, class T1, class T2, class T3, class T4>
typename result_of<Fn(T1, T2, T3, T4)>::type funcall (Fn, T1, T2, T3, T4);

//перегрузка для функционального объекта с 5-ю аргументами
template <class Fn, class T1, class T2, class T3, class T4, class T5>
typename result_of<Fn(T1, T2, T3, T4, T5)>::type funcall (Fn, T1, T2, T3, T4, T5);

//перегрузка для функционального объекта с 6-ю аргументами
template <class Fn, class T1, class T2, class T3, class T4, class T5, class T6>
typename result_of<Fn(T1, T2, T3, T4, T5, T6)>::type funcall (Fn, T1, T2, T3, T4, T5, T6);

//перегрузка для функционального объекта с 7-ю аргументами
template <class Fn, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
typename result_of<Fn(T1, T2, T3, T4, T5, T6, T7)>::type funcall (Fn, T1, T2, T3, T4, T5, T6, T7);

//перегрузка для функционального объекта с 8-ю аргументами
template <class Fn, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
typename result_of<Fn(T1, T2, T3, T4, T5, T6, T7, T8)>::type funcall (Fn, T1, T2, T3, T4, T5, T6, T7, T8);

//перегрузка для функционального объекта с 9-ю аргументами
template <class Fn, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
typename result_of<Fn(T1, T2, T3, T4, T5, T6, T7, T8, T9)>::type funcall (Fn, T1, T2, T3, T4, T5, T6, T7, T8, T9);

#include <tr1/detail/funcall.inl>
#include <tr1/detail/fn_utils.inl>

}

#endif
