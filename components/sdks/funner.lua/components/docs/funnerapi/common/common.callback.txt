Title: Common.Callback
  Работа с функциями обратного вызова.

Section: Введение

  При работе с движком предусмотрено два вида связей: прямые и обратные. При вызове из lua функций движка используются прямые 
  связи. Однако бывают случаи, когда необходимо передать в движок функцию lua для возможности обратного вызова данной функции 
  через некоторое время при возникновении события. Например, такая необходимость возникает при обработке событий ввода, работе 
  с таймерами. Обратная связь от движка к lua производится при помощи *шлюзов*, которые создаются посредством вызова из lua 
  *порождающей функции*.

  Funner совместно с lua поддерживает следующие разновидности функций обратного вызова:

  + именованная глобальная функция обратного вызова; 
  + именованная локальная функция обратного вызова; 
  + анонимная локальная функция обратного вызова; 
  + анонимная функция-оператор.
  
Section: Именованная глобальная функция обратного вызова

  Данная функция должна иметь имя, доступное из глобального пространства имён lua. В качестве параметров порождающей функции 
  может выступать сама функция обратного вызова, либо строка с её именем. Второй вариант предпочтителен в случае, если функция 
  обратного вызова на момент создания шлюза ещё не определена.
  
  Пример:
  
  (start code)
  function callback1()
  end

  thunk1 = EventHandler (callback1)
  thunk2 = EventHandler ('callback2')

  function callback2() -- Данная функция объявлена после создания шлюза
  end
  (end code)
  
Section: Именованная локальная функция обратного вызова

  Данный вариант создания функции обратного вызова аналогичен предыдущему, за исключением того, что сама функция обратного 
  вызова определена в пределах другой функции.
  
  Пример:
  
  (start code)
  function f(x)
    local function callback(y)
      return x * y
    end

    return EventHandler (callback)
  end
  (end code)

  Рассмотрим подробно приведенный выше пример. Во-первых, возвращаемый функцией f(x) шлюз связан с функцией обратного вызова 
  невидимой из глобального пространства имён. Во-вторых, сама функция обратного вызова "видит" все локальные переменные 
  включающей её функции f, в частности, переменную x. 

  Следует отметить, что для данного случая передача строковой константы с именем локальной функции приведет к созданию шлюза 
  на именованную глобальную функцию обратного вызова.
  
Section: Анонимная локальная функция обратного вызова

  Данный вариант фактически является частным случаем локальной функции обратного вызова. Различие только лишь в форме записи. 
  Фактически, данный вариант позволяет определять функцию обратного вызова непосредственно в месте подстановки аргумента шлюза.
  
  Пример:
  
  (start code)
  function f(x)
    return EventHandler (function (y) return x * y end)
  end
  (end code)
  
  Привязка аргументов:
  
  Анонимные функции обратного вызова позволяют изменять порядок аргументов функции обратного вызова и замещения аргументов 
  функции константами, известными на момент создания шлюза.
  
  Пример:
  
  (start code)
  function callback(x,y,z)
  end

  function f(x)
    return EventHandler (function (z,x) return callback (x, 12, z) end)
  end
  (end code)
  
Section: Анонимная функция-оператор

  Данный сокращенный вариант анонимной локальной функции позволяет автоматически создавать шлюз функции обратного вызова по её 
  телу, определенному в строковой константе. Строковая константа должна начинаться с символа '@', после которого идёт 
  непосредственно тело функции обратного вызова.
  
  Пример:
  
  (start code)
  x = 2
  y = 3
  thunk = EventHandler ("@x = y")
  (end code)
  
  Данный вид функции обратного вызова приемлем для создания шлюзов с простыми действиями, незагромождая код.
  