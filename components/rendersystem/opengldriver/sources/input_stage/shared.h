#ifndef RENDER_GL_DRIVER_INPUT_STAGE_SHARED_HEADER
#define RENDER_GL_DRIVER_INPUT_STAGE_SHARED_HEADER

#include <common/exception.h>
#include <common/singleton.h>

#include <xtl/uninitialized_storage.h>
#include <xtl/trackable_ptr.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/array>

#include <stl/vector>
#include <stl/algorithm>

#include <render/low_level/utils.h>

#include <shared/input_stage.h>
#include <shared/context_object.h>
#include <shared/object.h>

namespace render
{

namespace low_level
{

namespace opengl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вершинный буфер
///////////////////////////////////////////////////////////////////////////////////////////////////
class Buffer: virtual public IBuffer, virtual public IBindableBuffer, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Buffer (const ContextManager&, const BufferDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка типа буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool   IsVertexBuffer () const { return (desc.bind_flags & BindFlag_VertexBuffer) != 0; }
    bool   IsIndexBuffer  () const { return (desc.bind_flags & BindFlag_IndexBuffer) != 0; }
    size_t GetBindFlags   () const { return desc.bind_flags; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (BufferDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t offset, size_t size, const void* data);
    void GetData (size_t offset, size_t size, void* data);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / чтение данных после отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void SetDataCore (size_t offset, size_t size, const void* data) = 0;
    virtual void GetDataCore (size_t offset, size_t size, void* data) = 0;

  private:
    BufferDesc desc; //дескриптор буфера
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Указатель на буфер
///////////////////////////////////////////////////////////////////////////////////////////////////    
typedef xtl::trackable_ptr<Buffer> BufferPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер с хранением в системной памяти
///////////////////////////////////////////////////////////////////////////////////////////////////
class SystemMemoryBuffer: public Buffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SystemMemoryBuffer  (const ContextManager&, const BufferDesc&);
    ~SystemMemoryBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Указатель на данные буфера
///////////////////////////////////////////////////////////////////////////////////////////////////    
    void* GetDataPointer ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / чтение данных после отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDataCore (size_t offset, size_t size, const void* data);
    void GetDataCore (size_t offset, size_t size, void* data);

  private:
    xtl::uninitialized_storage <char> buffer;     //буфер в системной памяти
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер с хранением в видеопамяти с использованием расширения GL_ARB_vertex_buffer_object
///////////////////////////////////////////////////////////////////////////////////////////////////
class VboBuffer: public Buffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    VboBuffer  (const ContextManager&, GLenum target, const BufferDesc&);
    ~VboBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Cмещение от начала буфера (для аппаратных буферов)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void* GetDataPointer ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / чтение данных после отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDataCore (size_t offset, size_t size, const void* data);
    void GetDataCore (size_t offset, size_t size, void* data);

  private:
    GLenum target;     //целевой тип аппаратного буфера (GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER)
    GLuint buffer_id;  //номер буфера в контексте OpenGL
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние подуровня расположения геометрии
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputLayout: virtual public IInputLayout, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputLayout  (const ContextManager&, const InputLayoutDesc&, size_t tex_units_count);
    ~InputLayout ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDesc (const InputLayoutDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
//Установка состояния в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
   void Bind (size_t         base_vertex,
              size_t         base_index,
              BufferPtr*     vertex_buffers,
              BufferPtr      index_buffer,
              IndicesLayout* out_indices_layout);

  private:
    struct GlVertexAttribute;
    struct GlVertexAttributeGroup;

    typedef stl::vector<GlVertexAttribute>      GlVertexAttributeArray;
    typedef stl::vector<GlVertexAttributeGroup> GlVertexAttributeGroupArray;

  private:
    GlVertexAttributeArray      vertex_attributes;       //вершинные атрибуты
    GlVertexAttributeGroupArray vertex_attribute_groups; //группы вершинных атрибутов
    GLenum                      index_data_type;         //тип индексов
    size_t                      index_size;              //размер индекса
    size_t                      index_buffer_offset;     //смещение в индексном буфере до первого индекса
    size_t                      tex_units_count;         //количество текстурных юнитов поддерживаемое аппаратно
};

}

}

}

#endif
