#ifndef RENDER_GL_DRIVER_SHADER_STAGE_SHARED_HEADER
#define RENDER_GL_DRIVER_SHADER_STAGE_SHARED_HEADER

#include <render/low_level/utils.h>

#include <shared/shader_stage.h>
#include <shared/input_stage.h>

#include <common/exception.h>

#include <stl/vector>

#include <xtl/intrusive_ptr.h>
#include <xtl/trackable_ptr.h>
#include <xtl/uninitialized_storage.h>

namespace render
{

namespace low_level
{

namespace opengl
{

typedef xtl::trackable_ptr<IBindableBuffer> ConstantBufferPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Элементы таблицы локальных данных контекста
///////////////////////////////////////////////////////////////////////////////////////////////////
enum ShaderStageCache
{
  ShaderStageCache_UsedProgram,    //ID текущей используемой программы
};

struct ProgramParameterGroup
{
  size_t            slot;       //номер слота с константым буфером
  size_t            count;      //количество элементов группы
  ProgramParameter* parameters; //указатель на начало области с элементами
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание расположения параметров
///////////////////////////////////////////////////////////////////////////////////////////////////
class ProgramParametersLayout : virtual public IProgramParametersLayout, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ProgramParametersLayout (const ProgramParametersLayoutDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Изменение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDesc (const ProgramParametersLayoutDesc& in_desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение данных
///////////////////////////////////////////////////////////////////////////////////////////////////
          ///добавить приставку Get!!!
    size_t                 ParametersCount () {return parameters.size ();}
    size_t                 GroupsCount ();
    ProgramParameterGroup& ParametersGroup (size_t index);

    size_t                 GetGroupsCount     () const { return parameter_groups.size (); }
    size_t                 GetParametersCount () const { return parameter_groups.size (); }    
    ProgramParameterGroup* GetGroups          ()       { return &parameter_groups [0]; }
    ProgramParameter*      GetParameters      ()       { return &parameters [0]; }

  private:
    stl::vector<ProgramParameterGroup> parameter_groups;
    stl::vector<ProgramParameter>      parameters;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Шейдер
///////////////////////////////////////////////////////////////////////////////////////////////////
class Shader : virtual public IObject
{
};

typedef xtl::com_ptr<Shader> ShaderPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Программа
///////////////////////////////////////////////////////////////////////////////////////////////////
class Program : virtual public IProgram, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Биндинг
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Bind (ConstantBufferPtr* constant_buffers, ProgramParametersLayout* parameters_layout) = 0;
    
  protected:
    Program (const ContextManager& manager) : ContextObject (manager) {}
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Шейдер менеджер
///////////////////////////////////////////////////////////////////////////////////////////////////
class ShaderManager : virtual public IObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
   virtual ~ShaderManager () {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество поддерживаемых профилей
///////////////////////////////////////////////////////////////////////////////////////////////////
   virtual size_t GetProfilesCount () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имена поддерживаемых профилей
///////////////////////////////////////////////////////////////////////////////////////////////////
   virtual const char* GetProfile (size_t index) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание шейдера
///////////////////////////////////////////////////////////////////////////////////////////////////
   virtual Shader*  CreateShader  (const ShaderDesc& shader_desc, const LogFunction& error_log) = 0;
   virtual Program* CreateProgram (size_t shaders_count, ShaderPtr* shaders, const LogFunction& error_log) = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание шейдер менеджеров
///////////////////////////////////////////////////////////////////////////////////////////////////
ShaderManager* create_fpp_shader_manager  (const ContextManager& manager);
ShaderManager* create_glsl_shader_manager (const ContextManager& manager);

}

}

}

#endif
