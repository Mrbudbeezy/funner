#ifndef RENDER_GL_DRIVER_SHADER_STAGE_GLSL_SHARED_HEADER
#define RENDER_GL_DRIVER_SHADER_STAGE_GLSL_SHARED_HEADER

#include "../shared.h"

namespace render
{

namespace low_level
{

namespace opengl
{

enum GlslShaderType
{
  GlslShaderType_Fragment,
  GlslShaderType_Vertex,

  GlslShaderType_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///GLSL шейдер менеджер
///////////////////////////////////////////////////////////////////////////////////////////////////
class GlslShaderManager : public ShaderManager, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / Деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    GlslShaderManager (const ContextManager& manager);
    ~GlslShaderManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество поддерживаемых профилей
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetProfilesCount ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имена поддерживаемых профилей
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetProfile (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание шейдера
///////////////////////////////////////////////////////////////////////////////////////////////////
    Shader* CreateShader (size_t shaders_count, const ShaderDesc* shader_descs, const LogFunction& error_log);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///GLSL Шейдер
///////////////////////////////////////////////////////////////////////////////////////////////////
class GlslShader : public Shader
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор/деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    GlslShader (const ContextManager& manager, size_t shaders_count, const ShaderDesc* shader_descs, const LogFunction& error_log);
    ~GlslShader ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Биндинг
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (ConstantBufferPtr* constant_buffers, ShaderParametersLayout* shader_parameters_layout);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение лога OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetShaderLog (size_t shader_index);
    void GetProgramLog ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление шейдеров
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DeletePrograms ();

  private:
    GLhandleARB                      shader[GlslShaderType_Num];             //шейдера (вертексный, пиксельный)
    GLhandleARB                      program;                            //линкуемый шейдер    
    bool                             is_shader_attached[GlslShaderType_Num]; //подключен ли шейдер к программе
    xtl::uninitialized_storage<char> log_buffer;                         //буфер для получения лога GL
    ShaderDesc                       descs[GlslShaderType_Num];              //описание шейдеров
    LogFunction                      error_log;                          //лог ошибок
};

GlslShaderType get_shader_type (const char* profile); //получение ShaderType по имени профиля (при получении неизвестного имени возвращается -1)

}

}

}

#endif
