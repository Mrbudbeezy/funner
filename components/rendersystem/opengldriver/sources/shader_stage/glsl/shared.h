#ifndef RENDER_GL_DRIVER_SHADER_STAGE_GLSL_SHARED_HEADER
#define RENDER_GL_DRIVER_SHADER_STAGE_GLSL_SHARED_HEADER

#include "../shared.h"

#include <stl/string> //!!!

namespace render
{

namespace low_level
{

namespace opengl
{

enum GlslShaderType
{
  GlslShaderType_Fragment,
  GlslShaderType_Vertex,

  GlslShaderType_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///GLSL шейдер менеджер
///////////////////////////////////////////////////////////////////////////////////////////////////
class GlslShaderManager : public ShaderManager, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / Деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    GlslShaderManager (const ContextManager& manager);
    ~GlslShaderManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество поддерживаемых профилей
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetProfilesCount ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имена поддерживаемых профилей
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetProfile (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание шейдера
///////////////////////////////////////////////////////////////////////////////////////////////////
    Shader* CreateShader (size_t shaders_count, const ShaderDesc* shader_descs, const LogFunction& error_log);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///GLSL Шейдер
///////////////////////////////////////////////////////////////////////////////////////////////////
class GlslShader : public Shader
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор/деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    GlslShader (const ContextManager& manager, size_t shaders_count, const ShaderDesc* shader_descs, const LogFunction& error_log);
    ~GlslShader ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Биндинг
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (ConstantBufferPtr* constant_buffers, ShaderParametersLayout* shader_parameters_layout);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение лога OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetShaderLog (size_t shader_index, stl::string& buffer);
    void GetProgramLog (stl::string&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление шейдеров
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DeletePrograms ();

  private:
    GLhandleARB shader [GlslShaderType_Num];             //шейдера (вертексный, пиксельный)
    GLhandleARB program;                                 //линкуемый шейдер
    bool        is_shader_attached [GlslShaderType_Num]; //подключен ли шейдер к программе //????
    ShaderDesc  descs [GlslShaderType_Num];              //описание шейдеров
};

GlslShaderType get_shader_type (const char* profile); //получение ShaderType по имени профиля (при получении неизвестного имени возвращается -1)

}

}

}

#endif
