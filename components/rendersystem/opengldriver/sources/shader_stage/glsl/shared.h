#ifndef RENDER_GL_DRIVER_SHADER_STAGE_GLSL_SHARED_HEADER
#define RENDER_GL_DRIVER_SHADER_STAGE_GLSL_SHARED_HEADER

#include "../shared.h"

#include <stl/string> //!!!
#include <stl/vector>


namespace render
{

namespace low_level
{

namespace opengl
{

enum GlslShaderType
{
  GlslShaderType_Fragment,
  GlslShaderType_Vertex,

  GlslShaderType_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///GLSL шейдер менеджер
///////////////////////////////////////////////////////////////////////////////////////////////////
class GlslShaderManager : virtual public ShaderManager, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / Деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    GlslShaderManager (const ContextManager& manager);
    ~GlslShaderManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество поддерживаемых профилей
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetProfilesCount ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имена поддерживаемых профилей
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetProfile (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание шейдера
///////////////////////////////////////////////////////////////////////////////////////////////////
    Shader*  CreateShader  (const ShaderDesc& shader_desc, const LogFunction& error_log);
    Program* CreateProgram (size_t shaders_count, ShaderPtr* shaders, const LogFunction& error_log);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///GLSL Шейдер
///////////////////////////////////////////////////////////////////////////////////////////////////
class GlslShader : virtual public Shader, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор/деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    GlslShader (const ContextManager& manager, const ShaderDesc& shader_desc, const LogFunction& error_log);
    ~GlslShader ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение OpenGL хендла
///////////////////////////////////////////////////////////////////////////////////////////////////
    GLhandleARB GetShaderObject () {return shader;}
  
  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение лога OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetShaderLog (stl::string& buffer);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление шейдера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DeleteShader ();

  private:
    GLhandleARB shader; //шейдер
};

typedef xtl::com_ptr<GlslShader> GlslShaderPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///GLSL Программа
///////////////////////////////////////////////////////////////////////////////////////////////////
class GlslProgram : virtual public Program, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор/деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    GlslProgram (const ContextManager& manager, size_t shaders_count, ShaderPtr* shaders, const LogFunction& error_log);
    ~GlslProgram ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Биндинг
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (ConstantBufferPtr* constant_buffers, ProgramParametersLayout* parameters_layout);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение лога OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetProgramLog (stl::string&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление шейдеров
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DeleteProgram ();

  private:
    struct LayoutCacheEntry;

    typedef stl::vector<GlslShaderPtr>    ShaderArray;
    typedef stl::vector<LayoutCacheEntry> LayoutsCache;

    GLhandleARB     program;        //линкуемый шейдер
    ShaderArray     shaders;        //используемые шейдеры
    LayoutsCache    layouts_cache;  //кэш параметров программы
    size_t          current_time;   //текущее время
};

GlslShaderType get_shader_type (const char* profile); //получение ShaderType по имени профиля (при получении неизвестного имени возвращается -1)

}

}

}

#endif
