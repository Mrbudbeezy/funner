#ifndef RENDER_GL_DRIVER_FPP_SHADER_MANAGER_SHARED_HEADER
#define RENDER_GL_DRIVER_FPP_SHADER_MANAGER_SHARED_HEADER

#include "../shared.h"

#include <stl/string>
#include <stl/hash_map>

#include <common/parser.h>
#include <common/strlib.h>

namespace render
{

namespace low_level
{

namespace opengl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Константы
///////////////////////////////////////////////////////////////////////////////////////////////////
const size_t FPP_MAX_LIGHTS_COUNT = 8; //максимальное количество источников освещения

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип источника света
///////////////////////////////////////////////////////////////////////////////////////////////////
enum LightType
{
  LightType_Point,  //точечный источник света
  LightType_Remote, //удалённый направленный источник света
  LightType_Spot,   //конусоидальный направленный источник света
  
  LightType_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание источника света
///////////////////////////////////////////////////////////////////////////////////////////////////
struct LightDesc
{
  LightType type;                  //тип источника света
  int       enable;                //состояние источника света: включён/выключен
  float     position [3];          //положение источника света
  float     direction [3];         //направление источника света
  Color4f   ambient_color;         //веса поглащаемой составляющей света
  Color4f   diffuse_color;         //веса рассеиваемой составляющей света
  Color4f   specular_color;        //веса отражённой составляющей света
  float     angle;                 //угол излучения
  float     exponent;              //экспонента затухания освещения по углу
  float     constant_attenuation;  //константное затухание от расстояния
  float     linear_attenuation;    //линейное затухание от расстояния
  float     quadratic_attenuation; //квадратичное затухание от расстояния
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Источник текстурных координат
///////////////////////////////////////////////////////////////////////////////////////////////////
enum TexcoordSource
{
  TexcoordSource_Explicit,      //текстурные координаты задаются явно
  TexcoordSource_SphereMap,     //генерация текстурных координат: сферическая карта
  TexcoordSource_ReflectionMap, //генерация текстурных координат: карта отражения
  TexcoordSource_ObjectSpace,   //генерация текстурных координат: texmap.transform * position
  TexcoordSource_ViewerSpace,   //генерация текстурных координат: texmap.transform * modelviewprojection * position
  
  TexcoordSource_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор текстурной карты
///////////////////////////////////////////////////////////////////////////////////////////////////
struct TexmapDesc
{
  Matrix4f       transform; //матрица преобразования текстурных координат
  Matrix4f       texgen;    //матрица параметров генерации текстурных координат
  TexcoordSource source_u;  //источник текстурных координат для U-координаты
  TexcoordSource source_v;  //источник текстурных координат для V-координаты
  TexcoordSource source_w;  //источник текстурных координат для W-координаты
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние фиксированной программы шейдинга
///////////////////////////////////////////////////////////////////////////////////////////////////
struct FppState
{
  Matrix4f    projection_matrix;                  //матрица проецирования
  Matrix4f    view_matrix;                        //матрица вида
  Matrix4f    object_matrix;                      //матрица преобразований объекта
  size_t      lights_count;                       //количество источников освещения
  LightDesc   lights [FPP_MAX_LIGHTS_COUNT];      //параметры источников освещения
  Color4f     emission_color;                     //цвет излучения
  Color4f     ambient_color;                      //цвет поглощения
  Color4f     diffuse_color;                      //цвет рассеивания
  Color4f     specular_color;                     //цвет отражения
  float       shininess;                          //"металличность"
  CompareMode alpha_compare_mode;                 //режим альфа теста
  float       alpha_reference;                    //константа альфа теста
  TexmapDesc  maps [DEVICE_SAMPLER_SLOTS_COUNT];  //текстурные карты
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип динамического параметра
///////////////////////////////////////////////////////////////////////////////////////////////////
enum FppDynamicParameterType
{
  FppDynamicParameterType_Int,   //целое число
  FppDynamicParameterType_Float, //вещественное число
  
  FppDynamicParameterType_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Массив смещений полей структуры FppState, обновляемых вместе с динамическим параметром
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef stl::vector<size_t> FppFieldOffsetArray;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Динамический параметр fpp-шейдера (аналог uniform-var в glsl)
///////////////////////////////////////////////////////////////////////////////////////////////////
struct FppDynamicParameter
{
  FppDynamicParameterType type;          //тип параметра
  size_t                  count;         //количество элементов
  FppFieldOffsetArray     field_offsets; //смещения полей в структуре FppState, обновляемых при изменении параметра
};

typedef stl::hash_map<stl::hash_key<const char*>, FppDynamicParameter> FppDynamicParameterMap;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Fixed-pipeline-program шейдер
///////////////////////////////////////////////////////////////////////////////////////////////////
class FppShader: virtual public Shader, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FppShader  (const ShaderDesc& shader_desc, const LogFunction& error_log);
    ~FppShader ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовое состояние фиксированной программы шейдинга
///////////////////////////////////////////////////////////////////////////////////////////////////
    const FppState& GetBaseState () const { return base_state; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с динамическими параметрами
///////////////////////////////////////////////////////////////////////////////////////////////////
    const FppDynamicParameter* FindDynamicParameter (const char* name) const;

  private:
    FppState               base_state;         //базовое состояние фиксированной программы шейдинга
    FppDynamicParameterMap dynamic_parameters; //массив динамических параметров
};

typedef xtl::com_ptr<FppShader> FppShaderPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Fixed-pipeline-program
///////////////////////////////////////////////////////////////////////////////////////////////////
class FppProgram : virtual public Program, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор/деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FppProgram (const ContextManager& manager, size_t shaders_count, ShaderPtr* shaders);
    ~FppProgram ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Биндинг
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (ConstantBufferPtr* constant_buffers, ProgramParametersLayout* parameters_layout);
    
  private:
    struct LayoutCacheEntry;  

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение расположения параметров
///////////////////////////////////////////////////////////////////////////////////////////////////
    LayoutCacheEntry& GetLayout (ProgramParametersLayout*);

  private:
    typedef stl::vector<LayoutCacheEntry> LayoutsCache;
    typedef xtl::com_ptr<FppShader>       FppShaderPtr;

    FppShaderPtr  shader;         //используемый шейдер
    LayoutsCache  layouts_cache;  //кэш параметров программы
    size_t        current_time;   //текущее время
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер fixed-pipeline-program шейдеров
///////////////////////////////////////////////////////////////////////////////////////////////////
class FppShaderManager : virtual public ShaderManager, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FppShaderManager (const ContextManager& manager);
    ~FppShaderManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество поддерживаемых профилей
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetProfilesCount ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имена поддерживаемых профилей
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetProfile (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание шейдера
///////////////////////////////////////////////////////////////////////////////////////////////////
    Shader*  CreateShader  (const ShaderDesc& shader_desc, const LogFunction& error_log);
    Program* CreateProgram (size_t shaders_count, ShaderPtr* shaders, const LogFunction& error_log);
};

}

}

}

#endif
