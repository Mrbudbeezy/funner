#ifndef RENDER_GL_DRIVER_TEXTURE_SHARED_HEADER
#define RENDER_GL_DRIVER_TEXTURE_SHARED_HEADER

#include <math.h>
#include <common/exception.h>
#include <shared/texture_manager.h>
#include <shared/context_object.h>

namespace render
{

namespace low_level
{

namespace opengl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый класс реализации текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture : virtual public IBindableTexture, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture  (const ContextManager&, const TextureDesc&, GLenum target);
    ~Texture ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (TextureDesc&);
    void GetDesc (BindableTextureDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Выбор текстуры в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение идентификатора и типа текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    GLenum GetTarget    () const { return target; }
    GLuint GetTextureId () const { return texture_id; }

  public:
    GLenum      target;      //целевой тип текстуры
    GLuint      texture_id;  //идентификатор текстуры
    TextureDesc desc;        //дескриптор текстуры
    size_t      mips_count;  //количество мип-уровней
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Одномерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture1D : public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture1D (const ContextManager&, const TextureDesc& texture_desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Двумерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture2D : public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture2D (const ContextManager&, const TextureDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    virtual void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текстура со сторонами не степени 2, работающая через расширение GL_EXT_texture_rectangle
///////////////////////////////////////////////////////////////////////////////////////////////////
class TextureNPOT : public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextureNPOT (const ContextManager&, const TextureDesc& texture_desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текстура со сторонами не степени 2, растянутая (используетсяч при остутствии GL_EXT_texture_rectangle)
///////////////////////////////////////////////////////////////////////////////////////////////////
class TextureEmulatedNPOT : public Texture2D
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextureEmulatedNPOT (const ContextManager&, const TextureDesc& texture_desc, float in_horisontal_scale, float in_vertical_scale);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  private:
    float horisontal_scale; //коэффициент растягивания по горизонтали
    float vertical_scale;   //коэффициент растягивания по вертикали
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Трёхмерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture3D : public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture3D (const ContextManager&, const TextureDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Трёхмерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture3DEmulatedNPOT : public Texture3D
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture3DEmulatedNPOT (const ContextManager&, const TextureDesc&, float in_horisontal_scale, float in_vertical_scale);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  private:
    float horisontal_scale; //коэффициент растягивания по горизонтали
    float vertical_scale;   //коэффициент растягивания по вертикали
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Кубмап текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class TextureCubemap : public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextureCubemap (const ContextManager&, const TextureDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Кубмап текстура со сторонами не степени 2, растянутая (используетсяч при остутствии GL_ARB_texture_non_power_of_two)
///////////////////////////////////////////////////////////////////////////////////////////////////
class TextureCubemapEmulatedNPOT : public TextureCubemap
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextureCubemapEmulatedNPOT (const ContextManager&, const TextureDesc&, float in_scale_factor);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  private:
    float scale_factor; //коэффициент растягивания
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение параметров текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
size_t texel_size           (PixelFormat format);  //размер текселя в байтах
GLint  gl_internal_format   (PixelFormat format);  //внутренний формат OpenGL
GLenum gl_format            (PixelFormat format);  //формат OpenGL
GLenum gl_type              (PixelFormat format);  //тип OpenGL
bool   is_compressed_format (PixelFormat format);  //является ли формат сжатым
size_t compressed_quad_size (PixelFormat format);  //размер блока сжатых пикселей 4*4 в байтах

///////////////////////////////////////////////////////////////////////////////////////////////////
///Масштабирование текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
void scale_image_2x_down (PixelFormat format, size_t width,     size_t height,     const void* src, void* dest);
void scale_image         (PixelFormat format, size_t width,     size_t height, 
                                              size_t new_width, size_t new_height, const void* src, void* dest);
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с DXT форматом при остутствии аппаратной поддержки
///////////////////////////////////////////////////////////////////////////////////////////////////
void   unpack_dxt (PixelFormat format, size_t width, size_t height, const void* dxt_data,      void* unpacked_data); //распаковка dxt
void   pack_dxt   (PixelFormat format, size_t width, size_t height, const void* unpacked_data, void* dxt_data);      //упаковка dxt
GLint  unpack_internal_format (PixelFormat format);                                                                  //распакованный внутренний формат OpenGL
GLenum unpack_type            (PixelFormat format);                                                                  //распакованный тип OpenGL
size_t unpack_texel_size      (PixelFormat format);                                                                  //размер распакованного текселя в байтах
GLenum unpack_format          (PixelFormat format);                                                                  //распакованный формат OpenGL
PixelFormat unpack_pf         (PixelFormat format);                                                                  //распакованный формат

}

}

}

#endif
