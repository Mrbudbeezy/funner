#ifndef RENDER_GL_DRIVER_TEXTURE_SHARED_HEADER
#define RENDER_GL_DRIVER_TEXTURE_SHARED_HEADER

#include <math.h>

#include <common/exception.h>

#include <xtl/uninitialized_storage.h>
#include <xtl/intrusive_ptr.h>

#include <render/low_level/utils.h>

#include <shared/texture_manager.h>
#include <shared/context_object.h>

#include "nv_dxt/blockdxt.h"

namespace render
{

namespace low_level
{

namespace opengl
{

///////переместить в исходники!!!
struct TextureExtensions
{
  bool has_arb_texture_compression;      //GL_ARB_texture_compression
  bool has_ext_texture_compression_s3tc; //GL_EXT_texture_compression_s3tc
  bool has_sgis_generate_mipmap;         //GL_SGIS_generate_mipmap
  
  TextureExtensions (const ContextManager& manager)
  {
    static Extension SGIS_generate_mipmap         = "GL_SGIS_generate_mipmap",
                     EXT_texture_compression_s3tc = "GL_EXT_texture_compression_s3tc",
                     ARB_texture_compression      = "GL_ARB_texture_compression",
                     Version_1_3                  = "GL_VERSION_1_3",
                     Version_1_4                  = "GL_VERSION_1_4";
      
    has_arb_texture_compression      = manager.IsSupported (ARB_texture_compression);
    has_ext_texture_compression_s3tc = (has_arb_texture_compression || manager.IsSupported (Version_1_3)) && manager.IsSupported (EXT_texture_compression_s3tc);
    has_sgis_generate_mipmap         = (manager.IsSupported (SGIS_generate_mipmap) || manager.IsSupported (Version_1_4));
  }
};

struct LayerDesc
{
  GLenum target;
  size_t new_index;
};

struct MipLevelDesc
{
  size_t width, height;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый класс реализации текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture : virtual public IBindableTexture, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture  (const ContextManager&, const TextureDesc&, GLenum target);
    ~Texture ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (TextureDesc&);
    void GetDesc (BindableTextureDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Выбор текстуры в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (); //????????????
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение идентификатора и типа текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    GLenum GetTarget    () const { return target; }
    GLuint GetTextureId () const { return texture_id; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);
    
  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора mip-уровня текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetMipLevelDesc (size_t level, MipLevelDesc& desc);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора слоя текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void GetLayerDesc (size_t layer, LayerDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных  --- сделать чисто-виртуальными!!!
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                                      GLenum format, GLenum type, const void* buffer);
    virtual void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                                    GLenum format, size_t buffer_size, const void* buffer);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Генерация mip-уровней
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BuildMipmaps (size_t x, size_t y, size_t z, size_t width, size_t height, PixelFormat format, const void* data);

  public: //???!!!private!!!
    GLenum      target;      //целевой тип текстуры
    GLuint      texture_id;  //идентификатор текстуры
    TextureDesc desc;        //дескриптор текстуры
    size_t      mips_count;  //количество мип-уровней
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Одномерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture1D : public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture1D (const ContextManager&, const TextureDesc& texture_desc);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Двумерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture2D : public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture2D (const ContextManager&, const TextureDesc&);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текстура со сторонами не степени 2, работающая через расширение GL_EXT_texture_rectangle
///////////////////////////////////////////////////////////////////////////////////////////////////
class TextureNPOT : public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextureNPOT (const ContextManager&, const TextureDesc& texture_desc);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Трёхмерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture3D : public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture3D (const ContextManager&, const TextureDesc&);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Кубмап текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class TextureCubemap : public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextureCubemap (const ContextManager&, const TextureDesc&);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора слоя текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetLayerDesc (size_t layer, LayerDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текстура со сторонами, масштабированными до ближайшей степени двойки
///////////////////////////////////////////////////////////////////////////////////////////////////
class ScaledTexture: virtual public IBindableTexture, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ScaledTexture (TextureManager& manager, const TextureDesc& original_desc, size_t scaled_width=0, size_t scaled_height=0);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (TextureDesc&);
    void GetDesc (BindableTextureDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  private:
    typedef xtl::com_ptr<IBindableTexture> TexturePtr;

  private:
    TexturePtr shadow_texture;   //теневая текстура, со сторонами кратными степени двойки
    size_t     original_width;   //ширина оригинальной текстуры
    size_t     original_height;  //высота оригинальной текстуры
    float      horisontal_scale; //коэффициент растяжения по горизонтали
    float      vertical_scale;   //коэффициент растяжения по вертикали
};

/*///////////////////////////////////////////////////////////////////////////////////////////////////
///Текстура со сторонами не степени 2, растянутая (используетсяч при остутствии GL_EXT_texture_rectangle)
///////////////////////////////////////////////////////////////////////////////////////////////////
class TextureEmulatedNPOT : public Texture2D
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextureEmulatedNPOT (const ContextManager&, const TextureDesc& texture_desc, float in_horisontal_scale, float in_vertical_scale);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  private:
    float horisontal_scale; //коэффициент растягивания по горизонтали
    float vertical_scale;   //коэффициент растягивания по вертикали
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Трёхмерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture3DEmulatedNPOT : public Texture3D ///???????
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture3DEmulatedNPOT (const ContextManager&, const TextureDesc&, float in_horisontal_scale, float in_vertical_scale);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  private:
    float horisontal_scale; //коэффициент растягивания по горизонтали
    float vertical_scale;   //коэффициент растягивания по вертикали
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Кубмап текстура со сторонами не степени 2, растянутая (используетсяч при остутствии GL_ARB_texture_non_power_of_two)
///////////////////////////////////////////////////////////////////////////////////////////////////
class TextureCubemapEmulatedNPOT : public TextureCubemap
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextureCubemapEmulatedNPOT (const ContextManager&, const TextureDesc&, float in_scale_factor);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  private:
    float scale_factor; //коэффициент растягивания
};*/

///////////////////////////////////////////////////////////////////////////////////////////////////
///Утилиты
///////////////////////////////////////////////////////////////////////////////////////////////////
size_t next_higher_power_of_two (size_t size); //получение ближайшей сверху степени двойки

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение параметров текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
size_t texel_size           (PixelFormat format);          //размер текселя в байтах
GLint  gl_internal_format   (PixelFormat format);          //внутренний формат OpenGL
GLenum gl_format            (PixelFormat format);          //формат OpenGL
GLenum gl_type              (PixelFormat format);          //тип OpenGL
bool   is_compressed_format (PixelFormat format);          //является ли формат сжатым
bool   is_depth_format      (PixelFormat format);          //является ли форматом глубины
size_t compressed_quad_size (PixelFormat format);          //размер блока сжатых пикселей 4*4 в байтах
size_t get_mips_count       (size_t size);                 //получение количества mip-уровней
size_t get_mips_count       (size_t width, size_t height); //получение количества mip-уровней

///////////////////////////////////////////////////////////////////////////////////////////////////
///Масштабирование текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef void (*SetTexDataFn)(size_t mip_level, size_t x, size_t y, size_t z, size_t width, size_t height, GLenum format, GLenum type, const void* data);

void scale_image_2x_down (PixelFormat format, size_t width, size_t height, const void* src, void* dest);
void scale_image         (PixelFormat format, size_t width, size_t height, size_t new_width, size_t new_height, const void* src, void* dest);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с DXT форматом при остутствии аппаратной поддержки
///////////////////////////////////////////////////////////////////////////////////////////////////
void   unpack_dxt (PixelFormat format, size_t width, size_t height, const void* dxt_data, void* unpacked_data); //распаковка dxt
GLint  unpack_internal_format (PixelFormat format);                                                             //распакованный внутренний формат OpenGL
GLenum unpack_type            (PixelFormat format);                                                             //распакованный тип OpenGL
size_t unpack_texel_size      (PixelFormat format);                                                             //размер распакованного текселя в байтах
GLenum unpack_format          (PixelFormat format);                                                             //распакованный формат OpenGL
PixelFormat unpack_pf         (PixelFormat format);                                                             //распакованный формат

size_t get_compressed_image_size (PixelFormat format, size_t width, size_t height);

}

}

}

#endif
