#ifndef RENDER_GL_DRIVER_TEXTURE_SHARED_HEADER
#define RENDER_GL_DRIVER_TEXTURE_SHARED_HEADER

#include <math.h>

#include <common/exception.h>

#include <xtl/trackable_ptr.h>
#include <xtl/uninitialized_storage.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/shared_ptr.h>

#include <render/low_level/utils.h>

#include <shared/texture_manager.h>
#include <shared/context_object.h>

#include "nv_dxt/blockdxt.h"

namespace render
{

namespace low_level
{

namespace opengl
{

enum OpenGLTextureTarget
{
  OpenGLTextureTarget_Texture1D,
  OpenGLTextureTarget_Texture2D,
  OpenGLTextureTarget_TextureRectangle,
  OpenGLTextureTarget_Texture3D,
  OpenGLTextureTarget_TextureCubemap,

  OpenGLTextureTarget_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Расширения, поддерживаемые менеджером текстур
///////////////////////////////////////////////////////////////////////////////////////////////////
struct TextureExtensions
{  
  bool has_ext_texture_compression_s3tc; //GL_EXT_texture_compression_s3tc
  bool has_sgis_generate_mipmap;         //GL_SGIS_generate_mipmap  
  bool has_ext_texture_rectangle;        //GL_EXT_texture_rectangle
  bool has_ext_texture3d;                //GL_EXT_texture3D
  bool has_ext_packed_depth_stencil;     //GL_EXT_packed_depth_stencil
  bool has_arb_multitexture;             //GL_ARB_multitexture
  bool has_arb_texture_cube_map;         //GL_ARB_texture_cubemap
  bool has_arb_texture_non_power_of_two; //GL_ARB_texture_non_power_of_two
  bool has_arb_depth_texture;            //GL_ARB_depth_texture

  TextureExtensions (const ContextManager&);
};

typedef xtl::shared_ptr<TextureExtensions> ExtensionsPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор слоя текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
struct LayerDesc
{
  GLenum target;    //тип текстуры
  size_t new_index; //индекс слоя в образе получаемом посредством glGetTexImage
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор mip-уровня текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
struct MipLevelDesc
{
  size_t width, height; //ширина / высота изображения на уровне
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый класс реализации текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture: virtual public IBindableTexture, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture  (const ContextManager&, const ExtensionsPtr& extensions, const TextureDesc& desc, GLenum target, size_t mips_count);
    ~Texture ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (TextureDesc&);
    void GetDesc (BindableTextureDesc&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение информации о текстуре
///////////////////////////////////////////////////////////////////////////////////////////////////
    GLenum      GetTarget    () const { return target; }     //получение типа текстуры
    GLuint      GetTextureId () const { return texture_id; } //получение идентификатора текстуры
    size_t      GetMipsCount () const { return mips_count; }  //получение количества mip-уровней
    PixelFormat GetFormat    () const { return desc.format; } //получение формата текстуры

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текстуры в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);
    
  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора mip-уровня текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetMipLevelDesc (size_t level, MipLevelDesc& desc);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Поддерживаемые расширения
///////////////////////////////////////////////////////////////////////////////////////////////////
    const TextureExtensions& GetExtensions () const { return *extensions; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Изменение формата текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetFormat (PixelFormat);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора слоя текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void GetLayerDesc (size_t layer, LayerDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                                      GLenum format, GLenum type, const void* buffer) = 0;
    virtual void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                                    GLenum format, size_t buffer_size, const void* buffer) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Генерация mip-уровней
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BuildMipmaps (size_t x, size_t y, size_t z, size_t width, size_t height, PixelFormat format, const void* data);
    
  private:
    GLenum        target;      //тип текстуры
    GLuint        texture_id;  //идентификатор текстуры
    TextureDesc   desc;        //дескриптор текстуры    
    size_t        mips_count;  //количество мип-уровней
    ExtensionsPtr extensions;  //поддерживаемые расширения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Одномерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture1D : public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture1D (const ContextManager&, const ExtensionsPtr& extensions, const TextureDesc& texture_desc);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Двумерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture2D : public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture2D (const ContextManager&, const ExtensionsPtr& extensions, const TextureDesc&);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текстура со сторонами не степени 2, работающая через расширение GL_EXT_texture_rectangle
///////////////////////////////////////////////////////////////////////////////////////////////////
class TextureNpot : public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextureNpot (const ContextManager&, const ExtensionsPtr& extensions, const TextureDesc& texture_desc);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Трёхмерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture3D : public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture3D (const ContextManager&, const ExtensionsPtr& extensions, const TextureDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Кубмап текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class TextureCubemap : public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextureCubemap (const ContextManager&, const ExtensionsPtr& extensions, const TextureDesc&);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора слоя текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetLayerDesc (size_t layer, LayerDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текстура со сторонами, масштабированными до ближайшей степени двойки
///////////////////////////////////////////////////////////////////////////////////////////////////
class ScaledTexture: virtual public IBindableTexture, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ScaledTexture (TextureManager& manager, const TextureDesc& original_desc, size_t scaled_width=0, size_t scaled_height=0);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (TextureDesc&);
    void GetDesc (BindableTextureDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текстуры в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  private:
    typedef xtl::com_ptr<IBindableTexture> TexturePtr;

  private:
    TexturePtr    shadow_texture;   //теневая текстура, со сторонами кратными степени двойки
    size_t        original_width;   //ширина оригинальной текстуры
    size_t        original_height;  //высота оригинальной текстуры
    float         horisontal_scale; //коэффициент растяжения по горизонтали
    float         vertical_scale;   //коэффициент растяжения по вертикали
    ExtensionsPtr extensions;       //поддерживаемые расширения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сэмплер
///////////////////////////////////////////////////////////////////////////////////////////////////
class SamplerState : virtual public ISamplerState, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SamplerState (const ContextManager& manager, const SamplerDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Выбор сэмплера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (OpenGLTextureTarget tex_target);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Изменение/получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDesc (const SamplerDesc&);
    void GetDesc (SamplerDesc&);

  private:
    SamplerDesc desc;           //дескриптор сэмплера
    int         display_list;   //номер первого списка команд конфигурации OpenGL (всего списков OpenGLTextureTarget_Num)
    size_t      max_anisotropy; //максимально возможная степень анизотропии
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Утилиты
///////////////////////////////////////////////////////////////////////////////////////////////////
size_t      get_next_higher_power_of_two        (size_t size);        //получение ближайшей сверху степени двойки
GLint       get_gl_internal_format              (PixelFormat format); //внутренний формат OpenGL
GLenum      get_gl_format                       (PixelFormat format); //формат OpenGL
GLenum      get_gl_type                         (PixelFormat format); //тип OpenGL
GLenum      get_uncompressed_gl_internal_format (PixelFormat format); //распакованный внутренний формат OpenGL
GLenum      get_uncompressed_gl_format          (PixelFormat format); //распакованный формат OpenGL
GLenum      get_uncompressed_gl_type            (PixelFormat format); //распакованный тип OpenGL
PixelFormat get_pixel_format                    (GLenum gl_format);   //эквивалент внутреннего формата OpenGL

///////////////////////////////////////////////////////////////////////////////////////////////////
///Масштабирование текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
void scale_image_2x_down (PixelFormat format, size_t width, size_t height, const void* src, void* dest);
void scale_image         (PixelFormat format, size_t width, size_t height, size_t new_width, size_t new_height, const void* src, void* dest);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с DXT форматом при остутствии аппаратной поддержки
///////////////////////////////////////////////////////////////////////////////////////////////////
void unpack_dxt (PixelFormat format, size_t width, size_t height, const void* dxt_data, void* unpacked_data);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Копирование изображений различных форматов
///////////////////////////////////////////////////////////////////////////////////////////////////
void copy_image (size_t pixels_count, PixelFormat src_format, const void* src_buffer, PixelFormat dst_format, void* dst_buffer);

}

}

}

#endif
