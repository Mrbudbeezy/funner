#ifndef RENDER_GL_DRIVER_TEXTURE_SHARED_HEADER
#define RENDER_GL_DRIVER_TEXTURE_SHARED_HEADER

#include <math.h>

#include <common/exception.h>
#include <common/hash.h>

#include <xtl/trackable_ptr.h>
#include <xtl/uninitialized_storage.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/shared_ptr.h>
#include <xtl/array>

#include <render/low_level/utils.h>

#include <shared/texture_manager.h>
#include <shared/context_object.h>

#include "nv_dxt/blockdxt.h"

namespace render
{

namespace low_level
{

namespace opengl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Идентификаторы элементов кэша контекстной таблицы
///////////////////////////////////////////////////////////////////////////////////////////////////
enum TextureManagerCache
{
  TextureManagerCache_ActiveSlot,
  TextureManagerCache_TextureId0,
  TextureManagerCache_TextureIdNum = TextureManagerCache_TextureId0 + DEVICE_SAMPLER_SLOTS_COUNT,
  TextureManagerCache_TextureTarget0,
  TextureManagerCache_TextureTargetNum = TextureManagerCache_TextureTarget0 + DEVICE_SAMPLER_SLOTS_COUNT,

  TextureManagerContextTable_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Расширения, поддерживаемые менеджером текстур
///////////////////////////////////////////////////////////////////////////////////////////////////
struct TextureExtensions
{  
  bool   has_ext_texture_compression_s3tc;   //GL_EXT_texture_compression_s3tc
  bool   has_sgis_generate_mipmap;           //GL_SGIS_generate_mipmap
  bool   has_ext_texture_rectangle;          //GL_EXT_texture_rectangle
  bool   has_ext_texture3d;                  //GL_EXT_texture3D
  bool   has_ext_packed_depth_stencil;       //GL_EXT_packed_depth_stencil
  bool   has_arb_multitexture;               //GL_ARB_multitexture
  bool   has_arb_texture_cube_map;           //GL_ARB_texture_cubemap
  bool   has_arb_texture_non_power_of_two;   //GL_ARB_texture_non_power_of_two
  bool   has_arb_depth_texture;              //GL_ARB_depth_texture
  bool   has_sgis_texture_lod;               //GL_SGIS_texture_lod
  bool   has_ext_texture_lod_bias;           //GL_EXT_texture_lod_bias
  bool   has_ext_texture_filter_anisotropic; //GL_EXT_texture_filter_anisotropic
  bool   has_ext_shadow_funcs;               //GL_EXT_shadow_funcs
  bool   has_arb_texture_border_clamp;       //GL_ARB_texture_border_clamp
  bool   has_arb_texture_mirrored_repeat;    //GL_ARB_texture_mirrored_repeat
  size_t max_anisotropy;                     //максимально возможная степень анизотропии

  TextureExtensions (const ContextManager&);
};

typedef xtl::shared_ptr<TextureExtensions> ExtensionsPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор слоя текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
struct LayerDesc
{
  GLenum target;    //тип текстуры
  size_t new_index; //индекс слоя в образе получаемом посредством glGetTexImage
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор текстуры устанавливамой в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
struct BindableTextureDesc
{
  size_t target; //целевой тип текстуры
  size_t id;     //идентификатор текстуры
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текстура устанавливаемая в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
class BindableTexture: virtual public ITexture, virtual public IRenderTargetTexture, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескрипторов
///////////////////////////////////////////////////////////////////////////////////////////////////
    using ITexture::GetDesc;
    using IRenderTargetTexture::GetDesc;
    
    virtual void GetDesc (BindableTextureDesc&) = 0;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текстуры в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Bind () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / получение хэша дескриптора прикрепленного сэмплера
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void   SetSamplerHash (size_t hash) = 0;
    virtual size_t GetSamplerHash () = 0;

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    BindableTexture (const ContextManager& context_manager) : ContextObject (context_manager) {}      
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый класс реализации текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture: public BindableTexture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc         (TextureDesc&);
    void GetDesc         (RenderTargetTextureDesc&);
    void GetDesc         (BindableTextureDesc&); 
    void GetMipLevelDesc (size_t level, MipLevelDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение информации о текстуре
///////////////////////////////////////////////////////////////////////////////////////////////////
    GLenum      GetTarget    () const { return target; }      //получение типа текстуры
    GLuint      GetTextureId () const { return texture_id; }  //получение идентификатора текстуры
    size_t      GetMipsCount () const { return mips_count; }  //получение количества mip-уровней
    PixelFormat GetFormat    () const { return desc.format; } //получение формата текстуры

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / получение хэша дескриптора прикрепленного сэмплера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void   SetSamplerHash (size_t hash);
    size_t GetSamplerHash ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текстуры в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);
    
  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture  (const ContextManager&, const ExtensionsPtr& extensions, const TextureDesc& desc, GLenum target, size_t mips_count);
    ~Texture ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Поддерживаемые расширения
///////////////////////////////////////////////////////////////////////////////////////////////////
    const TextureExtensions& GetExtensions () const { return *extensions; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Изменение формата текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetFormat (PixelFormat);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора слоя текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void GetLayerDesc (size_t layer, LayerDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                                      GLenum format, GLenum type, const void* buffer) = 0;
    virtual void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                                    GLenum format, size_t buffer_size, const void* buffer) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Генерация mip-уровней
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BuildMipmaps (size_t x, size_t y, size_t z, size_t width, size_t height, PixelFormat format, const void* data);
    
  private:
    TextureDesc   desc;                //дескриптор текстуры  
    GLenum        target;              //тип текстуры
    GLuint        texture_id;          //идентификатор текстуры
    size_t        mips_count;          //количество мип-уровней
    size_t        binded_sampler_hash; //хэш дескриптора прикрепленного сэмплера
    ExtensionsPtr extensions;          //поддерживаемые расширения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Одномерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture1D: public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture1D (const ContextManager&, const ExtensionsPtr& extensions, const TextureDesc& texture_desc);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Двумерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture2D: public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture2D (const ContextManager&, const ExtensionsPtr& extensions, const TextureDesc&);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текстура со сторонами не степени 2, работающая через расширение GL_EXT_texture_rectangle
///////////////////////////////////////////////////////////////////////////////////////////////////
class TextureNpot: public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextureNpot (const ContextManager&, const ExtensionsPtr& extensions, const TextureDesc& texture_desc);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Трёхмерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture3D : public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture3D (const ContextManager&, const ExtensionsPtr& extensions, const TextureDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Кубмап текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class TextureCubemap : public Texture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextureCubemap (const ContextManager&, const ExtensionsPtr& extensions, const TextureDesc&);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора слоя текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetLayerDesc (size_t layer, LayerDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUncompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                              GLenum format, GLenum type, const void* buffer);
    void SetCompressedData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height,
                            GLenum format, size_t buffer_size, const void* buffer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текстура со сторонами, масштабированными до ближайшей степени двойки
///////////////////////////////////////////////////////////////////////////////////////////////////
class ScaledTexture: public BindableTexture
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ScaledTexture (const ContextManager&, TextureManager&, const TextureDesc& original_desc, size_t scaled_width=0, size_t scaled_height=0);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc         (TextureDesc&);
    void GetDesc         (RenderTargetTextureDesc&);
    void GetDesc         (BindableTextureDesc&);
    void GetMipLevelDesc (size_t level, MipLevelDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / получение хэша дескриптора прикрепленного сэмплера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void   SetSamplerHash (size_t hash);
    size_t GetSamplerHash ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текстуры в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  private:
    typedef xtl::com_ptr<BindableTexture> TexturePtr;

  private:
    TexturePtr    shadow_texture;   //теневая текстура, со сторонами кратными степени двойки
    size_t        original_width;   //ширина оригинальной текстуры
    size_t        original_height;  //высота оригинальной текстуры
    float         horisontal_scale; //коэффициент растяжения по горизонтали
    float         vertical_scale;   //коэффициент растяжения по вертикали
    ExtensionsPtr extensions;       //поддерживаемые расширения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сэмплер
///////////////////////////////////////////////////////////////////////////////////////////////////
class SamplerState : virtual public ISamplerState, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SamplerState (const ContextManager& manager, const ExtensionsPtr& extensions, const SamplerDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Выбор сэмплера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (GLenum texture_target);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Изменение/получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDesc (const SamplerDesc&);
    void GetDesc (SamplerDesc&);    

    size_t GetDescHash () const { return desc_hash; }

  private:
    SamplerDesc   desc;         //дескриптор сэмплера
    size_t        desc_hash;    //хэш дескриптора
    int           display_list; //номер первого списка команд конфигурации OpenGL (всего списков OpenGLTextureTarget_Num)
    ExtensionsPtr extensions;   //поддерживаемые расширения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Утилиты
///////////////////////////////////////////////////////////////////////////////////////////////////
size_t      get_next_higher_power_of_two        (size_t size);        //получение ближайшей сверху степени двойки
GLint       get_gl_internal_format              (PixelFormat format); //внутренний формат OpenGL
GLenum      get_gl_format                       (PixelFormat format); //формат OpenGL
GLenum      get_gl_type                         (PixelFormat format); //тип OpenGL
GLenum      get_uncompressed_gl_internal_format (PixelFormat format); //распакованный внутренний формат OpenGL
GLenum      get_uncompressed_gl_format          (PixelFormat format); //распакованный формат OpenGL
GLenum      get_uncompressed_gl_type            (PixelFormat format); //распакованный тип OpenGL
PixelFormat get_pixel_format                    (GLenum gl_format);   //эквивалент внутреннего формата OpenGL

///////////////////////////////////////////////////////////////////////////////////////////////////
///Масштабирование текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
void scale_image_2x_down (PixelFormat format, size_t width, size_t height, const void* src, void* dest);
void scale_image         (PixelFormat format, size_t width, size_t height, size_t new_width, size_t new_height, const void* src, void* dest);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с DXT форматом при остутствии аппаратной поддержки
///////////////////////////////////////////////////////////////////////////////////////////////////
void unpack_dxt (PixelFormat format, size_t width, size_t height, const void* dxt_data, void* unpacked_data);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Копирование изображений различных форматов
///////////////////////////////////////////////////////////////////////////////////////////////////
void copy_image (size_t pixels_count, PixelFormat src_format, const void* src_buffer, PixelFormat dst_format, void* dst_buffer);

}

}

}

#endif
