#ifndef RENDER_GL_DRIVER_OUTPUT_STAGE_SHARED_HEADER
#define RENDER_GL_DRIVER_OUTPUT_STAGE_SHARED_HEADER

#include <memory.h>

#include <render/low_level/utils.h>

#include <shared/output_stage.h>
#include <shared/context_object.h>
#include <shared/object.h>
#include <shared/trackable.h>
#include <shared/texture_manager.h>
#include <shared/platform/swap_chain_manager.h>

#include <stl/list>

#include <xtl/intrusive_ptr.h>
#include <xtl/trackable_ptr.h>
#include <xtl/bind.h>
#include <xtl/uninitialized_storage.h>

#include <common/exception.h>

namespace render
{

namespace low_level
{

namespace opengl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер цвета
///////////////////////////////////////////////////////////////////////////////////////////////////
class ColorBuffer: virtual public ITexture, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (TextureDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ColorBuffer (const ContextManager&);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Bind () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение размеров буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void GetSize (size_t& width, size_t& height) = 0;

  private:
    TextureDesc desc; //дескриптор текстуры
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер глубина-трафарет
///////////////////////////////////////////////////////////////////////////////////////////////////
class DepthStencilBuffer: virtual public ITexture, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (TextureDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    DepthStencilBuffer (const ContextManager&);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Bind () = 0;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение размеров буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void GetSize (size_t& width, size_t& height) = 0;    

  private:
    TextureDesc desc; //дескриптор текстуры
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер цвета цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainColorBuffer: public ColorBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainColorBuffer (const ContextManager& manager, ISwapChain* swap_chain, size_t buffer_index);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Цепочка обмена и gl-имя буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    ISwapChain* GetSwapChain   () const { return swap_chain.get (); }
    size_t      GetBufferIndex () const { return buffer_index; }
    GLenum      GetBufferType  () const { return buffer_type; }

  private:
    void Bind ();
    void GetSize (size_t& width, size_t& height);

  private:
    typedef xtl::com_ptr<ISwapChain> SwapChainPtr;

  private:
    SwapChainPtr swap_chain;   //цепочка обмена
    size_t       buffer_index; //индекс буфера обмена в цепочке обмена
    GLenum       buffer_type;  //тип буфера
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер глубины-трафарета цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainDepthStencilBuffer: public DepthStencilBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainDepthStencilBuffer  (const ContextManager& manager, ISwapChain* swap_chain);
    ~SwapChainDepthStencilBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Идентификатор контекста
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetContextId () const { return context_id; }

  private:
    void Bind ();
    void GetSize (size_t& width, size_t& height);

  private:
    typedef xtl::com_ptr<ISwapChain> SwapChainPtr;

  private:
    SwapChainPtr swap_chain; //цепочка обмена
    size_t       context_id; //индентификатор контекста
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип, используемый для указания отсутствия отображения при создания буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
struct NullView {};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип отображения
///////////////////////////////////////////////////////////////////////////////////////////////////
enum ViewType
{
  ViewType_Null,                        //отображение отсутствует
  ViewType_SwapChainColorBuffer,        //отображение на буфер цвета цепочки обмена
  ViewType_SwapChainDepthStencilBuffer, //отображение на буфер глубина-трафарет цепочки обмена
  ViewType_Texture,                     //отображение на текстуру
//  ViewType_RenderBuffer  //отображение построено на буфер отрисовки или буфер кадра
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отображение
///////////////////////////////////////////////////////////////////////////////////////////////////
class View: virtual public IView, public Object, public Trackable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    View (ITexture* texture, const ViewDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип отображения
///////////////////////////////////////////////////////////////////////////////////////////////////
    ViewType GetType () { return type; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение целевых объектов отображения
///////////////////////////////////////////////////////////////////////////////////////////////////
    ITexture*                    GetTexture                     () { return base_texture.get (); }
    IBindableTexture*            GetBindableTexture             () { return bindable_texture.get (); }
    SwapChainColorBuffer*        GetSwapChainColorBuffer        () { return color_buffer.get (); }
    SwapChainDepthStencilBuffer* GetSwapChainDepthStencilBuffer () { return depth_stencil_buffer.get (); }
//    RenderBuffer*      GetRenderBuffer    () { return render_buffer.get (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (ViewDesc&);

  private:
    typedef xtl::com_ptr<ITexture>                    TexturePtr;
    typedef xtl::com_ptr<IBindableTexture>            BindableTexturePtr;
    typedef xtl::com_ptr<SwapChainColorBuffer>        ColorBufferPtr;
    typedef xtl::com_ptr<SwapChainDepthStencilBuffer> DepthStencilBufferPtr;

  private:
    ViewType              type;                 //тип отображения
    TexturePtr            base_texture;         //указатель на базовую текстуру
    BindableTexturePtr    bindable_texture;     //текстура
    ColorBufferPtr        color_buffer;         //буфера цвета цепочки обмена
    DepthStencilBufferPtr depth_stencil_buffer; //буфер глубина-трафарет цепочки обмена
    ViewDesc              desc;                 //дескриптор отображения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class FrameBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////  
    virtual ~FrameBuffer () {}
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Bind () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление целевых буферов отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void UpdateRenderTargets () = 0;    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Абстрактаня фабрика ресурсов выходного подуровня OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
class OutputStageResourceFactory
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual ~OutputStageResourceFactory () {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание целевых буферов вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual ITexture* CreateTexture             (const TextureDesc&) = 0;
    virtual ITexture* CreateRenderTargetTexture (ISwapChain* swap_chain, size_t buffer_index) = 0;
    virtual ITexture* CreateDepthStencilTexture (ISwapChain* swap_chain) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание фрейм буферов
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual FrameBuffer* CreateFrameBuffer (NullView, NullView) = 0;
    virtual FrameBuffer* CreateFrameBuffer (NullView, SwapChainDepthStencilBuffer*) = 0;
    virtual FrameBuffer* CreateFrameBuffer (NullView, IBindableTexture*) = 0;
    virtual FrameBuffer* CreateFrameBuffer (SwapChainColorBuffer*, NullView) = 0;
    virtual FrameBuffer* CreateFrameBuffer (SwapChainColorBuffer*, SwapChainDepthStencilBuffer*) = 0;
    virtual FrameBuffer* CreateFrameBuffer (SwapChainColorBuffer*, IBindableTexture*) = 0;
    virtual FrameBuffer* CreateFrameBuffer (IBindableTexture*, NullView) = 0;
    virtual FrameBuffer* CreateFrameBuffer (IBindableTexture*, SwapChainDepthStencilBuffer*) = 0;
    virtual FrameBuffer* CreateFrameBuffer (IBindableTexture*, IBindableTexture*) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание фабрик
///////////////////////////////////////////////////////////////////////////////////////////////////
    static OutputStageResourceFactory* CreateDefaultFactory (const ContextManager&);
    static OutputStageResourceFactory* CreateFboFactory     (const ContextManager&, OutputStageResourceFactory* default_factory);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние подуровня смешивания цветов
///////////////////////////////////////////////////////////////////////////////////////////////////
class BlendState: virtual public IBlendState, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    BlendState  (const ContextManager&, const BlendDesc&);
    ~BlendState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка/изменение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDesc (const BlendDesc&);
    void GetDesc (BlendDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка состояния в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

  private:
    BlendDesc desc;         //дескриптор состояния
    int       display_list; //номер списка команд конфигурации OpenGL
};

}

}

}

#endif
