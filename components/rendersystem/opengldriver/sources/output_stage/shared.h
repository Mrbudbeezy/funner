#ifndef RENDER_GL_DRIVER_OUTPUT_STAGE_SHARED_HEADER
#define RENDER_GL_DRIVER_OUTPUT_STAGE_SHARED_HEADER

#include <memory.h>

#include <render/low_level/utils.h>

#include <shared/output_stage.h>
#include <shared/context_object.h>
#include <shared/object.h>
#include <shared/trackable.h>
#include <shared/platform/swap_chain_manager.h>

#include <xtl/intrusive_ptr.h>
#include <xtl/bind.h>

#include <common/exception.h>

namespace render
{

namespace low_level
{

namespace opengl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние подуровня смешивания цветов
///////////////////////////////////////////////////////////////////////////////////////////////////
class BlendState: virtual public IBlendState, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    BlendState  (const ContextManager&, const BlendDesc&);
    ~BlendState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка/изменение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDesc (const BlendDesc&);
    void GetDesc (BlendDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка состояния в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

  private:
    BlendDesc desc;         //дескриптор состояния
    int       display_list; //номер списка команд конфигурации OpenGL
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отображение
///////////////////////////////////////////////////////////////////////////////////////////////////
class View: public IView, public Object, public Trackable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    View (ITexture* texture, const ViewDesc& desc);
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Текстура, на которую строится отображение
///////////////////////////////////////////////////////////////////////////////////////////////////
    ITexture* GetTexture ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (ViewDesc&);

  private:
    typedef xtl::com_ptr<ITexture> TexturePtr;

  private:
    TexturePtr texture; //текстура
    ViewDesc   desc;    //дескриптор отображения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерфейс менеджера целевых буферов отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
class IRenderTargetsManager
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Выбор целевых отображений
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void    SetRenderTargets    (IView* render_target_view, IView* depth_stencil_view);
    virtual IView*  GetRenderTargetView () const;
    virtual IView*  GetDepthStencilView () const;  
};

}

}

}

#endif
