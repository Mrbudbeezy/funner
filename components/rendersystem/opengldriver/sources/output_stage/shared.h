#ifndef RENDER_GL_DRIVER_OUTPUT_STAGE_SHARED_HEADER
#define RENDER_GL_DRIVER_OUTPUT_STAGE_SHARED_HEADER

#include <memory.h>

#include <render/low_level/utils.h>

#include <shared/output_stage.h>
#include <shared/context_object.h>
#include <shared/object.h>
#include <shared/trackable.h>
#include <shared/texture_manager.h>
#include <shared/platform/swap_chain_manager.h>

#include <stl/list>

#include <xtl/intrusive_ptr.h>
#include <xtl/trackable_ptr.h>
#include <xtl/bind.h>
#include <xtl/uninitialized_storage.h>

#include <common/exception.h>

namespace render
{

namespace low_level
{

namespace opengl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер цвета
///////////////////////////////////////////////////////////////////////////////////////////////////
class ColorBuffer: virtual public ITexture, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (TextureDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ColorBuffer (const ContextManager&);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Bind () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение размеров буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void GetSize (size_t& width, size_t& height) = 0;

  private:
    TextureDesc desc; //дескриптор текстуры
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер глубина-трафарет
///////////////////////////////////////////////////////////////////////////////////////////////////
class DepthStencilBuffer: virtual public ITexture, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (TextureDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    DepthStencilBuffer (const ContextManager&);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Bind () = 0;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение размеров буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void GetSize (size_t& width, size_t& height) = 0;    

  private:
    TextureDesc desc; //дескриптор текстуры
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер цвета цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainColorBuffer: public ColorBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainColorBuffer (const ContextManager& manager, ISwapChain* swap_chain, size_t buffer_index);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Цепочка обмена и номер буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    ISwapChain* GetSwapChain   () const { return swap_chain.get (); }
    size_t      GetBufferIndex () const { return buffer_index; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип буфера
///////////////////////////////////////////////////////////////////////////////////////////////////    
    GLenum GetBufferType () const { return buffer_type; }

  private:
    void Bind ();
    void GetSize (size_t& width, size_t& height);

  private:
    typedef xtl::com_ptr<ISwapChain> SwapChainPtr;

  private:
    SwapChainPtr swap_chain;   //цепочка обмена
    size_t       buffer_index; //индекс буфера обмена в цепочке обмена
    GLenum       buffer_type; //тип буфера    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер глубины-трафарета цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainDepthStencilBuffer: public DepthStencilBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainDepthStencilBuffer  (const ContextManager& manager, ISwapChain* swap_chain);
    SwapChainDepthStencilBuffer  (const ContextManager& manager, ISwapChain* swap_chain, size_t width, size_t height);
    ~SwapChainDepthStencilBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Идентификатор контекста
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetContextId () const { return context_id; }

  private:
    void Bind ();
    void GetSize (size_t& width, size_t& height);

  private:
    size_t context_id;    //идентификатор контекста
    size_t width, height; //размеры буфера
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип, используемый для указания отсутствия отображения при создания буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
struct NullView {};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип отображения
///////////////////////////////////////////////////////////////////////////////////////////////////
enum ViewType
{
  ViewType_Null,                        //отображение отсутствует
  ViewType_SwapChainColorBuffer,        //отображение на буфер цвета цепочки обмена
  ViewType_SwapChainDepthStencilBuffer, //отображение на буфер глубина-трафарет цепочки обмена
  ViewType_Texture,                     //отображение на текстуру
//  ViewType_RenderBuffer  //отображение построено на буфер отрисовки или буфер кадра
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отображение
///////////////////////////////////////////////////////////////////////////////////////////////////
class View: virtual public IView, public Object, public Trackable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    View (ITexture* texture, const ViewDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип отображения
///////////////////////////////////////////////////////////////////////////////////////////////////
    ViewType GetType () { return type; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение целевых объектов отображения
///////////////////////////////////////////////////////////////////////////////////////////////////
    ITexture*                    GetTexture                     () { return base_texture.get (); }
    IBindableTexture*            GetBindableTexture             () { return bindable_texture.get (); }
    SwapChainColorBuffer*        GetSwapChainColorBuffer        () { return color_buffer.get (); }
    SwapChainDepthStencilBuffer* GetSwapChainDepthStencilBuffer () { return depth_stencil_buffer.get (); }
//    RenderBuffer*      GetRenderBuffer    () { return render_buffer.get (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (ViewDesc&);

  private:
    typedef xtl::com_ptr<ITexture>                    TexturePtr;
    typedef xtl::com_ptr<IBindableTexture>            BindableTexturePtr;
    typedef xtl::com_ptr<SwapChainColorBuffer>        ColorBufferPtr;
    typedef xtl::com_ptr<SwapChainDepthStencilBuffer> DepthStencilBufferPtr;

  private:
    ViewType              type;                 //тип отображения
    TexturePtr            base_texture;         //указатель на базовую текстуру
    BindableTexturePtr    bindable_texture;     //текстура
    ColorBufferPtr        color_buffer;         //буфера цвета цепочки обмена
    DepthStencilBufferPtr depth_stencil_buffer; //буфер глубина-трафарет цепочки обмена
    ViewDesc              desc;                 //дескриптор отображения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class FrameBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////  
    virtual ~FrameBuffer () {}
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Bind (bool& color_buffer_state, bool& depth_stencil_buffer_state) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление целевых буферов отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void UpdateRenderTargets () = 0;    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация буфера кадра для цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainFrameBuffer: public FrameBuffer, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainFrameBuffer (const ContextManager&        manager,
                          SwapChainColorBuffer*        color_buffer,
                          SwapChainDepthStencilBuffer* depth_stencil_buffer);
                          
///////////////////////////////////////////////////////////////////////////////////////////////////
///Разрешение / запрещение буферов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetBuffersState            (bool color_buffer_state, bool depth_stencil_buffer_state);
    bool GetColorBufferState        () const { return color_buffer_state; }
    bool GetDepthStencilBufferState () const { return depth_stencil_buffer_state; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (bool&, bool&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с текстурами
///////////////////////////////////////////////////////////////////////////////////////////////////
    void              SetRenderTargets       (IBindableTexture*, const ViewDesc*, IBindableTexture*, const ViewDesc*);
    IBindableTexture* GetRenderTargetTexture () const { return render_target_texture.get (); }
    IBindableTexture* GetDepthStencilTexture () const { return depth_stencil_texture.get (); }
    const ViewDesc&   GetRenderTargetDesc    () const { return render_target_desc; }
    const ViewDesc&   GetDepthStencilDesc    () const { return depth_stencil_desc; }
    void              UpdateRenderTargets    ();

  private:
    typedef xtl::com_ptr<SwapChainColorBuffer>        ColorBufferPtr;
    typedef xtl::com_ptr<SwapChainDepthStencilBuffer> DepthStencilBufferPtr;
    typedef xtl::com_ptr<IBindableTexture>            TexturePtr;

  private:
    ColorBufferPtr        color_buffer;
    DepthStencilBufferPtr depth_stencil_buffer;
    TexturePtr            render_target_texture;
    TexturePtr            depth_stencil_texture;
    ViewDesc              render_target_desc;
    ViewDesc              depth_stencil_desc;    
    bool                  color_buffer_state;
    bool                  depth_stencil_buffer_state;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class FrameBufferManager: public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FrameBufferManager  (const ContextManager& manager, ISwapChain* default_swap_chain);
    ~FrameBufferManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение цепочки обмена по умолчанию
///////////////////////////////////////////////////////////////////////////////////////////////////
    ISwapChain* GetDefaultSwapChain () const { return default_swap_chain.get (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание целевых буферов вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    ITexture* CreateTexture             (const TextureDesc&);
    ITexture* CreateRenderTargetTexture (ISwapChain* swap_chain, size_t buffer_index);
    ITexture* CreateDepthStencilTexture (ISwapChain* swap_chain);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Диспетчер создания буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    FrameBuffer* CreateFrameBuffer (View* render_target_view, View* depth_stencil_view);

  private:
    typedef xtl::com_ptr<SwapChainColorBuffer>        ColorBufferPtr;
    typedef xtl::com_ptr<SwapChainDepthStencilBuffer> DepthStencilBufferPtr;

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Промежуточные диспетчеры создания буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T>
    FrameBuffer* CreateFrameBufferImpl (const T& render_target, const ViewDesc& render_target_desc, View* depth_stencil_view);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    FrameBuffer* CreateFrameBuffer (NullView, const ViewDesc&, NullView, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (NullView, const ViewDesc&, SwapChainDepthStencilBuffer*, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (NullView, const ViewDesc&, IBindableTexture*, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (SwapChainColorBuffer*, const ViewDesc&, NullView, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (SwapChainColorBuffer*, const ViewDesc&, SwapChainDepthStencilBuffer*, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (SwapChainColorBuffer*, const ViewDesc&, IBindableTexture*, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (IBindableTexture*, const ViewDesc&, NullView, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (IBindableTexture*, const ViewDesc&, SwapChainDepthStencilBuffer*, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (IBindableTexture*, const ViewDesc&, IBindableTexture*, const ViewDesc&);
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с теневыми буферами
///////////////////////////////////////////////////////////////////////////////////////////////////
    ColorBufferPtr        GetShadowBuffer          (SwapChainDepthStencilBuffer*);
    DepthStencilBufferPtr GetShadowBuffer          (SwapChainColorBuffer*);
    void                  GetShadowBuffers         (ColorBufferPtr&, DepthStencilBufferPtr&);
    ColorBufferPtr        CreateColorBuffer        (SwapChainDepthStencilBuffer*);
    DepthStencilBufferPtr CreateDepthStencilBuffer (SwapChainColorBuffer*);
    SwapChainFrameBuffer* CreateShadowFrameBuffer  ();

  private:
    typedef stl::list<SwapChainColorBuffer*>        ColorBufferList;
    typedef stl::list<SwapChainDepthStencilBuffer*> DepthStencilBufferList;
    typedef xtl::com_ptr<ISwapChain>                SwapChainPtr;

  private:
    SwapChainPtr           default_swap_chain;
    ColorBufferList        shadow_color_buffers;
    DepthStencilBufferList shadow_depth_stencil_buffers;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние подуровня смешивания цветов
///////////////////////////////////////////////////////////////////////////////////////////////////
class BlendState: virtual public IBlendState, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    BlendState  (const ContextManager&, const BlendDesc&);
    ~BlendState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка/изменение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDesc (const BlendDesc&);
    void GetDesc (BlendDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка состояния в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

  private:
    BlendDesc desc;         //дескриптор состояния
    int       display_list; //номер списка команд конфигурации OpenGL
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние подуровня попиксельного отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
class DepthStencilState: virtual public IDepthStencilState, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    DepthStencilState  (const ContextManager&, const DepthStencilDesc&);
    ~DepthStencilState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка/изменение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDesc (const DepthStencilDesc&);
    void GetDesc (DepthStencilDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка состояния в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (size_t stencil_reference);

  private:
    DepthStencilDesc desc;                           //дескриптор состояния
    int              display_list;                   //номер списка команд конфигурации OpenGL
    GLenum           gl_stencil_func [FaceMode_Num]; //функции отсечения трафарета
    bool             need_two_side_stencil;          //состояние требует двустороннего трафарета
};

}

}

}

#endif
