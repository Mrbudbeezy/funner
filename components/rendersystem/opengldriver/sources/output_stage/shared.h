#ifndef RENDER_GL_DRIVER_OUTPUT_STAGE_SHARED_HEADER
#define RENDER_GL_DRIVER_OUTPUT_STAGE_SHARED_HEADER

#include <memory.h>

#include <render/low_level/utils.h>

#include <shared/output_stage.h>
#include <shared/context_object.h>
#include <shared/object.h>
#include <shared/texture_manager.h>
#include <shared/platform/swap_chain_manager.h>

#include <stl/list>

#include <xtl/intrusive_ptr.h>
#include <xtl/trackable_ptr.h>
#include <xtl/bind.h>
#include <xtl/uninitialized_storage.h>

#include <common/exception.h>
#include <common/hash.h>

namespace render
{

namespace low_level
{

namespace opengl
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Элементы таблицы локальных данных контекста
///////////////////////////////////////////////////////////////////////////////////////////////////
enum OutputStageCache
{
  OutputStageCache_FrameBufferId,         //идентификатор текущего буфера кадра
  OutputStageCache_BlendStateHash,        //хэш состояния подуровня смешивания цветов
  OutputStageCache_DepthStencilStateHash, //хэш состояния подуровня попиксельного отсечения
  OutputStageCache_StencilReference,      //ссылочное значение теста трафарета
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип цели рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
enum RenderTargetType
{
  RenderTargetType_Color,        //буфер цвета
  RenderTargetType_DepthStencil, //буфер глубина-трафарет
  
  RenderTargetType_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderBuffer: virtual public ITexture, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение типа цели рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTargetType GetTargetType () const { return target_type; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat source_format, const void* buffer);
    void GetData (size_t layer, size_t mip_level, size_t x, size_t y, size_t width, size_t height, PixelFormat target_format, void* buffer);

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderBuffer (const ContextManager&, RenderTargetType target_typ);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Bind () = 0;

  private:
    RenderTargetType target_type;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер рендеринг цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainRenderBuffer: public RenderBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (TextureDesc&);

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainRenderBuffer (const ContextManager&, RenderTargetType target);
    
  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение размеров буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void GetSize (size_t& width, size_t& height) = 0;  
  
  private:
    TextureDesc desc;   //дескриптор текстуры  
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер цвета цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainColorBuffer: public SwapChainRenderBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainColorBuffer (const ContextManager& manager, ISwapChain* swap_chain, size_t buffer_index);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Цепочка обмена и номер буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    ISwapChain* GetSwapChain   () const { return swap_chain.get (); }
    size_t      GetBufferIndex () const { return buffer_index; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип буфера
///////////////////////////////////////////////////////////////////////////////////////////////////    
    GLenum GetBufferType () const { return buffer_type; }

  private:
    void Bind ();
    void GetSize (size_t& width, size_t& height);

  private:
    typedef xtl::com_ptr<ISwapChain> SwapChainPtr;

  private:
    SwapChainPtr swap_chain;   //цепочка обмена
    size_t       buffer_index; //индекс буфера обмена в цепочке обмена
    GLenum       buffer_type;  //тип буфера    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер глубины-трафарета цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainDepthStencilBuffer: public SwapChainRenderBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainDepthStencilBuffer  (const ContextManager& manager, ISwapChain* swap_chain);
    SwapChainDepthStencilBuffer  (const ContextManager& manager, ISwapChain* swap_chain, size_t width, size_t height);
    ~SwapChainDepthStencilBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Идентификатор контекста
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetContextId () const { return context_id; }

  private:
    void Bind ();
    void GetSize (size_t& width, size_t& height);

  private:
    size_t context_id;    //идентификатор контекста
    size_t width, height; //размеры буфера
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер отрисовки, создаваемый посредством расширения EXT_framebuffer_object
///////////////////////////////////////////////////////////////////////////////////////////////////
class FboRenderBuffer: public RenderBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FboRenderBuffer  (const ContextManager& manager, PixelFormat format, size_t width, size_t height);
    ~FboRenderBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Внутренний OpenGL идентификатор буфера рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    int GetRenderBufferId () const { return render_buffer_id; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (TextureDesc&);
    
  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (); 

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение OpenGL идентификатора буфера кадра для возможности ручной записи / чтения данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetFrameBufferId ();

  private:
    size_t      render_buffer_id; //идентификатор буфера рендеринга
    size_t      frame_buffer_id;  //идентификатор буфера кадра, используемого для установки/чтения данных
    TextureDesc desc;             //дескриптор буфера
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип, используемый для указания отсутствия отображения при создания буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
struct NullView {};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип отображения
///////////////////////////////////////////////////////////////////////////////////////////////////
enum ViewType
{
  ViewType_Null,                        //отображение отсутствует
  ViewType_SwapChainColorBuffer,        //отображение на буфер цвета цепочки обмена
  ViewType_SwapChainDepthStencilBuffer, //отображение на буфер глубина-трафарет цепочки обмена
  ViewType_RenderTargetTexture,         //отображение на текстуру
  ViewType_FboRenderBuffer              //отображение на frame_buffer_object render-buffer
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отображение
///////////////////////////////////////////////////////////////////////////////////////////////////
class View: virtual public IView, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    View (ITexture* texture, const ViewDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип отображения
///////////////////////////////////////////////////////////////////////////////////////////////////
    ViewType GetType () { return type; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение целевых объектов отображения
///////////////////////////////////////////////////////////////////////////////////////////////////
    ITexture*                    GetTexture                     () { return base_texture.get (); }
    IRenderTargetTexture*        GetRenderTargetTexture         () { return render_target_texture.get (); }
    SwapChainColorBuffer*        GetSwapChainColorBuffer        () { return color_buffer.get (); }
    SwapChainDepthStencilBuffer* GetSwapChainDepthStencilBuffer () { return depth_stencil_buffer.get (); }
    FboRenderBuffer*             GetFboRenderBuffer             () { return fbo_render_buffer.get (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (ViewDesc&);

  private:
    typedef xtl::com_ptr<ITexture>                    TexturePtr;
    typedef xtl::com_ptr<IRenderTargetTexture>        RenderTargetTexturePtr;
    typedef xtl::com_ptr<SwapChainColorBuffer>        ColorBufferPtr;
    typedef xtl::com_ptr<SwapChainDepthStencilBuffer> DepthStencilBufferPtr;
    typedef xtl::com_ptr<FboRenderBuffer>             FboRenderBufferPtr;

  private:
    ViewType                type;                  //тип отображения
    TexturePtr              base_texture;          //указатель на базовую текстуру
    RenderTargetTexturePtr  render_target_texture; //текстура
    ColorBufferPtr          color_buffer;          //буфера цвета цепочки обмена
    DepthStencilBufferPtr   depth_stencil_buffer;  //буфер глубина-трафарет цепочки обмена
    FboRenderBufferPtr      fbo_render_buffer;     //буфер рендеринга
    ViewDesc                desc;                  //дескриптор отображения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class FrameBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////  
    virtual ~FrameBuffer () {}
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Bind (bool& color_buffer_state, bool& depth_stencil_buffer_state) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление целевых буферов отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void UpdateRenderTargets () = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация буфера кадра для цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainFrameBuffer: public FrameBuffer, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainFrameBuffer (const ContextManager&        manager,
                          SwapChainColorBuffer*        color_buffer,
                          SwapChainDepthStencilBuffer* depth_stencil_buffer);
                          
///////////////////////////////////////////////////////////////////////////////////////////////////
///Разрешение / запрещение буферов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetBuffersState            (bool color_buffer_state, bool depth_stencil_buffer_state);
    bool GetColorBufferState        () const { return color_buffer_state; }
    bool GetDepthStencilBufferState () const { return depth_stencil_buffer_state; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (bool&, bool&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с текстурами
///////////////////////////////////////////////////////////////////////////////////////////////////
    void              SetRenderTargets       (IRenderTargetTexture*, const ViewDesc*, IRenderTargetTexture*, const ViewDesc*);
    IRenderTargetTexture* GetRenderTargetTexture () const { return render_target_texture.get (); }
    IRenderTargetTexture* GetDepthStencilTexture () const { return depth_stencil_texture.get (); }
    const ViewDesc&   GetRenderTargetDesc    () const { return render_target_desc; }
    const ViewDesc&   GetDepthStencilDesc    () const { return depth_stencil_desc; }
    void              UpdateRenderTargets    ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Копирование изображения в текстуру
///////////////////////////////////////////////////////////////////////////////////////////////////
    void CopyImage (size_t width, size_t height, const RenderTargetTextureDesc& texture_desc, const ViewDesc& view_desc);

  private:
    typedef xtl::com_ptr<SwapChainColorBuffer>        ColorBufferPtr;
    typedef xtl::com_ptr<SwapChainDepthStencilBuffer> DepthStencilBufferPtr;
    typedef xtl::com_ptr<IRenderTargetTexture>            TexturePtr;

  private:
    ColorBufferPtr        color_buffer;
    DepthStencilBufferPtr depth_stencil_buffer;
    TexturePtr            render_target_texture;
    TexturePtr            depth_stencil_texture;
    ViewDesc              render_target_desc;
    ViewDesc              depth_stencil_desc;    
    bool                  color_buffer_state;
    bool                  depth_stencil_buffer_state;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый класс буфера кадра на основе расширения EXT_framebuffer_object
///////////////////////////////////////////////////////////////////////////////////////////////////
class FboFrameBufferBase: public FrameBuffer, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////  
    ~FboFrameBufferBase ();  

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение OpenGL идентификатора буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetFrameBufferId () const { return id; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (bool& color_buffer_state, bool& depth_stencil_buffer_state);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление целевых буферов отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateRenderTargets () {}

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FboFrameBufferBase (const ContextManager&, bool color_buffer_state, bool depth_stencil_buffer_state);

  private:
    size_t id;
    bool   color_buffer_state;
    bool   depth_stencil_buffer_state;    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер кадра на основе расширения EXT_framebuffer_object
///////////////////////////////////////////////////////////////////////////////////////////////////
class FboFrameBuffer: public FboFrameBufferBase
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    FboFrameBuffer (const ContextManager&, NullView, FboRenderBuffer*);
    FboFrameBuffer (const ContextManager&, NullView, IRenderTargetTexture*, const ViewDesc&);
    FboFrameBuffer (const ContextManager&, FboRenderBuffer*, NullView);
    FboFrameBuffer (const ContextManager&, FboRenderBuffer*, FboRenderBuffer*);
    FboFrameBuffer (const ContextManager&, FboRenderBuffer*, IRenderTargetTexture*, const ViewDesc&);
    FboFrameBuffer (const ContextManager&, IRenderTargetTexture*, const ViewDesc&, NullView);
    FboFrameBuffer (const ContextManager&, IRenderTargetTexture*, const ViewDesc&, FboRenderBuffer*);
    FboFrameBuffer (const ContextManager&, IRenderTargetTexture*, const ViewDesc&, IRenderTargetTexture*, const ViewDesc&);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединение буфера рендеринга к текущему буферу кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetAttachment (RenderTargetType target_type, IRenderTargetTexture* texture, const ViewDesc& desc);
    void SetAttachment (RenderTargetType target_type, FboRenderBuffer* render_buffer);
    void SetAttachment (GLenum textarget, GLenum attachment, size_t texture_id, const ViewDesc& view_desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Завершение инициализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    void FinishInitialization ();
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Пустой буфер кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class NullFrameBuffer: public FrameBuffer, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    NullFrameBuffer (const ContextManager&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (bool& color_buffer_state, bool& depth_stencil_buffer_state);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление целевых буферов отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateRenderTargets () {}
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class FrameBufferManager: public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FrameBufferManager  (const ContextManager& manager, ISwapChain* default_swap_chain);
    ~FrameBufferManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение цепочки обмена по умолчанию
///////////////////////////////////////////////////////////////////////////////////////////////////
    ISwapChain* GetDefaultSwapChain () const { return default_swap_chain.get (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание целевых буферов вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    ITexture* CreateRenderBuffer        (const TextureDesc&);
    ITexture* CreateRenderTargetTexture (ISwapChain* swap_chain, size_t buffer_index);
    ITexture* CreateDepthStencilTexture (ISwapChain* swap_chain);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Диспетчер создания буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    FrameBuffer* CreateFrameBuffer (View* render_target_view, View* depth_stencil_view);

  private:
    typedef xtl::com_ptr<SwapChainColorBuffer>        ColorBufferPtr;
    typedef xtl::com_ptr<SwapChainDepthStencilBuffer> DepthStencilBufferPtr;

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Промежуточные диспетчеры создания буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T>
    FrameBuffer* CreateFrameBufferImpl (const T& render_target, const ViewDesc& render_target_desc, View* depth_stencil_view);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    FrameBuffer* CreateFrameBuffer (NullView, const ViewDesc&, NullView, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (NullView, const ViewDesc&, SwapChainDepthStencilBuffer*, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (NullView, const ViewDesc&, IRenderTargetTexture*, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (NullView, const ViewDesc&, FboRenderBuffer*, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (SwapChainColorBuffer*, const ViewDesc&, NullView, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (SwapChainColorBuffer*, const ViewDesc&, SwapChainDepthStencilBuffer*, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (SwapChainColorBuffer*, const ViewDesc&, IRenderTargetTexture*, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (SwapChainColorBuffer*, const ViewDesc&, FboRenderBuffer*, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (IRenderTargetTexture*, const ViewDesc&, NullView, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (IRenderTargetTexture*, const ViewDesc&, SwapChainDepthStencilBuffer*, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (IRenderTargetTexture*, const ViewDesc&, IRenderTargetTexture*, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (IRenderTargetTexture*, const ViewDesc&, FboRenderBuffer*, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (FboRenderBuffer*, const ViewDesc&, NullView, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (FboRenderBuffer*, const ViewDesc&, SwapChainDepthStencilBuffer*, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (FboRenderBuffer*, const ViewDesc&, IRenderTargetTexture*, const ViewDesc&);
    FrameBuffer* CreateFrameBuffer (FboRenderBuffer*, const ViewDesc&, FboRenderBuffer*, const ViewDesc&);
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с теневыми буферами
///////////////////////////////////////////////////////////////////////////////////////////////////
    ColorBufferPtr        GetShadowBuffer          (SwapChainDepthStencilBuffer*);
    DepthStencilBufferPtr GetShadowBuffer          (SwapChainColorBuffer*);
    void                  GetShadowBuffers         (ColorBufferPtr&, DepthStencilBufferPtr&);
    ColorBufferPtr        CreateColorBuffer        (SwapChainDepthStencilBuffer*);
    DepthStencilBufferPtr CreateDepthStencilBuffer (SwapChainColorBuffer*);
    SwapChainFrameBuffer* CreateShadowFrameBuffer  ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание буферов рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    ITexture* CreateSwapChainRenderBuffer (const TextureDesc&);
    ITexture* CreateFboRenderBuffer       (const TextureDesc&);    

  private:
    typedef stl::list<SwapChainColorBuffer*>        ColorBufferList;
    typedef stl::list<SwapChainDepthStencilBuffer*> DepthStencilBufferList;
    typedef xtl::com_ptr<ISwapChain>                SwapChainPtr;

  private:
    SwapChainPtr           default_swap_chain;
    ColorBufferList        shadow_color_buffers;
    DepthStencilBufferList shadow_depth_stencil_buffers;
    Extension              EXT_framebuffer_object;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние подуровня смешивания цветов
///////////////////////////////////////////////////////////////////////////////////////////////////
class BlendState: virtual public IBlendState, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    BlendState  (const ContextManager&, const BlendDesc&);
    ~BlendState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка/изменение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDesc (const BlendDesc&);
    void GetDesc (BlendDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка состояния в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

  private:
    BlendDesc desc;         //дескриптор состояния
    size_t    desc_hash;    //хэш дескриптора состояния    
    int       display_list; //номер списка команд конфигурации OpenGL
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние подуровня попиксельного отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
class DepthStencilState: virtual public IDepthStencilState, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    DepthStencilState  (const ContextManager&, const DepthStencilDesc&);
    ~DepthStencilState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка/изменение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetDesc (const DepthStencilDesc&);
    void GetDesc (DepthStencilDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка состояния в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind (size_t stencil_reference);

  private:
    DepthStencilDesc desc;                           //дескриптор состояния
    size_t           desc_hash;                      //хэш дескриптора состояния
    int              display_list;                   //номер списка команд конфигурации OpenGL
    GLenum           gl_stencil_func [FaceMode_Num]; //функции отсечения трафарета
    bool             need_two_side_stencil;          //состояние требует двустороннего трафарета
};

}

}

}

#endif
