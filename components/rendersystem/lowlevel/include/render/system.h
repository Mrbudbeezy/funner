#ifndef RENDER_SYSTEM_INTERFACE_HEADER
#define RENDER_SYSTEM_INTERFACE_HEADER

#include <mathlib.h>

namespace render
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Матрицы, используемые системой визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
enum RenderSystemMatrix
{
  RenderSystemMatrix_Projection, //матрица проецирования
  RenderSystemMatrix_View,       //матрица вида (камеры)
  RenderSystemMatrix_Object      //матрица объекта
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерфейс системы визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
class ICustomRenderSystem
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры устройства
///////////////////////////////////////////////////////////////////////////////////////////////////
    struct DeviceInfo
    {
      size_t width, height;  //размеры экрана
      size_t bits_per_pixel; //глубина цвета в битах на пиксель
    };

    virtual void GetDeviceInfo (DeviceInfo&) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка области вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    struct Viewport
    {
      size_t x, y, width, height;
    };

            void SetViewport (size_t x, size_t y, size_t width, size_t height);
    virtual void SetViewport (const Viewport&) = 0;
    virtual void GetViewport (Viewport&) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    enum RenderBuffer
    {
      RenderBuffer_Front,
      RenderBuffer_Back,
    };

    virtual void SetRenderBuffer (size_t surface_index) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с моделями
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual size_t AllocateModel (usage ???) = 0;
    virtual void   DeleteModel   (size_t model_index) = 0;
    virtual void   SetModel      (size_t model_index, const char* name) = 0;
    virtual void   SetModel      (size_t model_index, const Mesh&) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение информации о модели
///////////////////////////////////////////////////////////////////////////////////////////////////
    class ModelInfo
    {
      public:
        virtual size_t      DynamicSurfacesCount () = 0;
        virtual const char* DynamicSurfaceInfo   (size_t surface_index) = 0;
      
      protected:
        virtual ~ModelInfo () {}
    };

    virtual IModelInfo* GetModelInfo (size_t model_index) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с текстурами
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual size_t AllocateTexture (usage???) = 0;
    virtual void   DeleteTexture   (size_t texture_index) = 0;
    virtual void   SetTexture      (size_t texture_index, const Image&) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Транзакция визуализации сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void BeginScene () = 0;
    virtual void EndScene   () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка матриц преобразования
///////////////////////////////////////////////////////////////////////////////////////////////////
      //возможно поместить enum в IRenderSystem
    virtual void               SetMatrix (RenderSystemMatrix, const math::mat4f&) = 0;
    virtual const math::mat4f& GetMatrix (RenderSystemMatrix) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка контекста отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void SetContext (const math::vec4f& entity_color, const float params [???]);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Настройка освещения
///////////////////////////////////////////////////////////////////////////////////////////////////
    struct Light
    {
      math::vec4f color;
      float       attenuation [3];
        //???...
    };

    virtual void SetLight (const Light&) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование примитивов
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void DrawModel (size_t model_index) = 0;
    virtual void DrawModel (size_t model_index, size_t joints_count, const mat4f* joints_tm) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка функции протоколирования
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (const char*)> LogHandler;

    virtual void              SetDebugLog (const LogHandler&) = 0;
    virtual const LogHandler& GetDebugLog () = 0;

  protected:
    virtual ~IRenderSystem () {}
};

}

#endif
