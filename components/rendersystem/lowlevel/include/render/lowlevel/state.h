#ifndef RENDER_LOW_LEVEL_STATE_HEADER
#define RENDER_LOW_LEVEL_STATE_HEADER

#include <render/lowlevel/object.h>
#include <render/lowlevel/common.h>

namespace render
{

namespace low_level
{

//сделать шаблонный класс состояния!!!!

/*
===================================================================================================
    Input stage
===================================================================================================
*/

//////////////////////////////////////////////////////////////////////////////////////////////////
///Семантика атрибута вершины
///////////////////////////////////////////////////////////////////////////////////////////////////
enum VertexAttributeSemantic
{
  VertexAttributeSemantic_Position,  //положение
  VertexAttributeSemantic_Normal,    //нормаль
  VertexAttributeSemantic_Color,     //цвет
  VertexAttributeSemantic_Tangent,   //касательная
  VertexAttributeSemantic_Binormal,  //бинормаль
  VertexAttributeSemantic_TexCoord0, //каналы текстурных координат
  VertexAttributeSemantic_TexCoord1,
  VertexAttributeSemantic_TexCoord2,
  VertexAttributeSemantic_TexCoord3,
  VertexAttributeSemantic_TexCoord4,
  VertexAttributeSemantic_TexCoord5,
  VertexAttributeSemantic_TexCoord6,  
  VertexAttributeSemantic_TexCoord7,
  VertexAttributeSemantic_Influence, //индексы отрезка индексных весов
    //+weights?????
  
  VertexAttributeSemantic_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Типы входных данных
///////////////////////////////////////////////////////////////////////////////////////////////////
enum InputDataType
{
  InputDataType_Byte,   //однобайтовое целое знаковое число
  InputDataType_UByte,  //однобайтовое целое беззнаковое число
  InputDataType_Short,  //двубайтовое целое знаковое число
  InputDataType_UShort, //двубайтовое целое беззнаковое число
  InputDataType_Int,    //четырёхбайтовое целое знаковое число
  InputDataType_UInt,   //четырёхбайтовое целое беззнаковое число
  InputDataType_Float,  //четырёхбайтовое вещественное число

  InputDataType_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Форматы входных данных
///////////////////////////////////////////////////////////////////////////////////////////////////
enum InputDataFormat
{
  InputDataFormat_Value,                           //одинарное значение
  InputDataFormat_Vector1 = InputDataFormat_Value, 
  InputDataFormat_Vector2,                         //вектор из двух элементов
  InputDataFormat_Vector3,                         //вектор из трёх элементов
  InputDataFormat_Vector4,                         //вектор из четырёх элементов
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вершинный атрибут
///////////////////////////////////////////////////////////////////////////////////////////////////
struct VertexAttribute
{
  VertexAttributeSemantic semantic; //семантика вершинного атрибута
  InputDataFormat         format;   //формат данных
  InputDataType           type;     //тип элементов
  size_t                  slot;     //номер вершинного буфера
  size_t                  offset;   //смещение от начала вершинного буфера
  size_t                  stride;   //шаг в вершинном буфере
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор входного потока
///////////////////////////////////////////////////////////////////////////////////////////////////
struct InputLayoutDesc
{
  size_t           vertex_attributes_count; //количество вершинных атрибутов
  VertexAttribute* vertex_attributes;       //вершинные атрибуты
  InputDataType    index_type;              //тип индексов в вершинном буфере
  size_t           index_buffer_offset;     //смещение в индексном буфере
  size_t           first_matrix;            //смещение в массиве матриц (для скиннинга)
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние входного уровня
///////////////////////////////////////////////////////////////////////////////////////////////////
class IInputLayoutState: virtual public IDeviceObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////  
    virtual void GetDesc (InputLayoutDesc&) = 0;
};

/*
===================================================================================================
    Shader stage (viewer)
===================================================================================================
*/

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор наблюдателя
///////////////////////////////////////////////////////////////////////////////////////////////////
struct ViewerDesc
{
  Matrix4f projection; //матрица проецирования
  Matrix4f view;       //матрица вида
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние наблюдателя
///////////////////////////////////////////////////////////////////////////////////////////////////
class IViewerState: virtual public IDeviceObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение/изменение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void SetDesc (const ViewerDesc&) = 0;
    virtual void GetDesc (ViewerDesc&) = 0;
};

/*
===================================================================================================
    Shader stage (transform)
===================================================================================================
*/

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор преобразований объектов
///////////////////////////////////////////////////////////////////////////////////////////////////
struct TransformDesc
{
  size_t          matrices_count; //количество матриц
  const Matrix4f* matrices;       //матрицы
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние преобразований объектов
///////////////////////////////////////////////////////////////////////////////////////////////////
class ITransformState: virtual public IDeviceObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение/изменение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void SetDesc (const TransformDesc&) = 0;
    virtual void GetDesc (TransformDesc&) = 0;
};

/*
===================================================================================================
    Shader stage (lighting)
===================================================================================================
*/

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип источника света
///////////////////////////////////////////////////////////////////////////////////////////////////
enum LightType
{
  LightType_Point,  //точечный источник света
  LightType_Direct, //цилиндрический направленный источник света
  LightType_Spot,   //конусоидальный направленный источник света
  
  LightType_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Коэффициенты затухания света в зависимости от расстояния (I(D) = Ibase / (A0 + A1 * d + A2 * d * d))
///////////////////////////////////////////////////////////////////////////////////////////////////
enum LightAttenuation
{
  LightAttenuation_Constant,  //постоянный коэффициент затухания (A0)
  LightAttenuation_Linear,    //линейный коэффициент затухания (A1)
  LightAttenuation_Quadratic, //квадратичный коэффициент затухания (A2)

  LightAttenuation_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание источника света
///////////////////////////////////////////////////////////////////////////////////////////////////
struct LightDesc
{
  LightType type;           //тип источника света  
  bool      enable;         //состояние источника света: включён/выключен
  Color3f   ambient_color;  //веса поглащаемой составляющей света
  Color3f   diffuse_color;  //веса рассеиваемой составляющей света
  Color3f   specular_color; //веса отражённой составляющей света
  float     inner_angle;    //внутренний угол излучения
  float     outer_angle;    //внешний угол излучения
  float     attenuation [CommonShaderLightAttenuation_Num]; //коэффициенты затухания
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор параметров освещения
///////////////////////////////////////////////////////////////////////////////////////////////////
struct LightParamsDesc
{
  enum { MAX_LIGHTS_NUM = 8 };

  size_t    lights_count;                //количество источников света
  LightDesc lights [MAX_LIGHTS_NUM];     //описание источников света
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние освещения
///////////////////////////////////////////////////////////////////////////////////////////////////
class ILightingState: virtual public IDeviceObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение/изменение описания параметров освещения
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void SetDesc (const LightParamsDesc&) = 0; //????нужно ли вводить такие операции во всех стейтах???
    virtual void GetDesc (LightParamsDesc&) = 0;
};

/*
===================================================================================================
    Shader stage (sampling)
===================================================================================================
*/

///////////////////////////////////////////////////////////////////////////////////////////////////
///Типы фильтров
///////////////////////////////////////////////////////////////////////////////////////////////////
enum Filter
{
  Filter_Default,     //фильтрация выбирается в соответствии с предпочтениями устройства визуализации
  Filter_Point,       //точечная фильтрация
  Filter_Bilinear,    //билинейная фильтрация
  Filter_Trilinear,   //трилинейная фильтрация
  Filter_Anisotropic, //анизотропная фильтрация
  
  FilterType_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режимы свёртки
///////////////////////////////////////////////////////////////////////////////////////////////////
enum TexcoordWrap
{
  TexcoordWrap_Repeat,        //повторение
  TexcoordWrap_Mirror,        //зеркальное отражение
  TexcoordWrap_Clamp,         //отсечение
  TexcoordWrap_ClampToBorder, //отсечение по цвету границы
  
  TexcoordWrap_Num,
  
  TexcoordWrap_Default = TexcoordWrap_Repeat
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор сэмплирования
///////////////////////////////////////////////////////////////////////////////////////////////////
struct SamplerDesc
{
  Filter       min_filter;       //фильтрация, используемая если размер текселя меньше размера пикселя
  Filter       mag_filter;       //фильтрация, используемая если размер текселя больше размера пикселя
  Filter       mip_filter;       //фильтрация, используемая при переходе между mip-уровнями
  TexcoordWrap wrap_u;           //свёртка по координате U
  TexcoordWrap wrap_v;           //свёртка по координате V
  TexcoordWrap wrap_w;           //свёртка по координате W  
  float        mip_lod_bias;     //смещение от вычисленного mip-уровня
  float        min_lod;          //минимальный mip-уровень
  float        max_lod;          //максимальный mip-уровень
  size_t       max_anisotropy;   //максимальный уровень анизотропии
  float        border_color [4]; //цвет бордюра
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние сэмплера
///////////////////////////////////////////////////////////////////////////////////////////////////
class ISamplerState: virtual public IDeviceObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void GetDesc (SamplerDesc&) = 0;
};

/*
===================================================================================================
    Shader stage (material)
===================================================================================================
*/

///////////////////////////////////////////////////////////////////////////////////////////////////
///Источник текстурных координат
///////////////////////////////////////////////////////////////////////////////////////////////////
enum TexcoordSource
{
  TexcoordSource_Explicit,      //текстурные координаты задаются явно
  TexcoordSource_SphereMap,     //генерация текстурных координат: сферическая карта
  TexcoordSource_ReflectionMap, //генерация текстурных координат: карта отражения
  TexcoordSource_ObjectSpace,   //генерация текстурных координат: texmap.transform * position
  TexcoordSource_ViewerSpace,   //генерация текстурных координат: texmap.transform * modelviewprojection * position
  
  TexcoordSource_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор текстурной карты
///////////////////////////////////////////////////////////////////////////////////////////////////
struct TexmapDesc
{
  bool           enable;                   //разрешена ли карта
  size_t         sampler_slot;             //номер слота с сэмплером  
  Matrix4f       transform;                //матрица преобразования текстурных координат  
  int            dynamic_transform_index;  //индекс в массиве матриц преобразований (-1 - динамические преобразования отсутствуют)
  TexcoordSource source_u;                 //источник текстурных координат для U-координаты
  TexcoordSource source_v;                 //источник текстурных координат для V-координаты
  TexcoordSource source_w;                 //источник текстурных координат для W-координаты
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Идентификаторы карт материала
///////////////////////////////////////////////////////////////////////////////////////////////////
enum MaterialMap
{
  MaterialMap_Diffuse,     //базовая текстура (рассеянное освещение)
  MaterialMap_Ambient,     //текстура поглощения света
  MaterialMap_Specular,    //текстура степени отражения света
  MaterialMap_Transparent, //текстура прозрачности
  MaterialMap_Emission,    //текстура эмиссии (self-illumination)
  MaterialMap_Reflective,  //текстура карты отражения (env-map)
  MaterialMap_Bump,        //текстура рельефа поверхности
  
  MaterialMap_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор материала
///////////////////////////////////////////////////////////////////////////////////////////////////
struct MaterialDesc
{
  Color4f         emission;                //цвет излучения
  Color4f         ambient;                 //цвет поглощения
  Color4f         diffuse;                 //цвет рассеивания
  Color4f         specular;                //цвет отражения
  float           shininess;               //металличность
  CompareMode     alpha_compare_mode;      //режим альфа теста
  float           alpha_reference;         //константа альфа теста
  MaterialMapDesc maps [MaterialMap_Num];  //текстурные карты
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние материала
///////////////////////////////////////////////////////////////////////////////////////////////////
class IMaterialState: virtual public IDeviceObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение/изменение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void SetDesc (const MaterialDesc&) = 0;
    virtual void GetDesc (MaterialDesc&) = 0;
};

/*
===================================================================================================
    Rasterizer stage
===================================================================================================
*/

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим заливки
///////////////////////////////////////////////////////////////////////////////////////////////////
enum FillMode
{
  FillMode_Wireframe, //каркасная модель заливки
  FillMode_Solid,     //сплошная модель заливки
  
  FillMode_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим отсечения граней
///////////////////////////////////////////////////////////////////////////////////////////////////
enum CullMode
{
  CullMode_Front, //отсекать передние грани
  CullMode_Back,  //отсекать задние грани
  
  CullMode_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор уровня растеризации
///////////////////////////////////////////////////////////////////////////////////////////////////
struct RasterizerDesc
{
  FillMode fill_mode;               //режим заливки
  CullMode cull_mode;               //режим отсечения
  bool     front_counter_clockwise; //режим определения передних граней (по часовой стрелке - true, против - false)
  int      depth_bias;              //значение прибавляемое к каждому пикселу 
  bool     depth_clip_enable;       //включено ли отсечение по максимальной глубине
  bool     scissor_enable;          //включено ли scissor-отсечение
  bool     multisample_enable;      //включено ли мультисэмплирование
  bool     antialiased_line_enable; //включен ли антиалиасинг линий
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние уровня растеризации
///////////////////////////////////////////////////////////////////////////////////////////////////
class IRasterizerState: virtual public IDeviceObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void GetDesc (RasterizerDesc&) = 0;
};

/*
===================================================================================================
    Output-merger stage (depth-stencil)
===================================================================================================
*/

///////////////////////////////////////////////////////////////////////////////////////////////////
///Операции, выполняемые над элементами буфера трафарета
///////////////////////////////////////////////////////////////////////////////////////////////////
enum StencilOperation
{
  StencilOperation_Keep,      //значене элемента не изменяется
  StencilOperation_Zero,      //значение элемента устанавливается равным нулю
  StencilOperation_Replace,   //значение элемента заменяется значением stencil_reference
  StencilOperation_Increment, //значение увеличивается на 1 и обрезается по верхнему пределу
  StencilOperation_Decrement, //значение уменьшается на 1 и обрезается по нижнему пределу
  StencilOperation_Invert,    //значение инвертируется
  
  StencilOperation_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор буфера трафарета
///////////////////////////////////////////////////////////////////////////////////////////////////
struct StencilDesc
{
  CompareMode      stencil_compare_mode;   //режим сравнения значений в stencil-test
  StencilOperation stencil_fail_operation; //операция, выполняемая над элементом буфера трафарета в случае провала stencil-test
  StencilOperation depth_fail_operation;   //операция, выполняемая над элементом буфера трафарета в случае провала depth-test
  StencilOperation stencil_pass_operation; //операция, выполняемая над элементом буфера трафарета в случае прохождения stencil-test
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Виды граней
///////////////////////////////////////////////////////////////////////////////////////////////////
enum FaceMode
{
  FaceMode_Front, //передняя грань
  FaceMode_Back,  //задняя грань
  
  FaceMode_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор уровня попиксельного отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
struct DepthStencilDesc
{
  bool          depth_test_enable;      //включён ли тест глубины
  bool          depth_write_enable;     //включена ли запись в буфер глубины
  bool          stencil_test_enable;    //включён ли тест трафарета
  CompareDesc   depth_compare_mode;     //режим сравнения в тесте глубины
  unsigned char stencil_read_mask;      //маска, накладываемая на значения буфера трафарета при чтении
  unsigned char stencil_write_mask;     //маска, накладываемая на значения буфера трафарета при записи
  StencilDesc   stencil_desc [FaceMode_Num]; //дескрипторы буфера трафарета для различных видов граней
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние уровня попиксельного отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
class IDepthStencilState: virtual public IDeviceObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void GetDesc (DepthStencilDesc&) = 0;
};

/*
===================================================================================================
    Output-merger stage (blending)
===================================================================================================
*/

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вид операции смешивания цветов
///////////////////////////////////////////////////////////////////////////////////////////////////
enum BlendOperation
{
  BlendOperation_Add,                //arg1 + arg2
  BlendOperation_Subtraction,        //arg1 - arg2
  BlendOperation_ReverseSubtraction, //arg2 - arg1
  BlendOperation_Min,                //min (arg1, arg2)
  BlendOperation_Max,                //max (arg1, arg2)
  
  BlendOperation_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Аргумент функции смешивания цветов
///////////////////////////////////////////////////////////////////////////////////////////////////
enum BlendArgument
{
  BlendArgument_Zero,                    //0
  BlendArgument_One,                     //1
  BlendArgument_SourceColor,             //цвет источника
  BlendArgument_SourceAlpha,             //альфа источника
  BlendArgument_InverseSourceColor,      //1 - цвет источника
  BlendArgument_InverseSourceAlpha,      //1 - альфа источника
  BlendArgument_DestinationColor,        //цвет приёмника
  BlendArgument_DestinationAlpha,        //альфа приёмника
  BlendArgument_InverseDestinationColor, //1 - цвет приёмника
  BlendArgument_InverseDestinationAlpha, //1 - альфа приёмника
  
  BlendArgument_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Флаги маски записи цветов
///////////////////////////////////////////////////////////////////////////////////////////////////
enum ColorWriteFlags //имя: mask or flags????
{
  ColorWriteFlags_RedBit   = 1, //необходимо ли записывать красную компоненту цвета
  ColorWriteFlags_GreenBit = 2, //необходимо ли записывать зелёную компоненту цвета
  ColorWriteFlags_BlueBit  = 4, //необходимо ли записывать синюю компоненту цвета
  ColorWriteFlags_AlphaBit = 8, //необходимо ли записывать альфа компоненту цвета
  ColorWriteFlags_All      = ColorWriteFlags_RedBit | ColorWriteFlags_GreenBit | ColorWriteFlags_BlueBit | ColorWriteFlags_AlphaBit
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор уровня смешивания цветов
///////////////////////////////////////////////////////////////////////////////////////////////////
struct BlendDesc
{
  bool           blend_enable;               //включено ли смешивание цветов
  BlendOperation blend_operation;            //вид операции смешивания цветов
  BlendArgument  blend_source_argument;      //аргумент функции смешивания цветов, выбранный из источника цвета
  BlendArgument  blend_destination_argument; //аргумент функции смешивания цветов, выбранный из приёмника цвета
  unsigned char  color_write_mask;           //маска записи цветов
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние уровня смешивания цветов
///////////////////////////////////////////////////////////////////////////////////////////////////
class IBlendState: virtual public IDeviceObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void GetDesc (BlendDesc&) = 0;
};

}

}

#endif
