#ifndef SOCIAL_COLLECTION_HEADER
#define SOCIAL_COLLECTION_HEADER

#include <cstddef>

namespace xtl
{

//forward declaration
template <class T> class iterator;

}

namespace social
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Коллекция
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Item>
class Collection
{
  public:
    typedef xtl::iterator<Item>       Iterator;
    typedef xtl::iterator<const Item> ConstIterator;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор / копирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    Collection ();
    Collection (const Collection&);
    ~Collection ();

    Collection& operator = (const Collection&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество элементов / проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Size    () const;
    bool   IsEmpty () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение итератора
///////////////////////////////////////////////////////////////////////////////////////////////////
    Iterator      CreateIterator ();
    ConstIterator CreateIterator () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к элементу по индексу
///////////////////////////////////////////////////////////////////////////////////////////////////
    const Item& operator [] (size_t index) const;
          Item& operator [] (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Резервирование элементов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Capacity () const;
    void   Reserve  (size_t count);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление элементов в коллекцию
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Add (Item&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление элементов из коллекции
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Remove (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка коллекции
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Clear ();

  private:
    struct Impl;
    Impl* impl;
};

}

#endif
