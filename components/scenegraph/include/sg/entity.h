#ifndef SCENE_GRAPH_ENTITY_HEADER
#define SCENE_GRAPH_ENTITY_HEADER

#include <sg/node.h>
#include <bv/axis_aligned_box.h>

namespace sg
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Объект, имеющий геометрическую интерпретацию в сцене
///////////////////////////////////////////////////////////////////////////////////////////////////
  //+события изменения ограничивающих объёмов
class Entity: public Node
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Цвет объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetColor (const math::vec3f& color);
    void               SetColor (float red, float green, float blue);
    const math::vec3f& Color    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с ограничивающим объёмом
///Примечание: ограничивающие объёмы узлов-потомков не влияют на ограничивающий объём родительского узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetBoundBox (const bound_volumes::aaboxf&);

    const bound_volumes::aaboxf& BoundBox      () const; //ограничивающий объём узла в локальной системе координат
    const bound_volumes::aaboxf& WorldBoundBox () const; //ограничивающий объём узла в мировой системе координат

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка бесконечных ограничивающий объёмов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetInfiniteBounds ();
    bool IsInfiniteBounds  () const; //являются ли ограничивающие объёмы узла бесконечными

///////////////////////////////////////////////////////////////////////////////////////////////////
///Расчёт кумулятивных ограничивающих объёмов
///////////////////////////////////////////////////////////////////////////////////////////////////
    bound_volumes::aaboxf ChildrenBoundBox      () const; //ограничивающий объём потомков в локальной системе координат узла
    bound_volumes::aaboxf FullBoundBox          () const; //полный ограничивающий объём узла с потомками в локальной системе координат узла
    bound_volumes::aaboxf WorldChildrenBoundBox () const; //ограничивающий объём потомков в мировой системе координат
    bound_volumes::aaboxf WorldFullBoundBox     () const; //полный ограничивающий объём узла с потомками в мировой системе координат
    
  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Entity  ();
    ~Entity ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Метод, вызываемый при посещении данного узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AcceptCore (Visitor&);

  private:
    using Node::Create;

  private:
    void UpdateWorldTransformEvent ();
    void UpdateWorldBoundsNotify ();
    void UpdateWorldBounds () const;

  private:
    struct Impl;
    Impl* impl;
};

}

#endif
