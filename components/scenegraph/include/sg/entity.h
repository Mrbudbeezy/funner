#ifndef SCENE_GRAPH_ENTITY_HEADER
#define SCENE_GRAPH_ENTITY_HEADER

#include <mathlib.h>
#include <xtl/functional_fwd>

namespace sg
{

//forward declarations
class Scene;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим присоединения
///////////////////////////////////////////////////////////////////////////////////////////////////
enum EntityBindMode
{
  EntityBindMode_AddRef,  //при присоединении количество ссылок на родителя увеличивается на 1
  EntityBindMode_Capture, //при присоединении количество ссылок на родителя не увеличивается
  
  EntityBindMode_Default = EntityBindMode_AddRef
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим поиска потомков
///////////////////////////////////////////////////////////////////////////////////////////////////
enum EntitySearchMode
{
  EntitySearchMode_OnNextSublevel, //поиск потомка только на следующем подуровне
  EntitySearchMode_OnAllSublevels, //поиск потомка на всех подуровнях
  
  EntitySearchMode_Default = EntitySearchMode_OnAllSublevels
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Пространство преобразований объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
enum EntityTransformSpace
{
  EntityTransformSpace_Local,  //преобразования в локальной системе координат объекта
  EntityTransformSpace_Parent, //преобразования в системе координат родительского объекта
  EntityTransformSpace_World   //преобразования в мировой системе координат
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим обхода объектов
///////////////////////////////////////////////////////////////////////////////////////////////////
enum EntityTraverseMode
{
  EntityTraverseMode_TopToBottom,      //обход объектов от родителей к потомкам
  EntityTraverseMode_BottomToTop,      //обход объектов от потомков к родителям
  
  EntityTraverseMode_Default = EntityTraverseMode_TopToBottom
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///События объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
enum EntityEvent
{
  EntityEvent_AfterUpdate,   //срабатывает после обновления состояния объекта
  EntityEvent_BeforeDestroy, //срабатывает перед удалением объекта
  EntityEvent_AfterBind,     //срабатывает после присоединения объекта к родителю
  EntityEvent_BeforeUnbind,  //срабатывает перед отсоединением объекта от родителя

  EntityEvent_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый объект сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
  //добавить ограничивающие объёмы!!!
  //добавить EntityIterator / EntityConstIterator
class Entity
{
  public: 
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание объекта (как правило это имеет смысл только в случае необходимости объединения других
///  объектов)
///////////////////////////////////////////////////////////////////////////////////////////////////  
    static Entity* Create ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сцена, которой принадлежит объект (если объект не присоединён к сцене возвращает 0)
///////////////////////////////////////////////////////////////////////////////////////////////////
    sg::Scene*       Scene ();
    const sg::Scene* Scene () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Name    () const;
    void        SetName (const char* new_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void   AddRef   ();         //увеличить число ссылок на объект на 1
    void   Release  ();         //уменьшить число ссылок на объекта на 1
    size_t UseCount () const;   //количество активных ссылок на объект

///////////////////////////////////////////////////////////////////////////////////////////////////
///Цвет объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetColor (const math::vec3f& color);
    void               SetColor (float red, float green, float blue);
    const math::vec3f& Color    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Связи для перемещения по данному уровню иерархии
///////////////////////////////////////////////////////////////////////////////////////////////////
          Entity* Parent     ();
    const Entity* Parent     () const;
          Entity* FirstChild ();
    const Entity* FirstChild () const;
          Entity* LastChild  ();
    const Entity* LastChild  () const;
          Entity* PrevChild  ();
    const Entity* PrevChild  () const;
          Entity* NextChild  ();
    const Entity* NextChild  () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Настройка иерархических связей
///////////////////////////////////////////////////////////////////////////////////////////////////
      //установка соединения
    void BindToParent (Entity&              parent,                                        //родительский узел
                       EntityBindMode       mode = EntityBindMode_Default,                 //режим присоединения
                       EntityTransformSpace invariant_space = EntityTransformSpace_Local); //инвариантное пространство преобразований

      //разрыв соединения
    void Unbind (EntityTransformSpace invariant_space = EntityTransformSpace_Local);

      //отсоединение потомка
    void UnbindChild (const char* name, EntityTransformSpace invariant_space = EntityTransformSpace_Local);
    void UnbindChild (const char* name, EntitySearchMode find_mode, EntityTransformSpace invariant_space = EntityTransformSpace_Local);

      //отсоединение всех потомков    
    void UnbindAllChildren ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск потомка по имени
///////////////////////////////////////////////////////////////////////////////////////////////////
          Entity* FindChild (const char* name, EntitySearchMode mode = EntitySearchMode_Default);
    const Entity* FindChild (const char* name, EntitySearchMode mode = EntitySearchMode_Default) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Посещение объекта с динамической диспетчеризацией по типу (применение паттерна Visitor)
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::basic_visitor<void> Visitor;

    void Accept (Visitor&) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обход потомков
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (Entity&)>       TraverseFunction;
    typedef xtl::function<void (const Entity&)> ConstTraverseFunction;

    void Traverse (const TraverseFunction&, EntityTraverseMode = EntityTraverseMode_Default);
    void Traverse (const ConstTraverseFunction&, EntityTraverseMode = EntityTraverseMode_Default) const;
    void TraverseAccept (Visitor&, EntityTraverseMode = EntityTraverseMode_Default) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Положение объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetPosition   (const math::vec3f&);
    void               SetPosition   (float x, float y, float z);
    void               ResetPosition ();
    const math::vec3f& Position      () const;
    const math::vec3f& WorldPosition () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ориентация объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetOrientation   (const math::quatf&);
    void               SetOrientation   (float angle_in_degrees, float axis_x, float axis_y, float axis_z);
    void               SetOrientation   (float pitch_in_degrees, float yaw_in_degrees, float roll_in_degrees); //углы Эйлера
    void               ResetOrientation ();
    const math::quatf& Orientation      () const;
    const math::quatf& WorldOrientation () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Масштаб объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetScale   (const math::vec3f&);
    void               SetScale   (float sx, float sy, float sz);
    void               ResetScale ();
    const math::vec3f& Scale      () const;
    const math::vec3f& WorldScale () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление наследованием преобразований
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetOrientationInherit  (bool state); //установка флага наследования родительской ориентации
    void SetScaleInherit        (bool state); //установка флага наследования родительского масштаба
    bool IsOrientationInherited () const;     //наследуется ли родительская ориентация
    bool IsScaleInherited       () const;     //наследуется ли родительский масштаб

///////////////////////////////////////////////////////////////////////////////////////////////////
///Кумулятивные преобразования
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Translate (const math::vec3f&, EntityTransformSpace = EntityTransformSpace_Parent);
    void Translate (float offset_x, float offset_y, float offset_z, EntityTransformSpace = EntityTransformSpace_Parent);
    void Rotate    (const math::quatf&, EntityTransformSpace = EntityTransformSpace_Parent);
    void Rotate    (float angle_in_degrees, float axis_x, float axis_y, float axis_z, EntityTransformSpace = EntityTransformSpace_Parent);
    void Rotate    (float pitch_in_degrees, float yaw_in_degrees, float roll_in_degrees, EntityTransformSpace = EntityTransformSpace_Parent);
    void Scale     (const math::vec3f&);
    void Scale     (float sx, float sy, float sz);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение матриц преобразования объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    const math::mat4f& TransformationMatrix (EntityTransformSpace) const;

      //сокращённые версии
    const math::mat4f& LocalTM  () const { return TransformationMatrix (EntityTransformSpace_Local); }
    const math::mat4f& WorldTM  () const { return TransformationMatrix (EntityTransformSpace_World); }
    const math::mat4f& ParentTM () const { return TransformationMatrix (EntityTransformSpace_Parent); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение матрицы преобразования объекта object в системе координат данного объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    math::mat4f ObjectTM (Entity&) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подписка на события Entity
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::signal<void (Entity&), xtl::default_signal_accumulator<void> > Signal;

          Signal& Listeners (EntityEvent);
    const Signal& Listeners (EntityEvent) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление транзакциями обновления
///  Во время транзакции оповещения не посылаются их обработчикам, а аккумулируются и посылаются
///  при завершении транзакции
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BeginUpdate ();
    void EndUpdate   ();
    bool IsInUpdateTransaction () const;

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
            Entity  ();
    virtual ~Entity ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об изменении объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateNotify ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Попытка посещения. Результат: обработано ли посещение
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> static bool TryAccept (T&, Visitor&);

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Метод, вызываемый при посещении данного объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void AcceptCore (Visitor&);

  private:
    void BindToParentImpl (Entity*, EntityBindMode, EntityTransformSpace);
    void SetScene (sg::Scene*);
    void UpdateWorldTransformNotify ();
    void UpdateLocalTransformNotify ();
    void UpdateWorldTransform () const;
    void Notify (EntityEvent);

  private:
    Entity (const Entity&); //no impl
    Entity& operator = (const Entity&); //no impl

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вспомогательный класс, для автоматизации блокирования оповещений об обновлениях
///////////////////////////////////////////////////////////////////////////////////////////////////
class EntityUpdateLock
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    EntityUpdateLock  (Entity* = 0);
    EntityUpdateLock  (const EntityUpdateLock&);
    ~EntityUpdateLock ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    EntityUpdateLock& operator = (const EntityUpdateLock&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (EntityUpdateLock&);

  private:
    Entity* entity;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (EntityUpdateLock&, EntityUpdateLock&);

#include <sg/detail/entity.inl>

}

#endif
