#ifndef SCENE_GRAPH_NODE_HEADER
#define SCENE_GRAPH_NODE_HEADER

#include <mathlib.h>
#include <xtl/functional_fwd>

namespace sg
{

//forward declarations
class Scene;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим присоединения
///////////////////////////////////////////////////////////////////////////////////////////////////
enum NodeBindMode
{
  NodeBindMode_AddRef,  //при присоединении количество ссылок на родителя увеличивается на 1
  NodeBindMode_Capture, //при присоединении количество ссылок на родителя не увеличивается
  
  NodeBindMode_Default = NodeBindMode_AddRef
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим поиска потомков
///////////////////////////////////////////////////////////////////////////////////////////////////
enum NodeSearchMode
{
  NodeSearchMode_OnNextSublevel, //поиск потомка только на следующем подуровне
  NodeSearchMode_OnAllSublevels, //поиск потомка на всех подуровнях
  
  NodeSearchMode_Default = NodeSearchMode_OnAllSublevels
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Пространство преобразований узла
///////////////////////////////////////////////////////////////////////////////////////////////////
enum NodeTransformSpace
{
  NodeTransformSpace_Local,  //преобразования в локальной системе координат узла
  NodeTransformSpace_Parent, //преобразования в системе координат родительского узла
  NodeTransformSpace_World   //преобразования в мировой системе координат
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим обхода узлов
///////////////////////////////////////////////////////////////////////////////////////////////////
enum NodeTraverseMode
{
  NodeTraverseMode_TopToBottom, //обход узлов от родителей к потомкам
  NodeTraverseMode_BottomToTop, //обход узлов от потомков к родителям
  
  NodeTraverseMode_Default = NodeTraverseMode_TopToBottom
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///События узла
///////////////////////////////////////////////////////////////////////////////////////////////////
enum NodeEvent
{
  NodeEvent_AfterUpdate,   //срабатывает после обновления состояния узла
  NodeEvent_BeforeDestroy, //срабатывает перед удалением узла
  NodeEvent_AfterDestroy,  //срабатывает после удаления узла
  NodeEvent_AfterBind,     //срабатывает после присоединения узла к родителю
  NodeEvent_BeforeUnbind,  //срабатывает перед отсоединением узла от родителя

  NodeEvent_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Узел сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
  //добавить NodeIterator / NodeConstIterator
class Node
{
  public: 
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание узла
///////////////////////////////////////////////////////////////////////////////////////////////////  
    static Node* Create ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сцена, которой принадлежит узел (если узел не присоединён к сцене возвращает 0)
///////////////////////////////////////////////////////////////////////////////////////////////////
    sg::Scene*       Scene ();
    const sg::Scene* Scene () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Name    () const;
    void        SetName (const char* new_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void   AddRef   ();         //увеличить число ссылок на узел на 1
    void   Release  ();         //уменьшить число ссылок на узел на 1
    size_t UseCount () const;   //количество активных ссылок на узел

///////////////////////////////////////////////////////////////////////////////////////////////////
///Цвет узла --- убрать!!!!
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetColor (const math::vec3f& color);
    void               SetColor (float red, float green, float blue);
    const math::vec3f& Color    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Связи для перемещения по данному уровню иерархии
///////////////////////////////////////////////////////////////////////////////////////////////////
          Node* Parent     ();
    const Node* Parent     () const;
          Node* FirstChild ();
    const Node* FirstChild () const;
          Node* LastChild  ();
    const Node* LastChild  () const;
          Node* PrevChild  ();
    const Node* PrevChild  () const;
          Node* NextChild  ();
    const Node* NextChild  () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Настройка иерархических связей
///////////////////////////////////////////////////////////////////////////////////////////////////
      //установка соединения
    void BindToParent (Node&              parent,                                        //родительский узел
                       NodeBindMode       mode = NodeBindMode_Default,                 //режим присоединения
                       NodeTransformSpace invariant_space = NodeTransformSpace_Local); //инвариантное пространство преобразований

      //разрыв соединения
    void Unbind (NodeTransformSpace invariant_space = NodeTransformSpace_Local);

      //отсоединение потомка
    void UnbindChild (const char* name, NodeTransformSpace invariant_space = NodeTransformSpace_Local);
    void UnbindChild (const char* name, NodeSearchMode find_mode, NodeTransformSpace invariant_space = NodeTransformSpace_Local);

      //отсоединение всех потомков    
    void UnbindAllChildren ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск потомка по имени
///////////////////////////////////////////////////////////////////////////////////////////////////
          Node* FindChild (const char* name, NodeSearchMode mode = NodeSearchMode_Default);
    const Node* FindChild (const char* name, NodeSearchMode mode = NodeSearchMode_Default) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Посещение узла с динамической диспетчеризацией по типу (применение паттерна Visitor)
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::basic_visitor<void> Visitor;

    void Accept (Visitor&) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обход потомков
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (Node&)>       TraverseFunction;
    typedef xtl::function<void (const Node&)> ConstTraverseFunction;

    void Traverse (const TraverseFunction&, NodeTraverseMode = NodeTraverseMode_Default);
    void Traverse (const ConstTraverseFunction&, NodeTraverseMode = NodeTraverseMode_Default) const;
    void TraverseAccept (Visitor&, NodeTraverseMode = NodeTraverseMode_Default) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Положение узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetPosition   (const math::vec3f&);
    void               SetPosition   (float x, float y, float z);
    void               ResetPosition ();
    const math::vec3f& Position      () const;
    const math::vec3f& WorldPosition () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ориентация узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetOrientation   (const math::quatf&);
    void               SetOrientation   (float angle_in_degrees, float axis_x, float axis_y, float axis_z);
    void               SetOrientation   (float pitch_in_degrees, float yaw_in_degrees, float roll_in_degrees); //углы Эйлера
    void               ResetOrientation ();
    const math::quatf& Orientation      () const;
    const math::quatf& WorldOrientation () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Масштаб узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetScale   (const math::vec3f&);
    void               SetScale   (float sx, float sy, float sz);
    void               ResetScale ();
    const math::vec3f& Scale      () const;
    const math::vec3f& WorldScale () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление наследованием преобразований
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetOrientationInherit  (bool state); //установка флага наследования родительской ориентации
    void SetScaleInherit        (bool state); //установка флага наследования родительского масштаба
    bool IsOrientationInherited () const;     //наследуется ли родительская ориентация
    bool IsScaleInherited       () const;     //наследуется ли родительский масштаб

///////////////////////////////////////////////////////////////////////////////////////////////////
///Кумулятивные преобразования
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Translate (const math::vec3f&, NodeTransformSpace = NodeTransformSpace_Parent);
    void Translate (float offset_x, float offset_y, float offset_z, NodeTransformSpace = NodeTransformSpace_Parent);
    void Rotate    (const math::quatf&, NodeTransformSpace = NodeTransformSpace_Parent);
    void Rotate    (float angle_in_degrees, float axis_x, float axis_y, float axis_z, NodeTransformSpace = NodeTransformSpace_Parent);
    void Rotate    (float pitch_in_degrees, float yaw_in_degrees, float roll_in_degrees, NodeTransformSpace = NodeTransformSpace_Parent);
    void Scale     (const math::vec3f&);
    void Scale     (float sx, float sy, float sz);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение матриц преобразования узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    const math::mat4f& TransformationMatrix (NodeTransformSpace) const;

      //сокращённые версии
    const math::mat4f& LocalTM  () const { return TransformationMatrix (NodeTransformSpace_Local); }
    const math::mat4f& WorldTM  () const { return TransformationMatrix (NodeTransformSpace_World); }
    const math::mat4f& ParentTM () const { return TransformationMatrix (NodeTransformSpace_Parent); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение матрицы преобразования узла object в системе координат данного узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    math::mat4f ObjectTM (Node&) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подписка на события Node
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::signal<void (Node&), xtl::default_signal_accumulator<void> > Signal;

          Signal& Listeners (NodeEvent);
    const Signal& Listeners (NodeEvent) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление транзакциями обновления
///  Во время транзакции оповещения не посылаются их обработчикам, а аккумулируются и посылаются
///  при завершении транзакции
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BeginUpdate ();
    void EndUpdate   ();
    bool IsInUpdateTransaction () const;

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
            Node  ();
    virtual ~Node ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об изменении узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateNotify ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Попытка посещения. Результат: обработано ли посещение
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> static bool TryAccept (T&, Visitor&);

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Метод, вызываемый при посещении данного узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void AcceptCore (Visitor&);

  private:
    void BindToParentImpl (Node*, NodeBindMode, NodeTransformSpace);
    void SetScene (sg::Scene*);
    void UpdateWorldTransformNotify ();
    void UpdateLocalTransformNotify ();
    void UpdateWorldTransform () const;
    void Notify (NodeEvent);

  private:
    Node (const Node&); //no impl
    Node& operator = (const Node&); //no impl

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вспомогательный класс, для автоматизации блокирования оповещений об обновлениях
///////////////////////////////////////////////////////////////////////////////////////////////////
class NodeUpdateLock
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    NodeUpdateLock  ();
    NodeUpdateLock  (Node&);
    NodeUpdateLock  (const NodeUpdateLock&);
    ~NodeUpdateLock ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    NodeUpdateLock& operator = (const NodeUpdateLock&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (NodeUpdateLock&);

  private:
    Node* node;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (NodeUpdateLock&, NodeUpdateLock&);

#include <sg/detail/node.inl>

}

#endif
