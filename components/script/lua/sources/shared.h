#ifndef SCRIPTLIB_LUA_SHARED_HEADER
#define SCRIPTLIB_LUA_SHARED_HEADER

#include <stl/hash_map>

#include <xtl/any.h>
#include <xtl/bind.h>
#include <xtl/common_exceptions.h>
#include <xtl/connection.h>
#include <xtl/function.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/iterator.h>
#include <xtl/reference_counter.h>
#include <xtl/shared_ptr.h>
#include <xtl/trackable.h>

#include <common/component.h>
#include <common/heap.h>
#include <common/strlib.h>

#include <script/bind.h>
#include <script/interpreter.h>
#include <script/environment.h>

#ifdef LUAJIT

#include <float.h>

extern "C" {
#include <luajit.h>
#endif

#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

#ifdef LUAJIT
}
#endif

extern "C" {
#include <ShinyManager.h>
}

namespace script
{

namespace lua
{

//forward declaration
class Interpreter;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя вариантного типа данных "по умолчанию"
///////////////////////////////////////////////////////////////////////////////////////////////////
extern const char* VARIANT_DEFAULT_TYPE_NAME;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние машины lua
///////////////////////////////////////////////////////////////////////////////////////////////////
class StateHolder
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    StateHolder  ();
    ~StateHolder ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение состояния
///////////////////////////////////////////////////////////////////////////////////////////////////
    lua_State* State () const { return state; }

  private:
    StateHolder (const StateHolder&); //no impl
    StateHolder& operator = (const StateHolder&); //no impl

  protected:
    lua_State* state;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Стек
///////////////////////////////////////////////////////////////////////////////////////////////////
class Stack: public IStack
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    Stack (lua_State* state, lua::Interpreter& interpreter);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерпретатор, которому принадлежит стек
///////////////////////////////////////////////////////////////////////////////////////////////////
    IInterpreter& Interpreter ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество аргументов в стеке
///////////////////////////////////////////////////////////////////////////////////////////////////
    unsigned int Size ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение аргументов из стека
///////////////////////////////////////////////////////////////////////////////////////////////////
    float       GetFloat   (unsigned int index);
    ptrdiff_t   GetInteger (unsigned int index);
    bool        GetBoolean (unsigned int index);
    void*       GetPointer (unsigned int index);
    const char* GetString  (unsigned int index);
    ISymbol*    GetSymbol  (unsigned int index);
    xtl::any&   GetVariant (unsigned int index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Помещение аргументов в стек
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Push       (float value);
    void Push       (ptrdiff_t value);
    void Push       (bool value);
    void Push       (void* pointer);
    void Push       (const char* string);
    void Push       (const xtl::any& object);
    void PushSymbol (const char* string);
    void PushSymbol (ISymbol*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление аргументов из стека
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Pop (unsigned int arguments_count);

  private:
    lua_State*        state;
    lua::Interpreter& interpreter;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Реестр символов
///////////////////////////////////////////////////////////////////////////////////////////////////
class SymbolRegistry
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SymbolRegistry  (lua_State* state);
    ~SymbolRegistry ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение состояния
///////////////////////////////////////////////////////////////////////////////////////////////////
    lua_State* State () const { return state; }
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение символа
///////////////////////////////////////////////////////////////////////////////////////////////////
    ISymbol* GetSymbol (int index);

  private:
    SymbolRegistry (const SymbolRegistry&); //no impl
    SymbolRegistry& operator = (const SymbolRegistry&); //no impl

    void RemoveSymbol (void* symbol_handle);    

  private:
    class Symbol;
    typedef stl::hash_map<void*, Symbol*> SymbolMap;

    friend class Symbol;

  private:
    lua_State* state;
    SymbolMap  symbols;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Библиотека Lua
///////////////////////////////////////////////////////////////////////////////////////////////////
class Library: public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Library  (Interpreter& interpreter, const char* name, const InvokerRegistry& registry);
    ~Library ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация/удаление шлюзов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RegisterInvoker   (const char* invoker_name, Invoker& invoker);
    void UnregisterInvoker (const char* invoker_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление метатаблицы
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Destroy ();

  private:
    Library (const Library&); //no impl
    Library& operator = (const Library&); //no impl

  private:
    lua_State*           state;                            //состояние Lua
    Interpreter&         interpreter;                      //интерпретатор
    InvokerRegistry      registry;                         //реестр шлюзов
    stl::string          table_name;                       //имя таблицы
    bool                 is_global;                        //является ли библиотека глобальной
    xtl::auto_connection on_register_invoker_connection;   //соединение регистрации шлюза
    xtl::auto_connection on_unregister_invoker_connection; //соединение удаления шлюза
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерпретатор Lua
///////////////////////////////////////////////////////////////////////////////////////////////////
class Interpreter: public IInterpreter, public StateHolder, public xtl::reference_counter, public xtl::trackable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Interpreter  (const script::Environment&);
    ~Interpreter ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя интерпретатора
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Name ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Окружение / реестр символов / стек
///////////////////////////////////////////////////////////////////////////////////////////////////
    script::Environment& Environment ();
    lua::SymbolRegistry& SymbolRegistry ();
    IStack&              Stack ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка наличия функции
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool HasFunction (const char* name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Выполнение буфера интерпретации луа
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DoCommands (const char* buffer_name, const void* buffer, size_t buffer_size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вызов функции луа
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Invoke (unsigned int arguments_count, unsigned int results_count);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddRef  ();
    void Release ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Объект, оповещающий об удалении IInterpreter
///////////////////////////////////////////////////////////////////////////////////////////////////
    xtl::trackable& GetTrackable () { return *this; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Профилирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LuaHook (lua_Debug* ar);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация/удаление библиотек
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RegisterLibrary   (const char* name, InvokerRegistry& registry);
    void UnregisterLibrary (const char* name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Профилирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    void        StartProfiling    ();
    void        StopProfiling     ();
    void        UpdateProfileInfo ();
    void        CleanProfileInfo  ();
    const char* ProfileTreeState  (unsigned int max_lines);
    const char* ProfileFlatState  (unsigned int max_lines);

  private:
    //Информация для профилирования lua-функций
    struct LuaHookProfile
    {
      ShinyZone      zone;
      ShinyNodeCache cache;
      stl::string    name;

      LuaHookProfile ();
    };

  private:
    typedef xtl::intrusive_ptr<Library>                           LibraryPtr;
    typedef stl::hash_map<stl::hash_key<const char*>, LibraryPtr> LibraryMap;
    typedef stl::hash_map<const void*, LuaHookProfile>            HookProfileMap;

  private:
    script::Environment   environment;                  //скриптовое окружение
    lua::SymbolRegistry   symbol_registry;              //реестр символов
    lua::Stack            stack;                        //стек аргументов
    LibraryMap            libraries;                    //карта библиотек
    HookProfileMap        hook_profiles;                //карта профилей луа-функций
    stl::string           profile_info_string;          //строка для возврата информации о профилировании
    xtl::auto_connection  on_create_library_connection; //соединение на событие создания библиотеки
    xtl::auto_connection  on_remove_library_connection; //соединение на событие удаления библиотеки
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Утилиты
///////////////////////////////////////////////////////////////////////////////////////////////////
int  variant_destroy  (lua_State*); //удаление объекта вариантного типа данных
int  variant_tostring (lua_State*); //печать в строку состояния объекта пользовательского типа данных
int  safe_call        (lua_State*, int (*f)(lua_State*)); //безопасный вызов шлюза
void dump_stack       (lua_State*, stl::string& buffer); //печать состояния стека
void check_stack      (lua_State* state, unsigned int count = 1); //проверка возможности поместить в стек count аргументов
void check_item       (lua_State* state, unsigned int index, int expected_type, const char* function_name); //проверка корректности типа элемента, извлекаемого из стека
void raise_error      (lua_State* state, const char* source); //получение сообщения об ошибке

//получение строки с местом вызова
stl::string get_lua_position (lua_State* state);

//безопасный вызов шлюзов
template <class Fn>
int safe_call (lua_State* state)
{
  try
  {
    return Fn::Invoke (state);
  }
  catch (xtl::bad_any_cast& e)
  {
    luaL_error (state, "%s: %s -> %s%s", e.what (), e.source_type ().name (), e.target_type ().name (), get_lua_position (state).c_str ());
  }
  catch (std::exception& e)
  {
    luaL_error (state, "%s%s", e.what (), get_lua_position (state).c_str ());
  }
  catch (...)
  {
    luaL_error (state, "%s%s", lua_gettop (state) ? lua_tostring (state, -1) : "internal error", get_lua_position (state).c_str ());
  }

  return 0;
}

}

}

#endif
