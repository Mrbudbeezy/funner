#ifndef SCRIPTLIB_INVOKER_HEADER
#define SCRIPTLIB_INVOKER_HEADER

#include <stl/string_fwd>

#include <script/stack.h>

namespace script
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сигнатура шлюза
///////////////////////////////////////////////////////////////////////////////////////////////////
class InvokerSignature
{
  public:  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    InvokerSignature  ();
    InvokerSignature  (const InvokerSignature&);
    ~InvokerSignature ();

    InvokerSignature& operator = (const InvokerSignature&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип возвращаемого значения
///////////////////////////////////////////////////////////////////////////////////////////////////
    const std::type_info& ResultType    () const;
    void                  SetResultType (const std::type_info& type); //type хранится как обычная ссылка

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество параметров
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t ParametersCount () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Типы параметров
///////////////////////////////////////////////////////////////////////////////////////////////////
    const std::type_info& ParameterType    (size_t index) const;
    void                  SetParameterType (size_t index, const std::type_info& type);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление / удаление типов параметров
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t AddParameterType        (const std::type_info& type); //type хранится как обычная ссылка
    void   RemoveParameterType     (size_t index);
    void   RemoveAllParameterTypes ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Приведение к строке
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* ToString () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сравнение
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool operator == (const InvokerSignature&) const;
    bool operator != (const InvokerSignature&) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (InvokerSignature&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (InvokerSignature&, InvokerSignature&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерфейс шлюза
///////////////////////////////////////////////////////////////////////////////////////////////////
class IInvoker
{
  public:
    virtual ~IInvoker () {}
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Вызов шлюза с использованием параметров в стеке
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual size_t operator () (IStack&) = 0;  
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение сигнатуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual InvokerSignature GetSignature () = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Простой шлюз - есть поддержка только вызова с использованием параметров в стеке
///  (предназначен как базовый класс для простых пользовательских шлюзов)
///////////////////////////////////////////////////////////////////////////////////////////////////
class SimpleInvoker: public IInvoker
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение сигнатуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    InvokerSignature GetSignature ();
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Функция-шлюз между скриптовым движком и C++ кодом
///////////////////////////////////////////////////////////////////////////////////////////////////
class Invoker
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    Invoker  ();
    Invoker  (const Invoker&);
    ~Invoker ();
    
    template <class Fn> Invoker (const Fn& first_overload_fn);
    
    Invoker& operator = (const Invoker&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Перегрузки
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t                  OverloadsCount    () const;
    const InvokerSignature& OverloadSignature (size_t index) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление и удаление перегрузок
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t AddOverload        (IInvoker* invoker); //invoker will be deleted in destructor
    size_t AddOverloads       (const Invoker&);
    void   RemoveOverload     (size_t index);
    void   RemoveAllOverloads ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Вызов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t operator () (IStack& stack) const;
    size_t operator () (size_t overload_index, IStack& stack) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (Invoker&);
    
  private:
    void Init (IInvoker*);
  
    IInvoker* OverloadInvoker (size_t index) const;
    
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (Invoker&, Invoker&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание перегруженного шлюза
///////////////////////////////////////////////////////////////////////////////////////////////////
Invoker make_invoker (const Invoker& invoker1, const Invoker& invoker2);
Invoker make_invoker (const Invoker& invoker1, const Invoker& invoker2, const Invoker& invoker3);
Invoker make_invoker (const Invoker& invoker1, const Invoker& invoker2, const Invoker& invoker3, const Invoker& invoker4);
Invoker make_invoker (const Invoker& invoker1, const Invoker& invoker2, const Invoker& invoker3, const Invoker& invoker4,
                      const Invoker& invoker5);
Invoker make_invoker (const Invoker& invoker1, const Invoker& invoker2, const Invoker& invoker3, const Invoker& invoker4,
                      const Invoker& invoker5, const Invoker& invoker6);
Invoker make_invoker (const Invoker& invoker1, const Invoker& invoker2, const Invoker& invoker3, const Invoker& invoker4,
                      const Invoker& invoker5, const Invoker& invoker6, const Invoker& invoker7);
Invoker make_invoker (const Invoker& invoker1, const Invoker& invoker2, const Invoker& invoker3, const Invoker& invoker4,
                      const Invoker& invoker5, const Invoker& invoker6, const Invoker& invoker7, const Invoker& invoker8);
Invoker make_invoker (size_t invokers_count, const Invoker* invokers);

#include <script/detail/invoker.inl>

}

#endif
