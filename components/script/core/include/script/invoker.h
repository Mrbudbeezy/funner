#ifndef SCRIPTLIB_INVOKER_HEADER
#define SCRIPTLIB_INVOKER_HEADER

#include <stl/string_fwd>

#include <script/stack.h>

namespace script
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сигнатура шлюза
///////////////////////////////////////////////////////////////////////////////////////////////////
class InvokerSignature
{
  public:  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    InvokerSignature  ();
    InvokerSignature  (const InvokerSignature&);
    ~InvokerSignature ();

    InvokerSignature& operator = (const InvokerSignature&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип возвращаемого значения
///////////////////////////////////////////////////////////////////////////////////////////////////
    const std::type_info& ResultType    () const;
    void                  SetResultType (const std::type_info& type); //type хранится как обычная ссылка

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество параметров
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t ParametersCount () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Типы параметров
///////////////////////////////////////////////////////////////////////////////////////////////////
    const std::type_info& ParameterType    (size_t index) const;
    void                  SetParameterType (size_t index, const std::type_info& type);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление / удаление типов параметров
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t AddParameterType        (const std::type_info& type); //type хранится как обычная ссылка
    void   RemoveParameterType     (size_t index);
    void   RemoveAllParameterTypes ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Приведение к строке
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* ToString () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сравнение
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool operator == (const InvokerSignature&) const;
    bool operator != (const InvokerSignature&) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (InvokerSignature&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (InvokerSignature&, InvokerSignature&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерфейс шлюза
///////////////////////////////////////////////////////////////////////////////////////////////////
class IInvoker
{
  public:
    virtual ~IInvoker () {}
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Вызов шлюза с использованием параметров в стеке
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual size_t operator () (IStack&) = 0;  
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение сигнатуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual InvokerSignature GetSignature () = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Простой шлюз - есть поддержка только вызова с использованием параметров в стеке
///  (предназначен как базовый класс для простых пользовательских шлюзов)
///////////////////////////////////////////////////////////////////////////////////////////////////
class SimpleInvoker: public IInvoker
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение сигнатуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    InvokerSignature GetSignature ();
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерфейс шлюзов с типизированной сигнатурой
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Signature> class ISignatureInvoker;

template <class Ret> class ISignatureInvoker<Ret ()>: public IInvoker
{
  public:
    using IInvoker::operator ();
    
    virtual Ret operator () () = 0;
};

template <class Ret, class T1> class ISignatureInvoker<Ret (T1)>: public IInvoker
{
  public:
    using IInvoker::operator ();
    
    virtual Ret operator () (T1) = 0;
};

template <class Ret, class T1, class T2> class ISignatureInvoker<Ret (T1, T2)>: public IInvoker
{
  public:
    using IInvoker::operator ();
    
    virtual Ret operator () (T1, T2) = 0;
};

template <class Ret, class T1, class T2, class T3> class ISignatureInvoker<Ret (T1, T2, T3)>: public IInvoker
{
  public:
    using IInvoker::operator ();
    
    virtual Ret operator () (T1, T2, T3) = 0;
};

template <class Ret, class T1, class T2, class T3, class T4> class ISignatureInvoker<Ret (T1, T2, T3, T4)>: public IInvoker
{
  public:
    using IInvoker::operator ();
    
    virtual Ret operator () (T1, T2, T3, T4) = 0;
};

template <class Ret, class T1, class T2, class T3, class T4, class T5> class ISignatureInvoker<Ret (T1, T2, T3, T4, T5)>: public IInvoker
{
  public:
    using IInvoker::operator ();
    
    virtual Ret operator () (T1, T2, T3, T4, T5) = 0;
};

template <class Ret, class T1, class T2, class T3, class T4, class T5, class T6> class ISignatureInvoker<Ret (T1, T2, T3, T4, T5, T6)>: public IInvoker
{
  public:
    using IInvoker::operator ();
    
    virtual Ret operator () (T1, T2, T3, T4, T5, T6) = 0;
};

template <class Ret, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
class ISignatureInvoker<Ret (T1, T2, T3, T4, T5, T6, T7)>: public IInvoker
{
  public:
    using IInvoker::operator ();
    
    virtual Ret operator () (T1, T2, T3, T4, T5, T6, T7) = 0;
};

template <class Ret, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
class ISignatureInvoker<Ret (T1, T2, T3, T4, T5, T6, T7, T8)>: public IInvoker
{
  public:
    using IInvoker::operator ();
    
    virtual Ret operator () (T1, T2, T3, T4, T5, T6, T7, T8) = 0;
};

template <class Ret, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
class ISignatureInvoker<Ret (T1, T2, T3, T4, T5, T6, T7, T8, T9)>: public IInvoker
{
  public:
    using IInvoker::operator ();
    
    virtual Ret operator () (T1, T2, T3, T4, T5, T6, T7, T8, T9) = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Функция-шлюз между скриптовым движком и C++ кодом
///////////////////////////////////////////////////////////////////////////////////////////////////
class Invoker
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    Invoker  ();
    Invoker  (const Invoker&);
    ~Invoker ();
    
    template <class Fn> Invoker (const Fn& first_overload_fn);
    
    Invoker& operator = (const Invoker&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Перегрузки
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t                  OverloadsCount    () const;
    const InvokerSignature& OverloadSignature (size_t index) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление и удаление перегрузок
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t AddOverload        (IInvoker* invoker); //invoker will be deleted in destructor
    size_t AddOverloads       (const Invoker&);
    void   RemoveOverload     (size_t index);
    void   RemoveAllOverloads ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Вызов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t operator () (IStack& stack) const;
    size_t operator () (size_t overload_index, IStack& stack) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Приведение к сигнатуре
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class Signature> ISignatureInvoker<Signature>* SignatureCast () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (Invoker&);
    
  private:
    void Init (IInvoker*);
  
    IInvoker* OverloadInvoker (size_t index) const;
    
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (Invoker&, Invoker&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание перегруженного шлюза
///////////////////////////////////////////////////////////////////////////////////////////////////
Invoker make_invoker (const Invoker& invoker1, const Invoker& invoker2);
Invoker make_invoker (const Invoker& invoker1, const Invoker& invoker2, const Invoker& invoker3);
Invoker make_invoker (const Invoker& invoker1, const Invoker& invoker2, const Invoker& invoker3, const Invoker& invoker4);
Invoker make_invoker (const Invoker& invoker1, const Invoker& invoker2, const Invoker& invoker3, const Invoker& invoker4,
                      const Invoker& invoker5);
Invoker make_invoker (const Invoker& invoker1, const Invoker& invoker2, const Invoker& invoker3, const Invoker& invoker4,
                      const Invoker& invoker5, const Invoker& invoker6);
Invoker make_invoker (const Invoker& invoker1, const Invoker& invoker2, const Invoker& invoker3, const Invoker& invoker4,
                      const Invoker& invoker5, const Invoker& invoker6, const Invoker& invoker7);
Invoker make_invoker (const Invoker& invoker1, const Invoker& invoker2, const Invoker& invoker3, const Invoker& invoker4,
                      const Invoker& invoker5, const Invoker& invoker6, const Invoker& invoker7, const Invoker& invoker8);
Invoker make_invoker (size_t invokers_count, const Invoker* invokers);

#include <script/detail/invoker.inl>

}

#endif
