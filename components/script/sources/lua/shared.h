#ifndef SCRIPTLIB_LUA_SHARED_HEADER
#define SCRIPTLIB_LUA_SHARED_HEADER

#include <script/interpreter.h>
#include <script/environment.h>

#include <stl/hash_map>

#include <xtl/any.h>
#include <xtl/connection.h>
#include <xtl/shared_ptr.h>
#include <xtl/iterator.h>
#include <xtl/bind.h>

#include <common/strlib.h> //???????????????
#include <common/heap.h>

#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

namespace script
{

namespace lua
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Стек Lua
///////////////////////////////////////////////////////////////////////////////////////////////////
class Stack: public IStack
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    Stack ();
    Stack (lua_State*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние машины Lua
///////////////////////////////////////////////////////////////////////////////////////////////////
    void       SetState (lua_State*);
    lua_State* State    () const { return state; }    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество аргументов в стеке
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Size ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение аргументов из стека
///////////////////////////////////////////////////////////////////////////////////////////////////    
    float       GetFloat   (size_t index);
    int         GetInteger (size_t index);
    void*       GetPointer (size_t index);
    const char* GetString  (size_t index);
    const char* GetSymbol  (size_t index);
    xtl::any&   GetVariant (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Помещение аргументов в стек
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Push       (float value);
    void Push       (int value);
    void Push       (void* pointer);
    void Push       (const char* string);
    void Push       (const xtl::any& object);
    void PushSymbol (const char* string);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление аргументов из стека
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Pop (size_t arguments_count);
    
  private:
    lua_State* state;    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Метатаблица Lua
///////////////////////////////////////////////////////////////////////////////////////////////////
class Metatable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Metatable  (lua_State* state, const char* name, InvokerRegistry& registry);
    ~Metatable ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Номер таблицы
///////////////////////////////////////////////////////////////////////////////////////////////////
//    int Index () const { return table_index; }

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация/удаление шлюзов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RegisterInvoker   (const char* invoker_name, Invoker& invoker);
    void UnregisterInvoker (const char* invoker_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление метатаблицы
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Destroy ();

  private:
    Metatable (const Metatable&); //no impl
    Metatable& operator = (const Metatable&); //no impl

  private:  
    InvokerRegistry&     registry;                         //реестр шлюзов
    lua_State*           state;                            //состояние lua
    stl::string          table_name;                       //имя таблицы
    xtl::auto_connection on_register_invoker_connection;   //соединение регистрации шлюза
    xtl::auto_connection on_unregister_invoker_connection; //соединение удаления шлюза    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерпретатор Lua
///////////////////////////////////////////////////////////////////////////////////////////////////
class Interpreter: public IInterpreter
{
  public:
    typedef xtl::shared_ptr<Environment> EnvironmentPointer;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Interpreter  (const EnvironmentPointer&);
    ~Interpreter ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя интерпретатора
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Name ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Стек аргументов
///////////////////////////////////////////////////////////////////////////////////////////////////
    IStack& Stack ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка наличия функции
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool HasFunction (const char* name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Выполнение буфера интерпретации луа
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DoCommands (const char* buffer_name, const void* buffer, size_t buffer_size, const LogFunction& log);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вызов функции луа
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Invoke (size_t arguments_count, size_t results_count);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddRef  ();
    void Release ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация/удаление шлюзов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RegisterInvoker   (const char* invoker_name, Invoker& invoker);
    void UnregisterInvoker (const char* invoker_name);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация/удаление реестров
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RegisterInvokerRegistry   (const char* registry_name, InvokerRegistry& registry);
    void RegisterGlobalRegistry    (InvokerRegistry&);
    void UnregisterInvokerRegistry (const char* invoker_registry);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск метатаблицы
///////////////////////////////////////////////////////////////////////////////////////////////////
    Metatable* FindMetatable (const char* name) const;

  private:
    typedef stl::hash_map<stl::hash_key<const char*>, Metatable*> MetatableMap;

  private:
    lua_State*            state;                            //состояние машины Lua    
    lua::Stack            stack;                            //стек аргументов    
    size_t                ref_count;                        //счётчик активных ссылок    
    xtl::auto_connection  on_register_invoker_connection;   //соединение на событие регистрации шлюза
    xtl::auto_connection  on_unregister_invoker_connection; //соединение на событие удаления шлюза
    xtl::auto_connection  on_create_registry_connection;    //соединение на событие создания реестра
    xtl::auto_connection  on_remove_registry_connection;    //соединение на событие удаления реестра    
    EnvironmentPointer    environment;                      //скриптовое окружение
    MetatableMap          metatables;                       //карта метатаблиц
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вызов шлюза / удаление объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
int invoke_dispatch (lua_State*);
int destroy_object  (lua_State*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тэг пользовательских данных
///////////////////////////////////////////////////////////////////////////////////////////////////
extern const char* USER_DATA_TAG;

}

}

#endif
