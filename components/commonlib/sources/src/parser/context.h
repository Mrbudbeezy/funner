#include <stddef.h>
#include <common/parser.h>
#include <stl/vector>

namespace common
{

//implementation forwards
struct ParseTextBuffer;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исключение: буфер разбора слишком велик
///////////////////////////////////////////////////////////////////////////////////////////////////
class ParseBufferTooLargeException: public stl::length_error
{
  public:
    ParseBufferTooLargeException (const char* message) : length_error (message) {}
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контекст разбора
///////////////////////////////////////////////////////////////////////////////////////////////////
class ParseContext
{
  public:
    ParseContext  (ParseLog* log = NULL);
    ~ParseContext ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Возвращение построенного дерева разбора
///////////////////////////////////////////////////////////////////////////////////////////////////
    ParseTreeImpl* GetParseTree () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с текстовыми буферами
///////////////////////////////////////////////////////////////////////////////////////////////////
    char*       AttachTextSource  (const char* file_name); //NULL - file not found
    char*       AttachTextSource  (const char* name,const char* buf,size_t buf_size);
    const char* GetTextSourceName (void* buf_ptr) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с атрибутами
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BeginElement (const char* name,const char* source_name="",size_t line=0);
    void EndElement   ();
    void AppendAttr   (const char*);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Определение границ фрейма
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BeginFrame ();
    void EndFrame   ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя текущего обрабатываемого узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetCurrentNodeName () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с протоколом ошибок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LogError       (const char* file_name,size_t line,const char* format,...);
    void LogWarning     (const char* file_name,size_t line,const char* format,...);
    void VLogError      (const char* file_name,size_t line,const char* format,va_list list);
    void VLogWarning    (const char* file_name,size_t line,const char* format,va_list list);
    void LogFatalError  (const char* format,...);
    void VLogFatalError (const char* format,va_list list);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Резервирование памяти для буфера разбора
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool Reserve (size_t nodes_count,size_t attrs_count);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка коэффициента роста буфера разбора
///////////////////////////////////////////////////////////////////////////////////////////////////    
    void   SetGrow (size_t);
    size_t GetGrow () const { return grow_koef; }

  private:       
    void Resize (size_t);
    template <class T> T* Alloc ();

  private:
    typedef stl::vector<size_t> FrameStack;

    ParseLog*  log;               //протокол разбора
    FrameStack frame_offset;      //стек узлов (используется при построении дерева)
    size_t     cur_argc;          //текущее значение счётчика атрибутов
    size_t     grow_koef;         //коэффициент роста буфера разбора
    char       *buf, *pos, *end;  //буфер разбора
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Inlines
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
inline T* ParseContext::Alloc ()
{
  if ((size_t)(end-pos) < sizeof (T))
    Resize (sizeof (T));

  T* res = (T*)pos;
        
  pos += sizeof (T);  
  
  return res;
}

inline void ParseContext::AppendAttr (const char* attr)
{
  *Alloc<char*> () = (char*)attr;
  cur_argc++;
}

}
