#ifndef COMMONLIB_STREAMS_HEADER
#define COMMONLIB_STREAMS_HEADER

#include <common/file.h>
#include <common/strlib.h>
#include <math/mathlib.h>
#include <stl/string>
#include <stl/iterator>
#include <stl/stack>

#include <stl/auto_ptr.h>
#include <xtl/functional_fwd>

namespace common
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исключения
///////////////////////////////////////////////////////////////////////////////////////////////////
struct WrongWxfTagExceptionTag; //неверное имя WXF тэга

typedef DerivedException<Exception,WrongWxfTagExceptionTag> WrongWxfTagException;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текстовый поток вывода с буферизированным выводом
///////////////////////////////////////////////////////////////////////////////////////////////////
//+Unicode, +encoding, +locale info
class OutputTextStream
{
  public:
    enum { DEFAULT_BUFFER_SIZE = 8192 };

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
             OutputTextStream  ();
    explicit OutputTextStream  (size_t buffer_size);
    explicit OutputTextStream  (const char* file_name,size_t buffer_size=DEFAULT_BUFFER_SIZE);
    explicit OutputTextStream  (const File& file,size_t buffer_size=DEFAULT_BUFFER_SIZE);
             ~OutputTextStream ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Печать в текстовый поток
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Printf  (const char* format,...);
    void VPrintf (const char* format,va_list list);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вывод строки
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Print (const char* string);
    void Print (const char* string,size_t string_length);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединение файла
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BindFile   (const File&);
    void BindFile   (const char* file_name);
    void UnbindFile ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление внутренним буфером
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetBufferSize () const;
    void   SetBufferSize (size_t new_buffer_size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс внутренних буферов в файл с последующим вызовом File::Flush
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Flush ();

  private:
    OutputTextStream (const OutputTextStream&);
    OutputTextStream& operator = (const OutputTextStream&);

  private:
    struct Impl;
    Impl*  impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый класс текстового сериализатора
///////////////////////////////////////////////////////////////////////////////////////////////////
class TextSerializer
{
  public:
    TextSerializer (OutputTextStream& stream,const char* separator = " ");
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сериализация базовых типов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Write (bool value);
    void Write (char value);
    void Write (unsigned char value);
    void Write (short value);
    void Write (unsigned short value);
    void Write (int value);
    void Write (unsigned int value);
    void Write (long value);
    void Write (unsigned long value);
    void Write (float value);
    void Write (double value);
    void Write (long double value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сериализация строк
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Write (const char* string);

    template <class Traits,class Allocator>
    void Write (const stl::basic_string<char,Traits,Allocator>& string);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сериализация математических типов
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T,size_t size> void Write (const math::vec<T,size>& vector);
    template <class T,size_t size> void Write (const math::matrix<T,size>& matrix);
    template <class T>             void Write (const math::quat<T>& quaternion);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вывод разделителя
///////////////////////////////////////////////////////////////////////////////////////////////////
    void WriteSeparator ();

  protected:  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Поток сериализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    OutputTextStream& Stream () const { return stream; }
        
  private:  
    OutputTextStream& stream;
    stl::string       separator;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Итератор вывода в текстовый поток сериализации (конвенция - STL)
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T,class SerializerType>
class TextSerializerIterator
{
  public:
    typedef T                        value_type;
    typedef void                     difference_type;
    typedef void                     pointer;
    typedef void                     reference;
    typedef stl::output_iterator_tag iterator_category;
    typedef SerializerType           serializer_type;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор и присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////    
    TextSerializerIterator (serializer_type& serializer);

    TextSerializerIterator& operator = (const value_type& value);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Операции доступа
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextSerializerIterator& operator *  ()    { return *this; }
    TextSerializerIterator& operator ++ ()    { return *this; }
    TextSerializerIterator& operator ++ (int) { return *this; }

  private:
    serializer_type& serializer;
    bool             first_output;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Упрощённая форма создания итератора
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T,class SerializerType>
TextSerializerIterator<T,SerializerType> make_iterator (SerializerType& serializer);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сериализатор WXF 
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class TextSerializerType>
class BasicWxfSerializer
{
  public:
    typedef TextSerializerType TextSerializer;

    enum { 
      DEFAULT_FRAME_INDENT      = 2, //величина отступа фрейма 
      DEFAULT_ATTRIBUTES_INDENT = 16 //величина отступа списка атрибутов от имени тэга
    };
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    BasicWxfSerializer  (const File& file,
                         size_t      frame_indent = DEFAULT_FRAME_INDENT,
                         size_t      attr_indent  = DEFAULT_ATTRIBUTES_INDENT);
    BasicWxfSerializer  (const char* file_name,
                         size_t      frame_indent = DEFAULT_FRAME_INDENT,
                         size_t      attr_indent  = DEFAULT_ATTRIBUTES_INDENT);
    ~BasicWxfSerializer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с фреймами
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BeginFrame (const char* frame_tag);
    void EndFrame   ();

    template <class T> void BeginFrame (const char* frame_tag,const T& value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сериализация атрибутов
///////////////////////////////////////////////////////////////////////////////////////////////////
                       void Write (const char* tag);
    template <class T> void Write (const char* tag,const T& value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сериализация массивов и диапозонов атрибутов
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T>      void Write (const char* tag,size_t count,const T& value);
    template <class T>      void Write (const char* tag,size_t count,const T* array);
    template <class T>      void Write (const char* tag,size_t count,T* array);
    template <class InIter> void Write (const char* tag,InIter first,InIter last);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вставка коментария
///////////////////////////////////////////////////////////////////////////////////////////////////
    void WriteComment (const char* comment);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество линий
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetLinesCount () const { return line_number; }
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Досрочное завершение сериализации с закрытием файла (последующая сериализация вызовет исключение)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void CloseFile ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Печать отступа
///////////////////////////////////////////////////////////////////////////////////////////////////
    void WriteIndent ();
    void WriteIndent (size_t indent);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Диспетчер вывода интервалов
///////////////////////////////////////////////////////////////////////////////////////////////////    
    template <class Iter> void WriteDispatch (const char*,Iter,Iter,stl::input_iterator_tag);
    template <class Iter> void WriteDispatch (const char*,Iter,Iter,stl::int_iterator_tag);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сериализация некоторых типов в соответствии с форматом WXF
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> 
    void WriteValue (const T&,size_t indent);

    template <class T,size_t size>
    void WriteValue (const math::matrix<T,size>& matrix,size_t indent);
    
    template <class Traits,class Allocator>
    void WriteValue (const stl::basic_string<char,Traits,Allocator>& string,size_t indent);

    void WriteValue (const char* string,size_t indent);
    void WriteValue (char value,size_t indent);
    void WriteValue (unsigned char value,size_t attr_indent);
    
    template <class T>             void WriteEnumValue (const T&);    
    template <class T,size_t size> void WriteEnumValue (const math::matrix<T,size>&);

  private: 
    OutputTextStream stream;
    TextSerializer   serializer;
    size_t           frame_indent;
    size_t           attr_indent;
    size_t           indent;
    size_t           line_number;
    size_t           frame_start_line_number;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сериализатор базовых типов в WXF формат
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef BasicWxfSerializer<TextSerializer> WxfSerializer;

#include <common/detail/streams.inl>


//////////////////NEW!!!

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер потоков вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
class OutputStreamBuffer
{
  public:
    enum { DEFAULT_BUFFER_SIZE = 8192 };
    
    typedef xtl::function<size_t (const void* buffer, size_t buffer_size)> WriteFunction;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    OutputStreamBuffer  (size_t buffer_size = DEFAULT_BUFFER_SIZE);
    OutputStreamBuffer  (const WriteFunction& writer, size_t buffer_size = DEFAULT_BUFFER_SIZE);
    ~OutputStreamBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Запись
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Write (const void* buffer, size_t size);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление размером буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Size   () const;
    void   Resize (size_t buffer_size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединение пользовательского буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUserBuffer (void* buffer, size_t size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Функция записи данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                 SetWriter (const WriteFunction&);
    const WriteFunction& Writer    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Функция записи данных по умолчанию
///////////////////////////////////////////////////////////////////////////////////////////////////
    static size_t DefaultWriter (const void* buffer, size_t size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Flush ();    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (OutputStreamBuffer&);

  private:
    OutputStreamBuffer (const OutputStreamBuffer&); //no impl
    OutputStreamBuffer& operator = (const OutputStreamBuffer&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (OutputStreamBuffer&, OutputStreamBuffer&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер потоков ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputStreamBuffer
{
  public:
    enum { DEFAULT_BUFFER_SIZE = 8192 };
    
    typedef xtl::function<size_t (void* buffer, size_t buffer_size)> ReadFunction;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputStreamBuffer  (size_t buffer_size = DEFAULT_BUFFER_SIZE);
    InputStreamBuffer  (const ReadFunction& reader, size_t buffer_size = DEFAULT_BUFFER_SIZE);
    ~InputStreamBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Чтение
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Read (void* buffer, size_t size);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление размером буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Size   () const;
    void   Resize (size_t buffer_size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединение пользовательского буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUserBuffer (void* buffer, size_t size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Функция чтения данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                SetReader (const ReadFunction&);
    const ReadFunction& Reader    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Функция чтения данных по умолчанию
///////////////////////////////////////////////////////////////////////////////////////////////////
    static size_t DefaultReader (void* buffer, size_t size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (InputStreamBuffer&);

  private:
    InputStreamBuffer (const InputStreamBuffer&); //no impl
    InputStreamBuffer& operator = (const InputStreamBuffer&); //no impl    

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (InputStreamBuffer&, InputStreamBuffer&);

}

#endif
