#ifndef __COMMONLIB_PARSER__
#define __COMMONLIB_PARSER__

#include <math/mathlib.h>
#include <stl/string>
#include <stdlib.h>

namespace common
{

//implementation forwards
struct ParseTreeImpl;
class  ParseNode;

template <class NodeType> class ParseNodeIterator;
template <class NodeType> class ParseNamesakeIterator;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип сообщения протокола парсера
///////////////////////////////////////////////////////////////////////////////////////////////////
enum ParseLogMessageType
{
  PARSE_LOG_FATAL_ERROR, //критическая ошибка
  PARSE_LOG_ERROR,       //ошибка
  PARSE_LOG_WARNING      //предупреждение
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Протокол парсера
///////////////////////////////////////////////////////////////////////////////////////////////////
class ParseLog
{
  public: 
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы и присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////  
    ParseLog  ();
    ~ParseLog ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка наличия ошибок и сообщений
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool HasErrors   () const;
    bool HasWarnings () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Протоколирование ошибок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Error    (const char* file_name,size_t line,const char* format,...);
    void Warning  (const char* file_name,size_t line,const char* format,...);
    void Error    (ParseNode* node,const char* format,...);
    void Warning  (ParseNode* node,const char* format,...);
    void VError   (const char* file_name,size_t line,const char* format,va_list list);
    void VWarning (const char* file_name,size_t line,const char* format,va_list list);
    void VError   (ParseNode* node,const char* format,va_list list);
    void VWarning (ParseNode* node,const char* format,va_list list);

    void FatalError  (const char* format,...);
    void VFatalError (const char* format,va_list list);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перебор сообщений
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t              MessagesCount () const;
    const char*         Message       (size_t index) const; //сделать выброс исключения по неверному индексу!!!!
    ParseLogMessageType MessageType   (size_t index) const;

  private:
    ParseLog (const ParseLog&);
    void operator = (const ParseLog&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Узел дерева разбора
///////////////////////////////////////////////////////////////////////////////////////////////////
class ParseNode
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Тэг
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Tag     () const;                 //имя узла
    bool        TestTag (const char* name) const; //проверяет совпадение имени  

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с атрибутами
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t       AttributesCount () const;
    const char*  Attribute       (size_t index) const;
    const char*  Attribute       (size_t index,const char* default_value) const;
    const char** Attributes      () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перебор вложенных узлов
///////////////////////////////////////////////////////////////////////////////////////////////////
    ParseNode* First () const; //первый потомок
    ParseNode* Next  () const; //следующий узел на данном уровне иерархии

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перебор узлов по имени
///////////////////////////////////////////////////////////////////////////////////////////////////
    ParseNode* First (const char* tag) const; //первый потомок с указанным именем
    ParseNode* Next  (const char* tag) const; //следующий узел на данном уровне иерархии с указанным именем

    ParseNode* NextNamesake () const; //следующий "тёзка" на данном уровне иерархии
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Информация о расположении узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* SourceName () const; //имя исходного текста, в котором расположен узел
    size_t      LineNumber () const; //номер строки

  private:
    ParseNode  ();
    ParseNode  (const ParseNode&);
    ~ParseNode ();

    void operator = (const ParseNode&);

  private:  
    char data [1];
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дерево разбора
///////////////////////////////////////////////////////////////////////////////////////////////////
class ParseTree
{
  public:
    typedef ParseNode Node;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    ParseTree  (const char* file_name,const char* format="auto");
    ParseTree  (const char* name,const char* buf,size_t buf_size,const char* format="auto");
    ParseTree  (ParseLog& log,const char* file_name,const char* format="auto");
    ParseTree  (ParseLog& log,const char* name,const char* buf,size_t buf_size,const char* format="auto");
    ~ParseTree ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Корневой узел дерева разбора
///////////////////////////////////////////////////////////////////////////////////////////////////
    Node* Root () const;

  private:
    ParseTree (const ParseTree&);
    void operator = (const ParseTree&);

  private:
    ParseTreeImpl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Класс производящий чтение атрибутов и их массивов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class AttributeReaderType>
class ParseAttributeReader: public AttributeReaderType
{
  public:
    typedef AttributeReaderType BaseAttributeReader;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ParseAttributeReader (size_t attributes_count,const char** attributes);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Чтение одиночных атрибутов
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> void Read (T& object);
    template <class T> void Read (T& object,const T& default_value);
    
    const char* ReadString (const char* default_value = NULL);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Чтение массива атрибутов
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class OutIter> size_t ReadArray (OutIter first);
    template <class OutIter> size_t ReadArray (OutIter first,size_t count);
    template <class OutIter> size_t ReadArray (OutIter first,size_t count,size_t step);
    
  private:
    template <class OutIter>   bool ReadIter (OutIter& iter);
    template <class Container> bool ReadIter (stl::front_insert_iterator<Container>& iter);
    template <class Container> bool ReadIter (stl::back_insert_iterator<Container>& iter);
    template <class Container> bool ReadIter (stl::insert_iterator<Container>& iter);
    template <class T>         bool ReadIter (T*);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Узлел дерева разбора позволяющий типизированно читать атрибуты
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class AttributeReaderType>
class ParseReadableNode: public ParseNode
{
  public:
    typedef ParseAttributeReader<AttributeReaderType>     AttributeReader;
    typedef typename AttributeReader::BaseAttributeReader BaseAttributeReader;
    typedef ParseReadableNode<AttributeReaderType>        Node;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Перебор вложенных узлов
///////////////////////////////////////////////////////////////////////////////////////////////////  
    Node* First () const;
    Node* Next  () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перебор узлов по имени
///////////////////////////////////////////////////////////////////////////////////////////////////
    Node* First (const char* tag) const;
    Node* Next  (const char* tag) const;

    Node* NextNamesake () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение парсера атрибутов
///////////////////////////////////////////////////////////////////////////////////////////////////
    AttributeReader     Reader     () const;
    AttributeReader     Reader     (const char* tag) const;
    BaseAttributeReader BaseReader () const;
    BaseAttributeReader BaseReader (const char* tag) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Чтение атрибутов
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> void Read (const char* tag,T& object) const;
    template <class T> void Read (const char* tag,T& object,const T& default_value) const;

    template <class Traits,class Allocator> 
    void Read (const char* tag,stl::basic_string<char,Traits,Allocator>& string,const char* default_value) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сокращённые версии чтения атрибутов базовых типов
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char*  ReadString (const char* tag,const char* default_value = NULL) const;
    int          ReadInt    (const char* tag,int default_value = 0) const;
    unsigned int ReadUInt   (const char* tag,unsigned int default_value = 0) const;
    float        ReadFloat  (const char* tag,float default_value = 0.0f) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Чтение массива атрибутов
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class OutIter>
    size_t ReadArray (const char* tag,OutIter first) const;

    template <class OutIter>
    size_t ReadArray (const char* tag,OutIter first,size_t count) const;

    template <class OutIter>
    size_t ReadArray (const char* tag,OutIter first,size_t count,size_t start) const;

    template <class OutIter>
    size_t ReadArray (const char* tag,OutIter first,size_t count,size_t start,size_t step) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка значения атрибутов
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> bool Test (const char* tag,const T& value) const;
    template <class T> bool Test (const char* tag,size_t attr_index,const T& value) const;
                       bool Test (const char* tag,const char* string) const;
                       bool Test (const char* tag,size_t attr_index,const char* string) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка наличия потомка
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool Present (const char* tag);

  private:
    ~ParseReadableNode () {}    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Итератор обхода узлов дерева разбора
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class NodeType,class NextFun>
class ParseIterator
{
  public:
    typedef NodeType Node;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    ParseIterator ();
    ParseIterator (ParseNode*);
    
    template <class NodeType1,class NextFun1>
    ParseIterator (const ParseIterator<NodeType1,NextFun1>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////    
    ParseIterator& operator = (ParseNode*);
    
    template <class NodeType1,class NextFun1> 
    ParseIterator& operator = (const ParseIterator<NodeType1,NextFun1>&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Переход по уровню иерархии
///////////////////////////////////////////////////////////////////////////////////////////////////
    ParseIterator& operator ++ ();
    ParseIterator  operator ++ (int);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение текущего узла дерева разбора
///////////////////////////////////////////////////////////////////////////////////////////////////
    Node* operator -> () const;
    Node& operator *  () const;

    operator Node* () const { return (Node*)node; }

  private:
    ParseNode* node;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Парсер
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class AttributeReaderType>
class BasicParser: public ParseTree
{
  private:
    struct NextNodeFun         { ParseNode* operator () (ParseNode* node) const; };
    struct NextNamesakeNodeFun { ParseNode* operator () (ParseNode* node) const; };

  public:
    typedef ParseReadableNode<AttributeReaderType>  Node;
    typedef typename Node::AttributeReader          AttributeReader;
    typedef typename Node::BaseAttributeReader      BaseAttributeReader;
    typedef ParseIterator<Node,NextNodeFun>         Iterator;
    typedef ParseIterator<Node,NextNamesakeNodeFun> NamesakeIterator;
    typedef ParseLog                                Log;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    BasicParser (const char* file_name,const char* format="auto");
    BasicParser (const char* name,const char* buf,size_t buf_size,const char* format="auto");
    BasicParser (ParseLog& log,const char* file_name,const char* format="auto");
    BasicParser (ParseLog& log,const char* name,const char* buf,size_t buf_size,const char* format="auto");

///////////////////////////////////////////////////////////////////////////////////////////////////
///Корень дерева разбора
///////////////////////////////////////////////////////////////////////////////////////////////////
    Node* Root () const;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый класс чтения атрибутов
///////////////////////////////////////////////////////////////////////////////////////////////////
class BasicAttributeReader
{
  public: 
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    BasicAttributeReader (size_t attributes_count,const char** attributes);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Указатель на текущий атрибут / список доступных атрибутов
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char*  GetAttribute     () const;
    const char** GetAttributeList () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество доступных атрибутов / проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////        
    size_t Available () const;
    bool   IsEmpty   () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Позиционирование
///////////////////////////////////////////////////////////////////////////////////////////////////    
    size_t Tell  () const; //номер текущего атрибута
    bool   Seek  (size_t position);
    bool   Skip  (size_t attributes_count);
    void   Reset ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Чтение базовых типов
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool Read (bool&);
    bool Read (char&);
    bool Read (unsigned char&);
    bool Read (short&);
    bool Read (unsigned short&);
    bool Read (int&);
    bool Read (unsigned int&);
    bool Read (long&);
    bool Read (unsigned long&);
    bool Read (float&);
    bool Read (double&);
    bool Read (long double&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Чтение строк
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool Read (const char*& string_ptr);

    template <class Traits,class Allocator>
    bool Read (stl::basic_string<char,Traits,Allocator>& string);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Чтение математических типов
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T,size_t size> bool Read (math::vec<T,size>&);
    template <class T,size_t size> bool Read (math::matrix<T,size>&);
    template <class T>             bool Read (math::quat<T>&);

  private:
    const char **start, **pos, **finish;
};

//определение типа для парсера "по умолчанию"
typedef BasicParser<BasicAttributeReader> Parser;

#include <common/impl/parser.inl>

}

#endif
