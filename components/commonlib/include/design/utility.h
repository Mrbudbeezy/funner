#ifndef DESIGN_UTILITY_HEADER
#define DESIGN_UTILITY_HEADER

namespace design
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение адреса объекта (адрес возвращается даже если объект имеет переопределённый оператор &)
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> T* addressof (T&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оболочка над ссылкой
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> class reference_wrapper
{
  public:
    typedef T type;
  
    reference_wrapper (T&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Приведение к ссылочному типу
///////////////////////////////////////////////////////////////////////////////////////////////////
    operator T& () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение ссылки и указателя из обёртки
///////////////////////////////////////////////////////////////////////////////////////////////////
    T& get_reference () const;
    T* get_pointer   () const;

  private:
    T* ptr;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение ссылки и указателя из обёртки
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> T& get_reference (const reference_wrapper<T>&);
template <class T> T* get_pointer   (const reference_wrapper<T>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание обёртки над ссылкой
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> const reference_wrapper<T>       ref  (T&);
template <class T> const reference_wrapper<T const> cref (T const&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Класс объекты которого невозможно скопировать
///////////////////////////////////////////////////////////////////////////////////////////////////
namespace noncopyable_namespace //защита от несанкционированного поиска по Кёнигу
{

class noncopyable
{
  public:
    noncopyable () {}

  private:
    noncopyable (const noncopyable&); //no impl
    void operator = (const noncopyable&); //no impl
};

}

typedef noncopyable_namespace::noncopyable noncopyable;

#include <design/impl/utility.inl>

}

#endif
