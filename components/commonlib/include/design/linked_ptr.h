#ifndef DESIGN_LINKED_POINTER_HEADER
#define DESIGN_LINKED_POINTER_HEADER

#include <design/smart_ptr.h>

namespace stl
{

//implementation forwards
struct bidirectional_iterator_tag;

}

namespace design
{

//implementation forwards
template <class Ptr> class linked_ptr_iterator;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Указатели связанные в цепочку
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Ptr>
class linked_ptr: public smart_ptr_storage<Ptr>
{
  typedef smart_ptr_storage<Ptr> base;
  public:
    typedef typename base::element_type                                    element_type;
    typedef element_type*                                                  pointer;
    typedef typename base::template get_parameter_type<linked_ptr>::result this_parameter_type;
    typedef linked_ptr_iterator<linked_ptr>                                iterator;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    linked_ptr  ();
    linked_ptr  (element_type*);
    linked_ptr  (parameter_type);
    linked_ptr  (element_type*,linked_ptr& next);
    linked_ptr  (parameter_type,linked_ptr& next);
    ~linked_ptr ();

    template <class Ptr1> linked_ptr (const linked_ptr<Ptr1>&);
    template <class Ptr1> linked_ptr (const linked_ptr<Ptr1>&,linked_ptr& next);
    template <class Ptr1> linked_ptr (linked_ptr<Ptr1>&);
    template <class Ptr1> linked_ptr (linked_ptr<Ptr1>&,linked_ptr& next);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    linked_ptr& operator = (element_type*);
    linked_ptr& operator = (parameter_type);

    template <class T1> linked_ptr& operator = (const linked_ptr<T1>&);
    template <class T1> linked_ptr& operator = (linked_ptr<T1>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Селекторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    using base::operator *;
    using base::operator ->;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление связями
///////////////////////////////////////////////////////////////////////////////////////////////////
    void connect    (linked_ptr& next);
    void disconnect ();
    bool connected  () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Предыдущий и следующий указатели
///////////////////////////////////////////////////////////////////////////////////////////////////
    linked_ptr&       prev ();
    linked_ptr&       next ();
    const linked_ptr& prev () const;
    const linked_ptr& next () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение итератора
///////////////////////////////////////////////////////////////////////////////////////////////////
    iterator get_iterator () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void swap (linked_ptr&);

  private:
    void connect_internal (linked_ptr& next);
    void update_links ();

  private:
    linked_ptr *prev_ptr, *next_ptr;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> void swap (linked_ptr<T>&,linked_ptr<T>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Итератор указателей связанных в цепочку
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Ptr>
class linked_ptr_iterator
{
  typedef typename linked_ptr<Ptr>::element_type element_type;
  public:
    typedef Ptr                              linked_ptr;
    typedef element_type                     value_type;
    typedef size_t                           size_type;
    typedef ptrdiff_t                        difference_type;
    typedef element_type*                    pointer;
    typedef element_type&                    reference;
    typedef stl::bidirectional_iterator_tag  iterator_category;

/////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
/////////////////////////////////////////////////////////////////////////////////////////////
    linked_ptr_iterator ();
    linked_ptr_iterator (const linked_ptr_iterator&);
    linked_ptr_iterator (const linked_ptr&);

/////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
/////////////////////////////////////////////////////////////////////////////////////////////
    linked_ptr_iterator& operator = (const linked_ptr_iterator&);
    linked_ptr_iterator& operator = (const linked_ptr&);

/////////////////////////////////////////////////////////////////////////////////////////////
///Селекторы
/////////////////////////////////////////////////////////////////////////////////////////////
    reference operator  * () const;
    pointer   operator -> () const;
    
/////////////////////////////////////////////////////////////////////////////////////////////
///Проверка на 0
/////////////////////////////////////////////////////////////////////////////////////////////
    operator typename linked_ptr::test_type* () const { return *current; }

/////////////////////////////////////////////////////////////////////////////////////////////
///Инкремент / декремент
/////////////////////////////////////////////////////////////////////////////////////////////
    linked_ptr_iterator&      operator ++ ();
    linked_ptr_iterator&      operator -- ();
    const linked_ptr_iterator operator ++ (int);
    const linked_ptr_iterator operator -- (int);

/////////////////////////////////////////////////////////////////////////////////////////////
///Сравнение
/////////////////////////////////////////////////////////////////////////////////////////////
    bool operator == (const linked_ptr_iterator&) const;
    bool operator != (const linked_ptr_iterator&) const;
    
/////////////////////////////////////////////////////////////////////////////////////////////
///Получение linked_ptr
/////////////////////////////////////////////////////////////////////////////////////////////
    linked_ptr& get_link () const;

  private:
    const linked_ptr* current;
};

#include <design/impl/ptr_linked.inl>

}

#endif
