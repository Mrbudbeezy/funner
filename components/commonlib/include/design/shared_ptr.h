#ifndef DESIGN_SHARED_POINTER_HEADER
#define DESIGN_SHARED_POINTER_HEADER

#include <design/smart_ptr.h>

namespace design
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Адаптер удаления объектов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
struct default_object_deleter
{
  static void destroy (T*);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Интеллектуальный указатель с подсчётом ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T,class Control=default_object_deleter<T> >
class shared_ptr: public smart_ptr_storage<T*>
{
  template <class T1,class Control1> friend class shared_ptr;
  typedef smart_ptr_storage<T*> base;
  public:
    typedef typename base::element_type element_type;
    typedef element_type*               pointer;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / декструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    shared_ptr  ();
    shared_ptr  (element_type*);
    shared_ptr  (const shared_ptr&);
    ~shared_ptr ();

    template <class T1> shared_ptr (const shared_ptr<T1,Control>&);
    template <class T1> shared_ptr (const shared_ptr<T1,Control>&,static_cast_tag);
    template <class T1> shared_ptr (const shared_ptr<T1,Control>&,const_cast_tag);
    template <class T1> shared_ptr (const shared_ptr<T1,Control>&,dynamic_cast_tag);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    shared_ptr& operator = (element_type*);
    shared_ptr& operator = (const shared_ptr&);

    template <class T1> shared_ptr& operator = (const shared_ptr<T1,Control>&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Операции доступа
///////////////////////////////////////////////////////////////////////////////////////////////////
    using base::operator *;
    using base::operator ->;    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен значений указателей
///////////////////////////////////////////////////////////////////////////////////////////////////
    void swap (shared_ptr&);

  private:
    size_t* count;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Приведение типов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T1,class T2,class Control>
shared_ptr<T1,Control> static_pointer_cast (const shared_ptr<T2,Control>&);

template <class T1,class T2,class Control>
shared_ptr<T1,Control> const_pointer_cast (const shared_ptr<T2,Control>&);

template <class T1,class T2,class Control>
shared_ptr<T1,Control> dynamic_pointer_cast (const shared_ptr<T2,Control>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T,class Control>
void swap (shared_ptr<T,Control>&,shared_ptr<T,Control>&);

#include <design/impl/ptr_shared.inl>

}

#endif
