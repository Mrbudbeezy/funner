#ifndef DESIGN_VARIANT_HEADER
#define DESIGN_VARIANT_HEADER

#include <design/typelist.h>
#include <exception>
#include <typeinfo>

namespace design
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исключение: невозможно сделать приведение от вариантного типа данных
///////////////////////////////////////////////////////////////////////////////////////////////////
class bad_variant_cast: public std::exception
{
  public:
    bad_variant_cast (const std::type_info& source,const std::type_info& target);
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сообщение об ошибке
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* what () const throw () { return "bad variant cast"; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Информация о приводимых типах
///////////////////////////////////////////////////////////////////////////////////////////////////
    const type_info& source_type () const;
    const type_info& target_type () const;
  
  private:
    const std::type_info& source;
    const std::type_info& target;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исключение: невозможно присвоить значение вариантной переменной (read-only)
///////////////////////////////////////////////////////////////////////////////////////////////////
class bad_variant_assign: public std::exception
{
  public:
    bad_variant_assign (const std::type_info& left,const std::type_info& right);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сообщение об ошибке
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* what () const throw () { return "attempt to assign value to read-only variant"; }
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Информация о типах участвующих в присваивании
///////////////////////////////////////////////////////////////////////////////////////////////////
    const type_info& left_type  () const;
    const type_info& right_type () const;

  private:
    const std::type_info& left;
    const std::type_info& right;    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Пользовательское приведение типов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class TargetType,class SourceType>
struct custom_type_caster
{
  static TargetType cast (const SourceType&); //по умолчанию: throw bad_variant_cast
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Приведение вариантных типов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class TargetType,class SourceType>
TargetType variant_cast (const SourceType&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание класса для приведения вариантных типов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class Base,class T>
struct variant_caster_interface: public Base
{
  virtual ~variant_caster_interface () {}

  virtual      operator T () const = 0;
  virtual void operator = (const T&) = 0;

  using Base::operator =;
};

//добавить visitor

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вариантная ссылка на объект невариантного типа данных
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T1=null_type,class T2=null_type,class T3=null_type,class T4=null_type,
          class T5=null_type,class T6=null_type,class T7=null_type,class T8=null_type>
class variant_reference
{
  public:
    template <class Ptr> variant_reference  (Ptr);
                         ~variant_reference ();

    template <class T> variant_reference& operator = (const T&);
    template <class T>                    operator T () const;

  private:
    typedef typename type_manip::unique<
            typename type_manip::accumulate<
            typename type_manip::list<T1,T2,T3,T4,T5,T6,T7,T8>::result,
            type_manip::append>::result>::result type_list;

    typedef typename type_manip::generate_linear_hierarchy<type_list,variant_caster_interface>::result caster_type;

  private:
    caster_type* caster;
    char         buffer [8];
};

#include <design/impl/variant.inl>

}

#endif
