#include <stl/hash_map>
#include <stl/string>
#include <stl/vector>

#include <xtl/bind.h>
#include <xtl/common_exceptions.h>
#include <xtl/connection.h>
#include <xtl/function.h>
#include <xtl/trackable.h>
#include <xtl/token_parser.h>

#include <math/utility.h>

#include <bv/plane_list.h>

#include <common/singleton.h>

#include <sg/camera.h>
#include <sg/input.h>
#include <sg/scene.h>
#include <sg/screen.h>
#include <sg/viewport.h>

#include <input/scene_input.h>

namespace input
{

class InputScene;

typedef xtl::intrusive_ptr<InputScene> InputScenePtr;

typedef bound_volumes::plane_list<float> frustum;

typedef unsigned int touch_t;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние тача
///////////////////////////////////////////////////////////////////////////////////////////////////
enum TouchState
{
  TouchState_Moving,
  TouchState_Pressed,
  TouchState_Released
};

const touch_t MOUSE_TOUCH_ID = touch_t (~0u); //идентификатор тача мыши

///////////////////////////////////////////////////////////////////////////////////////////////////
///Событие нажатия
///////////////////////////////////////////////////////////////////////////////////////////////////
struct TouchEvent
{
  touch_t     touch;      //идентификатор тача
  int         button;     //кнопка
  TouchState  state;      //состояние тача
  math::vec2f position;   //положение
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Порт ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputPort: public xtl::reference_counter, public scene_graph::IViewportListener, public xtl::noncopyable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputPort  (scene_graph::Viewport& in_viewport, bool& in_z_order_changed);
    ~InputPort ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Область вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    scene_graph::Viewport& AttachedViewport () { return viewport; }
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Активна ли область
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsActive () { return is_active; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработчики событий
///////////////////////////////////////////////////////////////////////////////////////////////////    
    void OnViewportChangeArea       (const scene_graph::Rect& new_area, float min_depth_range, float max_depth_range);
    void OnViewportChangeCamera     (scene_graph::Camera* new_camera);
    void OnViewportChangeZOrder     (int);
    void OnViewportChangeActive     (bool new_state);
    void OnViewportChangeInputState (bool state);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Размер тача
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetTouchSize (float size, InputTransformSpace);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработка события нажатия
///////////////////////////////////////////////////////////////////////////////////////////////////
    void OnTouch (const TouchEvent& event, bool& touch_catched);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс состояния нажатий
///////////////////////////////////////////////////////////////////////////////////////////////////
    void ResetTouchState ();

  private:
    void OnSceneChanged  ();
    void OnCameraUpdated ();
    void Update ();

  private:
    scene_graph::Viewport&   viewport;               //область вывода
    bool&                    z_order_changed;        //порядок следования областей ввода изменен
    InputScenePtr            input_scene;            //сцена ввода
    bool                     is_active;              //активность области
    bool                     need_update;            //нужно обновление
    float                    touch_size;             //размер тача
    InputTransformSpace      touch_size_space;       //система координат размеров тача
    math::vec3f              touch_scale;            //коэффициент масштабирования тача    
    xtl::auto_connection     on_camera_updated;      //соединение с событием обновления камеры
    xtl::auto_connection     on_scene_changed;       //соединение с событием изменения сцены
    math::mat4f              normalized_position_tm; //матрица преобразования координат (в систему координат проекции)
    math::mat4f              position_tm;            //матрица преобразования координат (в мировую систему координат)
    math::mat4f              view_proj_tm;           //матрица преобразования координат (proj * inv(view))
    math::mat4f              inv_view_proj_tm;       //матрица обратного преобразования координат (inv (proj * inv(view)))
    frustum                  touch_frustum;          //пирамида тача
};

typedef xtl::intrusive_ptr<InputPort> InputPortPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Слушатель событий
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputEventListener: public xtl::noncopyable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Список слушателей
///////////////////////////////////////////////////////////////////////////////////////////////////
    class List: public xtl::noncopyable
    {
      friend class InputEventListener;
      public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
        List  ();
        ~List ();
        
///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение
///////////////////////////////////////////////////////////////////////////////////////////////////
        void BroadcastTouch (InputPort& input_port, const TouchEvent& event, const math::vec3f& touch_world_position);
        
///////////////////////////////////////////////////////////////////////////////////////////////////
///Отсоединение всех
///////////////////////////////////////////////////////////////////////////////////////////////////
        void DetachAll ();

      private:
        InputEventListener* first;
        InputEventListener* last;
    };
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputEventListener  ();
    ~InputEventListener ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработка события
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void OnBroadcastTouch (InputPort& input_port, const TouchEvent& event, const math::vec3f& touch_world_position) {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединение слушателя к списку
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Attach (List&);
    void Detach ();

  private:
    List*               list;
    InputEventListener* prev;
    InputEventListener* next;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Объект ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputEntity: public xtl::reference_counter, private InputEventListener
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputEntity  (const scene_graph::InputZoneModel& zone, InputScene& scene);
    ~InputEntity ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединенная зона ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
    const scene_graph::InputZoneModel& Zone () { return zone; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработка события нажатия
///////////////////////////////////////////////////////////////////////////////////////////////////
    void OnTouch (InputPort& input_port, const TouchEvent& event, const math::vec3f& touch_world_position, size_t touch_zone_index, const math::vec2f& touch_local_position); 
    
  private:
    void OnBroadcastTouch    (InputPort& input_port, const TouchEvent& event, const math::vec3f& touch_world_position);
    void UpdateNotifications ();
  
  private:  
    const scene_graph::InputZoneModel& zone;
    InputScene&                        scene;
    xtl::auto_connection               on_notifications_changed_connection;
};

typedef xtl::intrusive_ptr<InputEntity> InputEntityPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отображение сцены ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputScene: public xtl::reference_counter, private InputEventListener::List
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputScene  (scene_graph::Scene& scene);
    ~InputScene ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединенная сцена
///////////////////////////////////////////////////////////////////////////////////////////////////
    scene_graph::Scene& Scene () { return scene; }
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение объекта ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputEntityPtr GetEntity (const scene_graph::InputZoneModel&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс состояния нажатий
///////////////////////////////////////////////////////////////////////////////////////////////////
    void ResetTouchState ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработка события
///////////////////////////////////////////////////////////////////////////////////////////////////
    void OnTouch (InputPort& input_port, const TouchEvent& event, const math::vec3f& touch_world_position, const math::vec3f& touch_world_direction, const frustum& touch_frustum, bool& touch_catched);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация слушателей оповещений
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RegisterBroadcastListener (InputEventListener& listener);
    
  private:
    void OnInputZoneDestroyed (const scene_graph::InputZoneModel*);
    void OnInputZoneCreated   (scene_graph::Node&);
    
    struct EntityDesc
    {
      InputEntityPtr       entity;
      xtl::auto_connection on_unbind_connection;
    };
    
  private:
    typedef stl::hash_map<const scene_graph::InputZoneModel*, EntityDesc> EntityMap;

  private:    
    scene_graph::Scene&  scene;
    EntityMap            entities;
    xtl::auto_connection on_entity_created_connection;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Коллекция сцен ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputSceneCollection
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputSceneCollection  ();
    ~InputSceneCollection ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputScenePtr GetScene (scene_graph::Scene&);
    
  private:
    void OnSceneDestroyed (scene_graph::Scene*);    

  private:
    struct SceneDesc
    {
      InputScenePtr        scene;
      xtl::auto_connection on_scene_destroyed;
    };
  
    typedef stl::hash_map<scene_graph::Scene*, SceneDesc> InputSceneMap;    
    
  private:
    InputSceneMap scenes;
};

typedef common::Singleton<InputSceneCollection> InputSceneCollectionSingleton;

}
