#include <stl/hash_map>
#include <stl/string>
#include <stl/vector>

#include <xtl/bind.h>
#include <xtl/common_exceptions.h>
#include <xtl/connection.h>
#include <xtl/function.h>
#include <xtl/trackable.h>
#include <xtl/token_parser.h>

#include <math/utility.h>

#include <bv/plane_list.h>

#include <common/singleton.h>

#include <sg/camera.h>
#include <sg/input.h>
#include <sg/scene.h>
#include <sg/screen.h>
#include <sg/viewport.h>

#include <input/scene_input.h>

namespace input
{

class InputScene;

typedef xtl::intrusive_ptr<InputScene> InputScenePtr;

typedef bound_volumes::plane_list<float> frustum;

typedef unsigned int touch_t;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние тача
///////////////////////////////////////////////////////////////////////////////////////////////////
enum TouchState
{
  TouchState_Moving,
  TouchState_Pressed,
  TouchState_Released
};

const touch_t MOUSE_TOUCH_ID = touch_t (~0u); //идентификатор тача мыши

///////////////////////////////////////////////////////////////////////////////////////////////////
///Событие нажатия
///////////////////////////////////////////////////////////////////////////////////////////////////
struct TouchEvent
{
  touch_t     touch;      //идентификатор тача
  int         button;     //кнопка
  TouchState  state;      //состояние тача
  math::vec2f position;   //положение
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Порт ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputPort: public xtl::reference_counter, public scene_graph::IViewportListener, public xtl::noncopyable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputPort  (scene_graph::Viewport& in_viewport, bool& in_z_order_changed);
    ~InputPort ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Область вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    scene_graph::Viewport& AttachedViewport () { return viewport; }
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Активна ли область
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsActive () { return is_active; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработчики событий
///////////////////////////////////////////////////////////////////////////////////////////////////    
    void OnViewportChangeArea       (const scene_graph::Rect& new_area, float min_depth_range, float max_depth_range);
    void OnViewportChangeCamera     (scene_graph::Camera* new_camera);
    void OnViewportChangeZOrder     (int);
    void OnViewportChangeActive     (bool new_state);
    void OnViewportChangeInputState (bool state);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Размер тача
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetTouchSize (float size, InputTransformSpace);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработка события нажатия
///////////////////////////////////////////////////////////////////////////////////////////////////
    void OnTouch (const TouchEvent& event, bool& touch_catched);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс состояния нажатий
///////////////////////////////////////////////////////////////////////////////////////////////////
    void ResetTouchState ();

  private:
    void OnSceneChanged  ();
    void OnCameraUpdated ();
    void Update ();

  private:
    scene_graph::Viewport&   viewport;               //область вывода
    bool&                    z_order_changed;        //порядок следования областей ввода изменен
    InputScenePtr            input_scene;            //сцена ввода
    bool                     is_active;              //активность области
    bool                     need_update;            //нужно обновление
    float                    touch_size;             //размер тача
    InputTransformSpace      touch_size_space;       //система координат размеров тача
    math::vec3f              touch_scale;            //коэффициент масштабирования тача    
    xtl::auto_connection     on_camera_updated;      //соединение с событием обновления камеры
    xtl::auto_connection     on_scene_changed;       //соединение с событием изменения сцены
    math::mat4f              normalized_position_tm; //матрица преобразования координат (в систему координат проекции)
    math::mat4f              position_tm;            //матрица преобразования координат (в мировую систему координат)
    math::mat4f              view_proj_tm;           //матрица преобразования координат (proj * inv(view))
    frustum                  touch_frustum;          //пирамида тача
};

typedef xtl::intrusive_ptr<InputPort> InputPortPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Объект ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputEntity: public xtl::reference_counter, public xtl::noncopyable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputEntity  (const scene_graph::InputZoneModel& zone);
    ~InputEntity ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединенная зона ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
    const scene_graph::InputZoneModel& Zone () { return zone; }
  
  private:
    const scene_graph::InputZoneModel& zone;
};

typedef xtl::intrusive_ptr<InputEntity> InputEntityPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отображение сцены ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputScene: public xtl::reference_counter, public xtl::noncopyable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputScene  (scene_graph::Scene& scene);
    ~InputScene ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединенная сцена
///////////////////////////////////////////////////////////////////////////////////////////////////
    scene_graph::Scene& Scene () { return scene; }
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение объекта ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputEntityPtr GetEntity (const scene_graph::InputZoneModel&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс состояния нажатий
///////////////////////////////////////////////////////////////////////////////////////////////////
    void ResetTouchState ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработка события нажатия
///////////////////////////////////////////////////////////////////////////////////////////////////
    void OnTouch (const TouchEvent& event, const math::vec3f& touch_world_position, const frustum& touch_frustum, bool& touch_catched);
    
  private:
    void OnInputZoneDestroyed (const scene_graph::InputZoneModel*);
    
    struct EntityDesc
    {
      InputEntityPtr       entity;
      xtl::auto_connection on_destroy_connection;
    };
    
  private:
    typedef stl::hash_map<const scene_graph::InputZoneModel*, EntityDesc> EntityMap;

  private:    
    scene_graph::Scene& scene;
    EntityMap           entities;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Коллекция сцен ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputSceneCollection
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputSceneCollection  ();
    ~InputSceneCollection ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputScenePtr GetScene (scene_graph::Scene&);
    
  private:
    void OnSceneDestroyed (scene_graph::Scene*);    

  private:
    struct SceneDesc
    {
      InputScenePtr        scene;
      xtl::auto_connection on_scene_destroyed;
    };
  
    typedef stl::hash_map<scene_graph::Scene*, SceneDesc> InputSceneMap;    
    
  private:
    InputSceneMap scenes;
};

typedef common::Singleton<InputSceneCollection> InputSceneCollectionSingleton;

}
