#include <stl/hash_map>
#include <stl/string>
#include <stl/vector>

#include <xtl/bind.h>
#include <xtl/common_exceptions.h>
#include <xtl/connection.h>
#include <xtl/function.h>
#include <xtl/trackable.h>
#include <xtl/token_parser.h>

#include <common/singleton.h>

#include <sg/camera.h>
#include <sg/scene.h>
#include <sg/screen.h>
#include <sg/viewport.h>

#include <input/scene_input.h>

namespace input
{

class InputScene;

typedef xtl::intrusive_ptr<InputScene> InputScenePtr;

typedef unsigned int touch_t;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние тача
///////////////////////////////////////////////////////////////////////////////////////////////////
enum TouchState
{
  TouchState_Moving,
  TouchState_Pressed,
  TouchState_Released
};

const touch_t MOUSE_TOUCH_ID = touch_t (~0u); //идентификатор тача мыши

///////////////////////////////////////////////////////////////////////////////////////////////////
///Событие нажатия
///////////////////////////////////////////////////////////////////////////////////////////////////
struct TouchEvent
{
  touch_t     touch;      //идентификатор тача
  int         button;     //кнопка
  TouchState  state;      //состояние тача
  math::vec2f position;   //положение
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Порт ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputPort: public xtl::reference_counter, public scene_graph::IViewportListener, public xtl::noncopyable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputPort  (scene_graph::Viewport& in_viewport, bool& in_z_order_changed);
    ~InputPort ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Область вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    scene_graph::Viewport& AttachedViewport () { return viewport; }
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Активна ли область
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsActive () { return is_active; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработчики событий
///////////////////////////////////////////////////////////////////////////////////////////////////    
    void OnViewportChangeArea       (const scene_graph::Rect& new_area, float min_depth_range, float max_depth_range);
    void OnViewportChangeCamera     (scene_graph::Camera* new_camera);
    void OnViewportChangeZOrder     (int);
    void OnViewportChangeActive     (bool new_state);
    void OnViewportChangeInputState (bool state);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработка события нажатия
///////////////////////////////////////////////////////////////////////////////////////////////////
    void OnTouch (const TouchEvent& event, bool& touch_catched);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс состояния нажатий
///////////////////////////////////////////////////////////////////////////////////////////////////
    void ResetTouchState ();

  private:
    void OnSceneChanged  ();
    void OnCameraUpdated ();
    void Update ();

  private:
    scene_graph::Viewport& viewport;          //область вывода
    bool&                  z_order_changed;   //порядок следования областей ввода изменен
    InputScenePtr          input_scene;       //сцена ввода
    bool                   is_active;         //активность области
    bool                   need_update;       //нужно обновление
    xtl::auto_connection   on_camera_updated; //соединение с событием обновления камеры
    xtl::auto_connection   on_scene_changed;  //соединение с событием изменения сцены
};

typedef xtl::intrusive_ptr<InputPort> InputPortPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отображение сцены ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputScene: public xtl::reference_counter, public xtl::noncopyable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputScene  (scene_graph::Scene& scene);
    ~InputScene ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединенная сцена
///////////////////////////////////////////////////////////////////////////////////////////////////
    scene_graph::Scene& Scene () { return scene; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс состояния нажатий
///////////////////////////////////////////////////////////////////////////////////////////////////
    void ResetTouchState ();

  private:    
    scene_graph::Scene& scene;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Коллекция сцен ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputSceneCollection: private xtl::trackable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputSceneCollection  ();
    ~InputSceneCollection ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputScenePtr GetScene (scene_graph::Scene&);

  private:
    typedef stl::hash_map<scene_graph::Scene*, InputScenePtr> InputSceneMap;
    
  private:
    void OnSceneDestroyed (scene_graph::Scene*);
    
  private:
    InputSceneMap scenes;
};

typedef common::Singleton<InputSceneCollection> InputSceneCollectionSingleton;

}
