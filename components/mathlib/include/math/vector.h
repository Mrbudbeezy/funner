#ifndef __MATHLIB_VECTOR__
#define __MATHLIB_VECTOR__

#include <stddef.h>

#pragma pack (push,1)

#undef min
#undef max

namespace math
{

////////////////////////////////////////////////////////////////////////////////////////////
///Векторная база по умолчанию
////////////////////////////////////////////////////////////////////////////////////////////
template <class type,size_t size> struct vec_base
{
  type&       operator [] (size_t index)       { return x [index]; }
  const type& operator [] (size_t index) const { return x [index]; }
 
  type x [size];
};

template <class type> struct vec_base<type,2>
{
  type&       operator [] (size_t index)       { return (&x) [index]; }
  const type& operator [] (size_t index) const { return (&x) [index]; }
 
  type x,y;
};

template <class type> struct vec_base<type,3>
{
  type&       operator [] (size_t index)       { return (&x) [index]; }
  const type& operator [] (size_t index) const { return (&x) [index]; }
 
  type x,y,z;
};

template <class type> struct vec_base<type,4>
{
  type&       operator [] (size_t index)       { return (&x) [index]; }
  const type& operator [] (size_t index) const { return (&x) [index]; }
 
  type x,y,z,w;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
//Вектор 
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class type,size_t size>
class vec: public vec_base<type,size>
{
  public:
    typedef vec_base<type,size> base;
    typedef type                value_type;

    enum { _size = size }; //исправить!!!

////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
////////////////////////////////////////////////////////////////////////////////////////////
    vec ();
    vec (const type&);
    vec (const base&);

      //это решение - не лучшее, но оно меня устраивает
    vec (const type&,const type&,const type& = 0,const type& = 0); 
    vec (const vec<type,size-1>&,const type&);

      //для использования оптимизации возвращаемого значения
    template <class T>           vec (const T&,void (*eval)(vec&,const T&));
    template <class T1,class T2> vec (const T1&,const T2&,void (*eval)(vec&,const T1&,const T2&));

    template <size_t size1>         vec (const vec<type,size1>&); 

////////////////////////////////////////////////////////////////////////////////////////////
///Унарный +,-, длина (~)
////////////////////////////////////////////////////////////////////////////////////////////
    const vec&   operator +  () const;
    const vec    operator -  () const;
          type   operator ~  () const;

////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
////////////////////////////////////////////////////////////////////////////////////////////
    vec&   operator =  (const type&); 
    vec&   operator =  (const base&);

    template <size_t size1> vec& operator = (const vec<type,size1>&); 

////////////////////////////////////////////////////////////////////////////////////////////
///Основные бинарные операции
////////////////////////////////////////////////////////////////////////////////////////////
    vec&      operator += (const vec&);
    vec&      operator -= (const vec&);
    vec&      operator *= (const vec&);
    vec&      operator /= (const vec&);
    vec&      operator *= (const type&);
    vec&      operator /= (const type&);
    const vec operator +  (const vec&) const;
    const vec operator -  (const vec&) const;
    const vec operator *  (const vec&) const;
    const vec operator /  (const vec&) const;
    const vec operator *  (const type&) const;
    const vec operator /  (const type&) const;

    friend const vec operator *  (const type& a,const vec& v)    { return v * a; }

////////////////////////////////////////////////////////////////////////////////////////////
///Умножение вектора строки на матрицу столбец
////////////////////////////////////////////////////////////////////////////////////////////
    vec&      operator *= (const matrix<type,size>&);
    vec&      operator *= (const matrix<type,size+1>&);

    const vec operator *  (const matrix<type,size>&) const;
    const vec operator *  (const matrix<type,size+1>&) const;

////////////////////////////////////////////////////////////////////////////////////////////
///Отношения между векторами           
////////////////////////////////////////////////////////////////////////////////////////////
    bool operator == (const vec&) const;      
    bool operator != (const vec&) const;

////////////////////////////////////////////////////////////////////////////////////////////
///Cкалярное произведение
////////////////////////////////////////////////////////////////////////////////////////////
    type operator &  (const vec&) const;

////////////////////////////////////////////////////////////////////////////////////////////
///Приведение типов (понижение размерности вектора)
////////////////////////////////////////////////////////////////////////////////////////////
    operator const vec<type,size-1>& () const;
    operator       vec<type,size-1>& ();
};

template <class type> class vec<type,0> {};

#pragma pack(pop)

////////////////////////////////////////////////////////////////////////////////////////////
///Базовые операции
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
///Утилиты
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
///Скалярное произведение
////////////////////////////////////////////////////////////////////////////////////////////
template <class type,size_t size> 
type dot (const vec<type,size>&,const vec<type,size>&); 

////////////////////////////////////////////////////////////////////////////////////////////
///Равенство векторов с заданной погрешностью
////////////////////////////////////////////////////////////////////////////////////////////    
template <class type,size_t size>
bool equal (const vec<type,size>&,const vec<type,size>&,const type& eps); 

////////////////////////////////////////////////////////////////////////////////////////////
///Длина вектора
////////////////////////////////////////////////////////////////////////////////////////////                
template <class type,size_t size>                          
type length (const vec<type,size>&); 

////////////////////////////////////////////////////////////////////////////////////////////
///Квадрат длины
////////////////////////////////////////////////////////////////////////////////////////////                
template <class type,size_t size>
type qlen (const vec<type,size>&);

////////////////////////////////////////////////////////////////////////////////////////////
///Возвращает нормированный вектор
////////////////////////////////////////////////////////////////////////////////////////////                
template <class type,size_t size>                          
const vec<type,size> normalize (const vec<type,size>&);

////////////////////////////////////////////////////////////////////////////////////////////
///Возвращает покоординатный модуль
////////////////////////////////////////////////////////////////////////////////////////////                
template <class type,size_t size>                          
const vec<type,size> abs (const vec<type,size>&); 

////////////////////////////////////////////////////////////////////////////////////////////
///Покомпонентный минимум/максимум
////////////////////////////////////////////////////////////////////////////////////////////                
template <class type,size_t size>
const vec<type,size> min (const vec<type,size>&,const vec<type,size>&); 

template <class type,size_t size>
const vec<type,size> max (const vec<type,size>&,const vec<type,size>&); 

////////////////////////////////////////////////////////////////////////////////////////////
///Угол между векторами
////////////////////////////////////////////////////////////////////////////////////////////
template <class type,size_t size>
type angle (const vec<type,size>& a,const vec<type,size>& b);

////////////////////////////////////////////////////////////////////////////////////////////
///Векторное произведение
////////////////////////////////////////////////////////////////////////////////////////////
template <class type>
vec<type,3> cross (const vec<type,3>& a,const vec<type,3>& b);

template <class type>
vec<type,4> cross (const vec<type,4>& a,const vec<type,4>& b);

template <class type>
vec<type,3> operator ^ (const vec<type,3>& a,const vec<type,3>& b);

template <class type>
vec<type,4> operator ^ (const vec<type,4>& a,const vec<type,4>& b);

}

#endif
