#ifndef SYSLIB_SENSOR_HEADER
#define SYSLIB_SENSOR_HEADER

#include <cstddef>
#include <ctime>

#include <xtl/functional_fwd>

namespace common
{

//forward declaration
class PropertyMap;

}

namespace syslib
{

//implementation forward
class SensorImpl;
class SensorManager;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вектор сенсора
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef float SensorVector [3];

///////////////////////////////////////////////////////////////////////////////////////////////////
///Событие сенсора
///////////////////////////////////////////////////////////////////////////////////////////////////
struct SensorEvent
{
  time_t        timestamp;
  unsigned char values_count;

  union
  {
    float          data [16];
    SensorVector   vector;
    SensorVector   acceleration;
    SensorVector   magnetic;
    float          temperature;
    float          distance;
    float          light;
    float          pressure;
  };
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сенсор
///////////////////////////////////////////////////////////////////////////////////////////////////
class Sensor
{
  friend class SensorManager;
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    Sensor  (size_t sensor_index);
    Sensor  (const Sensor&);
    ~Sensor ();
    
    Sensor& operator = (const Sensor&);    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Name () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип устройства
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Type () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Производитель
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Vendor () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Максимальное значение
///////////////////////////////////////////////////////////////////////////////////////////////////
    float MaxRange () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Частота обновления
///////////////////////////////////////////////////////////////////////////////////////////////////
    void  SetUpdateRate (float rate);
    float UpdateRate    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Платформо-зависимый дескриптор сенсора
///////////////////////////////////////////////////////////////////////////////////////////////////
    const void* Handle () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение платформо-зависимых свойств
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetProperties (common::PropertyMap&) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация событий сенсора
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (SensorEvent& event)> EventHandler;

    xtl::connection RegisterEventHandler (const EventHandler& handler) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (Sensor&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сравнение
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool operator == (const Sensor&) const;
    bool operator != (const Sensor&) const;

  private:
    SensorImpl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (Sensor&, Sensor&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер экранов
///////////////////////////////////////////////////////////////////////////////////////////////////
class SensorManager
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Перечисление сенсоров
///////////////////////////////////////////////////////////////////////////////////////////////////
    static size_t         SensorsCount ();
    static syslib::Sensor Sensor       (size_t index);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск сенсора по типу
///////////////////////////////////////////////////////////////////////////////////////////////////
    static int FindSensorByType (const char* type);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Частота опроса очередей сенсоров
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void  SetUpdateRate (float rate);
    static float UpdateRate    ();
};

}

#endif
