#ifndef SYSLIB_TIMER_HEADER
#define SYSLIB_TIMER_HEADER

#include <xtl/functional_fwd>

namespace syslib
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние таймера
///////////////////////////////////////////////////////////////////////////////////////////////////
enum TimerState
{
  TimerState_Paused,  //в паузе
  TimerState_Running, //работает
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Синхронный таймер (вызывается при обработке событий)
///////////////////////////////////////////////////////////////////////////////////////////////////
class Timer
{
  public:
    typedef xtl::function<void (Timer&)> TickHandler;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Timer  (const TickHandler&, size_t period_in_milliseconds=0, TimerState initial_state = TimerState_Running);
    ~Timer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработчик
///////////////////////////////////////////////////////////////////////////////////////////////////
    const TickHandler& Handler () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Период
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Period    () const;
    void   SetPeriod (size_t period_in_milliseconds);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Приостановка / возобновление работы таймера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void       SetState  (TimerState);
    TimerState State     () const;
    bool       IsPaused  () const { return State () == TimerState_Paused; }
    bool       IsRunning () const { return State () == TimerState_Running; }
    void       Pause     ()       { SetState (TimerState_Paused); }
    void       Run       ()       { SetState (TimerState_Running); }
    void       Restart   ()       { Pause (), Run (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество милисекунд, прошедшее с момента старта таймера
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t ElapsedMilliseconds () const;

  private:
    Timer (const Timer&); //no impl
    Timer& operator = (const Timer&); //no impl
  
  private:
    struct Impl;
    Impl* impl;
};

}

#endif
