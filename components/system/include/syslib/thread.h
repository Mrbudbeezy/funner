#ifndef SYSLIB_THREAD_HEADER
#define SYSLIB_THREAD_HEADER

#include <stl/auto_ptr.h>
#include <xtl/exception.h>
#include <xtl/functional_fwd>

namespace syslib
{

//forward declarations
struct CurrentThreadHolder;
class  Mutex;

struct cancel_thread_exception: virtual public xtl::exception {};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Константы
///////////////////////////////////////////////////////////////////////////////////////////////////
const int THREAD_CANCELED_EXIT_CODE = -1; //код завершения сброшенной нити

///////////////////////////////////////////////////////////////////////////////////////////////////
///Приоритет нити
///////////////////////////////////////////////////////////////////////////////////////////////////
enum ThreadPriority
{
  ThreadPriority_Low,
  ThreadPriority_Normal,
  ThreadPriority_High
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Нить
///////////////////////////////////////////////////////////////////////////////////////////////////
class Thread
{
  friend struct CurrentThreadHolder;
  public:
    typedef size_t                threadid_t;
    typedef xtl::function<int ()> Function;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    Thread  (const Function& thread_function);
    Thread  (const char* name, const Function& thread_function);
    ~Thread ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Идентификатор нити
///////////////////////////////////////////////////////////////////////////////////////////////////
    threadid_t Id () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя нити
///////////////////////////////////////////////////////////////////////////////////////////////////
//    const char* Name () const; //сделать возвращение объекта с подсчётом ссылок, иначе нить может удалиться, оставив badptr

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка приоритета нити
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetPriority (ThreadPriority thread_priority);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отмена нити
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Cancel ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ожидание завершения нити
///////////////////////////////////////////////////////////////////////////////////////////////////
    int Join (); //return exit code

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение текущей нити
///////////////////////////////////////////////////////////////////////////////////////////////////
    static Thread& GetCurrent ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка точки отмена нити
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void TestCancel ();

  private:
    struct Impl;

    Thread  (const Thread&); //no impl
    Thread& operator = (const Thread&); //no impl

  private:
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Локальные данные нити
///////////////////////////////////////////////////////////////////////////////////////////////////
class ThreadLocalStorage
{
  public:
    typedef xtl::function<void (void* data)> CleanupHandler;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ThreadLocalStorage  ();
    ThreadLocalStorage  (const CleanupHandler& cleanup);
    ThreadLocalStorage  (void (*cleanup)(void*));
    ~ThreadLocalStorage ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / чтение данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void  SetValue (void* data);
    void* GetValue () const;

  private:
    ThreadLocalStorage (const ThreadLocalStorage&); //no impl
    ThreadLocalStorage& operator = (const ThreadLocalStorage&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Типизированный указатель на локальные данные нити
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> class ThreadLocalPointer
{
  public:
    typedef xtl::function<void (T* data)> CleanupHandler;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ThreadLocalPointer ();
    ThreadLocalPointer (const CleanupHandler& cleanup);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    T* Get         () const;
    T* operator -> () const;
    T& operator *  () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс указателя
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Reset (T* new_object); //????

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс указателя без очищения данных (вызова cleanup)
///////////////////////////////////////////////////////////////////////////////////////////////////
    T* Release ();

  private:
    ThreadLocalPointer (const ThreadLocalPointer&); //no impl
    ThreadLocalPointer& operator = (const ThreadLocalPointer&); //no impl
    
  private:
    ThreadLocalStorage storage;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Условие работы кода нити
///////////////////////////////////////////////////////////////////////////////////////////////////
class ThreadCondition
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ThreadCondition  ();
    ~ThreadCondition ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Посылка оповещения об изменении условия
///////////////////////////////////////////////////////////////////////////////////////////////////
    void NotifyOne ();
    void NotifyAll ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ожидание изменения условия
///////////////////////////////////////////////////////////////////////////////////////////////////
                          void Wait (Mutex& lock);
    template <class Pred> void Wait (Mutex& lock, Pred pred);

  private:
    ThreadCondition  (const ThreadCondition&); //no impl
    ThreadCondition& operator = (const ThreadCondition&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Блок захвата ресурсов нитью
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> class ThreadLockScope
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ThreadLockScope  (T& object);
    ~ThreadLockScope ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Упрощение однострочного доступа
///////////////////////////////////////////////////////////////////////////////////////////////////
    T* Get         () const;
    T* operator -> () const;

  private:
    ThreadLockScope (const ThreadLockScope&); //no impl
    ThreadLockScope& operator = (const ThreadLockScope&); //no impl

  private:
    T* object;
};

#include <syslib/detail/thread.inl>

}

#endif
