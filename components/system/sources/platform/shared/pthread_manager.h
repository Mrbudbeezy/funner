#ifndef SYSLIB_PTHREAD_MANAGER_HEADER
#define SYSLIB_PTHREAD_MANAGER_HEADER

#include <shared/default_thread_manager.h>

namespace syslib
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер нитей PThread
///////////////////////////////////////////////////////////////////////////////////////////////////
class PThreadManager
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание / удаление нити
///////////////////////////////////////////////////////////////////////////////////////////////////
    static thread_t CreateThread  (IThreadCallback*);
    static void     DestroyThread (thread_t);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ожидание завершения нити
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void JoinThread (thread_t);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение идентификатора нити
///////////////////////////////////////////////////////////////////////////////////////////////////
    static size_t GetThreadId        (thread_t thread);
    static size_t GetCurrentThreadId ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка приоритета нити
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void SetThreadPriority (thread_t thread, ThreadPriority thread_priority);
    static void SetThreadAffinity (thread_t thread, size_t affinity);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с локальными данными нити
///////////////////////////////////////////////////////////////////////////////////////////////////
    static tls_t CreateTls  (IThreadCleanupCallback* cleanup);
    static void  DestroyTls (tls_t tls);
    static void  SetTls     (tls_t tls, void* data);
    static void* GetTls     (tls_t tls);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с исключающими семафорами
///////////////////////////////////////////////////////////////////////////////////////////////////
    static mutex_t CreateMutex  ();
    static void    DestroyMutex (mutex_t);
    static void    LockMutex    (mutex_t);
    static bool    LockMutex    (mutex_t, size_t wait_in_milliseconds);
    static bool    TryLockMutex (mutex_t);
    static void    UnlockMutex  (mutex_t);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с семафорами
///////////////////////////////////////////////////////////////////////////////////////////////////
    static semaphore_t CreateSemaphore   (size_t initial_count);
    static void        DestroySemaphore  (semaphore_t);
    static void        WaitSemaphore     (semaphore_t);
    static bool        WaitSemaphore     (semaphore_t, size_t wait_in_milliseconds);
    static bool        TryWaitSemaphore  (semaphore_t);
    static void        PostSemaphore     (semaphore_t);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с условиями
///////////////////////////////////////////////////////////////////////////////////////////////////
    static condition_t CreateCondition    ();
    static void        DestroyCondition   (condition_t);
    static void        WaitCondition      (condition_t, mutex_t);
    static bool        WaitCondition      (condition_t, mutex_t, size_t wait_in_milliseconds);
    static void        NotifyCondition    (condition_t, bool broadcast);  
};

}

#endif
