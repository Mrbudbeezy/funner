#ifndef SYSLIB_PLATFORM_HEADER
#define SYSLIB_PLATFORM_HEADER

#include <syslib/application_delegate.h>
#include <syslib/window.h>

namespace syslib
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Флаги окна
///////////////////////////////////////////////////////////////////////////////////////////////////
enum WindowFlag
{
  WindowFlag_Visible,   //видимость окна
  WindowFlag_Active,    //активность окна
  WindowFlag_Focus,     //фокус ввода окна
  WindowFlag_Maximized, //максимальный размер окна
  WindowFlag_Minimized, //минимальный размер окна
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерфейс обратной связи нити
///////////////////////////////////////////////////////////////////////////////////////////////////
class IThreadCallback
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Запуск на выполнение
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Run () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void AddRef  () = 0;
    virtual void Release () = 0;

  protected:
    virtual ~IThreadCallback () {}
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерфейс очистки ресурсов нити
///////////////////////////////////////////////////////////////////////////////////////////////////
class IThreadCleanupCallback
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Cleanup (void* data) = 0;

  protected:
    virtual ~IThreadCleanupCallback () {}
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Платформа
///////////////////////////////////////////////////////////////////////////////////////////////////
class Platform
{
  public:
    struct window_handle;
    struct cursor_handle;
    struct thread_handle;
    struct tls_handle;
    struct mutex_handle;
    struct semaphore_handle;
    struct condition_handle;

    typedef window_handle*    window_t;
    typedef cursor_handle*    cursor_t;
    typedef thread_handle*    thread_t;
    typedef tls_handle*       tls_t;
    typedef mutex_handle*     mutex_t;
    typedef semaphore_handle* semaphore_t;
    typedef condition_handle* condition_t;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание/закрытие/уничтожение окна
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef void (*WindowMessageHandler)(window_t, WindowEvent, const WindowEventContext&, void* user_data);

    static window_t CreateWindow  (WindowStyle, WindowMessageHandler, const void* parent_handle, const char* init_string, void* user_data);
    static void     CloseWindow   (window_t);
    static void     DestroyWindow (window_t);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение платформо-зависимого дескриптора окна и дисплея
///////////////////////////////////////////////////////////////////////////////////////////////////
    static const void* GetNativeWindowHandle  (window_t);
    static const void* GetNativeDisplayHandle (window_t);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Заголовок окна
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void SetWindowTitle (window_t, const wchar_t* title);
    static void GetWindowTitle (window_t, size_t buffer_size_in_chars, wchar_t* buffer);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Область окна / клиентская область
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void SetWindowRect (window_t, const Rect&);
    static void SetClientRect (window_t, const Rect&);
    static void GetWindowRect (window_t, Rect&);
    static void GetClientRect (window_t, Rect&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка флагов окна
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void SetWindowFlag (window_t, WindowFlag flag, bool state);
    static bool GetWindowFlag (window_t, WindowFlag flag);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка родительского окна
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void        SetParentWindowHandle (window_t child, const void* parent_handle);
    static const void* GetParentWindowHandle (window_t child);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление окна
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void InvalidateWindow (window_t);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Положение курсора
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void  SetCursorPosition (const Point& position);
    static Point GetCursorPosition ();
    static void  SetCursorPosition (window_t, const Point& client_position); //в клиентских координатах окна
    static Point GetCursorPosition (window_t);                               //в клиентских координатах окна

///////////////////////////////////////////////////////////////////////////////////////////////////
///Видимость курсора
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void SetCursorVisible (window_t, bool state);
    static bool GetCursorVisible (window_t);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Изображение курсора
///////////////////////////////////////////////////////////////////////////////////////////////////
    static cursor_t CreateCursor  (const char* name, int hotspot_x, int hotspot_y); //hotspot_x/hotspot_y = -1 - default value
    static void     DestroyCursor (cursor_t);
    static void     SetCursor     (window_t window, cursor_t cursor);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка/получение multitouch режима
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void SetMultitouchEnabled (window_t window, bool state);
    static bool IsMultitouchEnabled  (window_t window);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Цвет фона
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void  SetBackgroundColor (window_t window, const Color& color);
    static void  SetBackgroundState (window_t window, bool state);
    static Color GetBackgroundColor (window_t window);
    static bool  GetBackgroundState (window_t window);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение имени клавиши
///////////////////////////////////////////////////////////////////////////////////////////////////
    static size_t GetKeyName (ScanCode scan_code, size_t buffer_size, char* buffer); //возвращается длина строки без учёта '\0'

///////////////////////////////////////////////////////////////////////////////////////////////////
///Приостановка выполнения нити на miliseconds милисекунд
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void Sleep (size_t miliseconds);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Открытие URL во внешнем браузере
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void OpenUrl (const char* url);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание / уничтожение таймера
///////////////////////////////////////////////////////////////////////////////////////////////////
    struct timer_handle;
    typedef timer_handle* timer_t;
    typedef void (*TimerHandler)(void* user_data);

    static timer_t CreateTimer (size_t period_in_milliseconds, TimerHandler, void* user_data);
    static void    KillTimer   (timer_t handle);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с очередью сообщений
///////////////////////////////////////////////////////////////////////////////////////////////////
    static IApplicationDelegate* CreateDefaultApplicationDelegate ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка динамических библиотек
///////////////////////////////////////////////////////////////////////////////////////////////////
    struct dynamic_library_handle;

    typedef dynamic_library_handle* dll_t;

    static dll_t LoadLibrary   (const wchar_t* name);
    static void  UnloadLibrary (dll_t);
    static void* GetSymbol     (dll_t, const char* symbol_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание / удаление нити
///////////////////////////////////////////////////////////////////////////////////////////////////
    static thread_t CreateThread  (IThreadCallback*);
    static void     DestroyThread (thread_t);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ожидание завершения нити
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void JoinThread (thread_t);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение идентификатора нити
///////////////////////////////////////////////////////////////////////////////////////////////////
    static size_t GetThreadId        (thread_t thread);
    static size_t GetCurrentThreadId ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с локальными данными нити
///////////////////////////////////////////////////////////////////////////////////////////////////
    static tls_t CreateTls  (IThreadCleanupCallback* cleanup);
    static void  DestroyTls (tls_t tls);
    static void  SetTls     (tls_t tls, void* data);
    static void* GetTls     (tls_t tls);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с исключающими семафорами
///////////////////////////////////////////////////////////////////////////////////////////////////
    static mutex_t CreateMutex  ();
    static void    DestroyMutex (mutex_t);
    static void    LockMutex    (mutex_t);
    static bool    LockMutex    (mutex_t, size_t wait_in_milliseconds);
    static bool    TryLockMutex (mutex_t);
    static void    UnlockMutex  (mutex_t);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с семафорами
///////////////////////////////////////////////////////////////////////////////////////////////////
    static semaphore_t CreateSemaphore   (size_t initial_count);
    static void        DestroySemaphore  (semaphore_t);
    static void        WaitSemaphore     (semaphore_t);
    static bool        WaitSemaphore     (semaphore_t, size_t wait_in_milliseconds);
    static bool        TryWaitSemaphore  (semaphore_t);
    static void        PostSemaphore     (semaphore_t);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с условиями
///////////////////////////////////////////////////////////////////////////////////////////////////
    static condition_t CreateCondition    ();
    static void        DestroyCondition   (condition_t);
    static void        WaitCondition      (condition_t, mutex_t);
    static bool        WaitCondition      (condition_t, mutex_t, size_t wait_in_milliseconds);
    static void        NotifyCondition    (condition_t, bool broadcast);
};

}

#endif
