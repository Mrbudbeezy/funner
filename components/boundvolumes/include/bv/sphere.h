#ifndef BOUND_VOLUMES_SPHERE_HEADER
#define BOUND_VOLUMES_SPHERE_HEADER

#include <mathlib.h>

namespace bound_volumes
{

//forward declarations
template <class T> class axis_aligned_box;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ограничивающая сфера
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> class sphere
{
  public:
    typedef T               element_type;
    typedef math::vec<T, 3> vec_type;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    sphere ();
    sphere (const vec_type& center, const element_type& radius);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение параметров
///////////////////////////////////////////////////////////////////////////////////////////////////
    const vec_type& center () const;
    element_type    radius () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка параметров
///////////////////////////////////////////////////////////////////////////////////////////////////
    void set_radius  (const element_type&);
    void set_center  (const vec_type&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс объёма
///////////////////////////////////////////////////////////////////////////////////////////////////
    void reset (const vec_type& center = vec_type (0), const element_type& radius = element_type (0));

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение статистик ограничивающей сферы
///////////////////////////////////////////////////////////////////////////////////////////////////
    element_type volume () const; //геометрический объём сферы

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool empty (const element_type& eps = default_epsilon) const; //проверка: r < eps

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление примитивов в ограничивающий объём
///  Если текущий радиус < 0 - сбрасываем положение сферы
///////////////////////////////////////////////////////////////////////////////////////////////////
    sphere& operator += (const vec_type&);
    sphere& operator += (const sphere&);
//    sphere& operator += (const axis_aligned_box<T>&); //???
    sphere  operator +  (const vec_type&) const;
    sphere  operator +  (const sphere&) const;
//    sphere  operator +  (const axis_aligned_box&) const; //???

///////////////////////////////////////////////////////////////////////////////////////////////////
///Преобразования ограничивающей сферы
///////////////////////////////////////////////////////////////////////////////////////////////////
/*    sphere& operator *= (const math::matrix<T, 4>&);
    sphere& operator *= (const math::quat<T>&);
    sphere  operator *  (const math::matrix<T, 4>&) const;
    sphere  operator *  (const math::quat<T>&) const;
*/
///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка пересечения ограничивающей сферы с различными примитивами
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool intersects (const sphere&) const;
    bool intersects (const axis_aligned_box<T>&) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка: содержит ли ограничивающая сфера различные примитивы
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool contains (const vec_type& point) const;
    bool contains (const sphere& sphere) const;
    bool contains (const axis_aligned_box<T>& box) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сравнение
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool equal (const sphere&, const element_type& eps = default_epsilon) const;

    bool operator == (const sphere&) const;
    bool operator != (const sphere&) const;

  private:
    vec_type     sphere_center;
    element_type sphere_radius;    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Определения типов
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef sphere<int>    spherei;
typedef sphere<float>  spheref;
typedef sphere<double> sphered;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Преобразования ограничивающей сферы
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> sphere<T> operator * (const math::matrix<T, 4>&, const sphere<T>&);
template <class T> sphere<T> operator * (const math::quat<T>&, const sphere<T>&);

#include <bv/detail/sphere.inl>

}

#endif
