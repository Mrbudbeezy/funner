#ifndef PHYSICS_BULLET_DRIVER_SHARED_HEADER
#define PHYSICS_BULLET_DRIVER_SHARED_HEADER

#include <stl/auto_ptr.h>
#include <stl/hash_map>

#include <xtl/bind.h>
#include <xtl/common_exceptions.h>
#include <xtl/connection.h>
#include <xtl/function.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/reference_counter.h>
#include <xtl/signal.h>

#include <common/component.h>
#include <common/log.h>

#include <render/debug_render.h>

#include <physics/low_level/common.h>
#include <physics/low_level/driver.h>
#include <physics/low_level/joints.h>
#include <physics/low_level/material.h>
#include <physics/low_level/rigid_body.h>
#include <physics/low_level/scene.h>
#include <physics/low_level/shape.h>

#include <BulletCollision/BroadphaseCollision/btBroadphaseInterface.h>
#include <BulletCollision/BroadphaseCollision/btDbvtBroadphase.h>
#include <BulletCollision/CollisionDispatch/btDefaultCollisionConfiguration.h>
#include <BulletCollision/CollisionDispatch/btCollisionDispatcher.h>
#include <BulletCollision/CollisionShapes/btBoxShape.h>
#include <BulletCollision/CollisionShapes/btBvhTriangleMeshShape.h>
#include <BulletCollision/CollisionShapes/btCapsuleShape.h>
#include <BulletCollision/CollisionShapes/btCollisionShape.h>
#include <BulletCollision/CollisionShapes/btCompoundShape.h>
#include <BulletCollision/CollisionShapes/btConvexHullShape.h>
#include <BulletCollision/CollisionShapes/btStaticPlaneShape.h>
#include <BulletCollision/CollisionShapes/btSphereShape.h>
#include <BulletCollision/CollisionShapes/btTriangleMesh.h>
#include <BulletDynamics/ConstraintSolver/btConeTwistConstraint.h>
#include <BulletDynamics/ConstraintSolver/btHingeConstraint.h>
#include <BulletDynamics/ConstraintSolver/btPoint2PointConstraint.h>
#include <BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.h>
#include <BulletDynamics/ConstraintSolver/btSliderConstraint.h>
#include <BulletDynamics/Dynamics/btDiscreteDynamicsWorld.h>
#include <BulletDynamics/Dynamics/btRigidBody.h>
#include <LinearMath/btDefaultMotionState.h>
#include <LinearMath/btIDebugDraw.h>

#ifdef _MSC_VER
  #pragma warning (disable : 4250) //'class1' : inherits 'class2::member' via dominance
#endif

namespace physics
{

namespace low_level
{

namespace bullet
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый объект семейства низкоуровневых средств отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
class Object: virtual public IObject, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Object () {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddRef  () { addref (this); }
    void Release () { release (this); }

  private:
    Object (const Object&); //no impl
    Object& operator = (const Object&); //no impl
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Геометрическое тело
///////////////////////////////////////////////////////////////////////////////////////////////////
class Shape : public IShape, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Shape  (btCollisionShape* shape);
    ~Shape ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Толщина полей
///////////////////////////////////////////////////////////////////////////////////////////////////
    float Margin    ();
    void  SetMargin (float value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение bullet тела
///////////////////////////////////////////////////////////////////////////////////////////////////
    btCollisionShape* BulletCollisionShape ();

  private:
    btCollisionShape* collision_shape;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Геометрическое тело представленное сеткой
///////////////////////////////////////////////////////////////////////////////////////////////////
class TriangleMeshShape : public Shape
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TriangleMeshShape (btCollisionShape* shape, btStridingMeshInterface* in_mesh) : Shape (shape), mesh (in_mesh) {}
    ~TriangleMeshShape () { delete mesh; }

  private:
    btStridingMeshInterface* mesh;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Материал тела
///////////////////////////////////////////////////////////////////////////////////////////////////
class Material : public IMaterial, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Material ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление линейной/угловой аммортизацией
///////////////////////////////////////////////////////////////////////////////////////////////////
    float LinearDamping     ();
    float AngularDamping    ();
    void  SetLinearDamping  (float value);
    void  SetAngularDamping (float value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление трением
///////////////////////////////////////////////////////////////////////////////////////////////////
    float              Friction               ();
    const math::vec3f& AnisotropicFriction    ();
    void               SetFriction            (float value);
    void               SetAnisotropicFriction (const math::vec3f& value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление упругостью
///////////////////////////////////////////////////////////////////////////////////////////////////
    float Restitution    ();
    void  SetRestitution (float value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подписка на обновление свойств
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function <void ()> UpdateHandler;

    xtl::connection RegisterUpdateHandler (const UpdateHandler& handler);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Твердое тело
///////////////////////////////////////////////////////////////////////////////////////////////////
class RigidBody : public IRigidBody, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор/деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RigidBody  (bullet::Shape* shape, float mass);
    ~RigidBody ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Геометрическое представление
///////////////////////////////////////////////////////////////////////////////////////////////////
    bullet::Shape* Shape ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Материал
///////////////////////////////////////////////////////////////////////////////////////////////////
    IMaterial* Material    ();
    void       SetMaterial (IMaterial* material);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Флаги поведения
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Flags    ();
    void   SetFlags (size_t flags);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Приложение силы/импульса/вращения
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddForce   (const math::vec3f& force,   const math::vec3f& relative_position);
    void AddImpulse (const math::vec3f& impulse, const math::vec3f& relative_position);
    void AddTorque  (const math::vec3f& torque);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление линейной/угловой скоростями
///////////////////////////////////////////////////////////////////////////////////////////////////
    const math::vec3f& LinearVelocity     ();
    const math::vec3f& AngularVelocity    ();
    void               SetLinearVelocity  (const math::vec3f& velocity);
    void               SetAngularVelocity (const math::vec3f& velocity);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление массой
///////////////////////////////////////////////////////////////////////////////////////////////////
    float Mass    ();
    void  SetMass (float mass);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление тензором
///////////////////////////////////////////////////////////////////////////////////////////////////
    const math::vec3f&  MassSpaceInertiaTensor    ();
    void                SetMassSpaceInertiaTensor (const math::vec3f& value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление сном
///////////////////////////////////////////////////////////////////////////////////////////////////
    float SleepLinearVelocity     ();
    float SleepAngularVelocity    ();
    void  SetSleepLinearVelocity  (float value);
    void  SetSleepAngularVelocity (float value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление пороговым значением скорости перехода в режим непрерывного движения
///////////////////////////////////////////////////////////////////////////////////////////////////
    float CcdMotionThreshold    ();
    void  SetCcdMotionThreshold (float);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Согласование объекта с группой
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t CollisionGroup    ();
    void   SetCollisionGroup (size_t group_number);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Мировое положение
///////////////////////////////////////////////////////////////////////////////////////////////////
    const Transform& WorldTransform                  ();
    void             SetWorldTransform               (const Transform& transform);
    xtl::connection  RegisterTransformUpdateCallback (const TransformUpdateCallback& callback_handler);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение bullet тела
///////////////////////////////////////////////////////////////////////////////////////////////////
    btRigidBody* BulletRigidBody ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подписка на удаление объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function <void (RigidBody*)> BeforeDestroyHandler;

    xtl::connection RegisterDestroyHandler (const BeforeDestroyHandler& handler);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Соединение тел
///////////////////////////////////////////////////////////////////////////////////////////////////
class Joint : public IJoint, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор/деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Joint (RigidBody* body1, RigidBody* body2, btTypedConstraint* joint);
    ~Joint ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение объектов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t      ObjectsCount ();
    IRigidBody* GetObject    (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение bullet соединения
///////////////////////////////////////////////////////////////////////////////////////////////////
    btTypedConstraint* BulletJoint ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подписка на удаление объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function <void (Joint*)> BeforeDestroyHandler;

    xtl::connection RegisterDestroyHandler (const BeforeDestroyHandler& handler);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Физическая сцена
///////////////////////////////////////////////////////////////////////////////////////////////////
class Scene : public IScene, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Scene ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление гравитацией
///////////////////////////////////////////////////////////////////////////////////////////////////
    const math::vec3f& Gravity    ();
    void               SetGravity (const math::vec3f& value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Симуляция
///////////////////////////////////////////////////////////////////////////////////////////////////
    float SimulationStep    ();
    void  SetSimulationStep (float step);

    void  PerformSimulation (float dt);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание тел в сцене (тела, обладающие нулевой массой, являются статическими)
///////////////////////////////////////////////////////////////////////////////////////////////////
    RigidBody* CreateRigidBody (IShape* shape, float mass);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание соединений между телами
///////////////////////////////////////////////////////////////////////////////////////////////////
    Joint* CreateSphericalJoint (IRigidBody* body1, IRigidBody* body2, const SphericalJointDesc& desc);
    Joint* CreateConeTwistJoint (IRigidBody* body1, IRigidBody* body2, const ConeTwistJointDesc& desc);
    Joint* CreateHingeJoint     (IRigidBody* body1, IRigidBody* body2, const HingeJointDesc& desc);
    Joint* CreatePrismaticJoint (IRigidBody* body1, IRigidBody* body2, const PrismaticJointDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Фильтрация столкновений объектов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetCollisionFilter (size_t group1, size_t group2, bool collides, const BroadphaseCollisionFilter& filter);
    void SetDefaultCollisionFilter (const BroadphaseCollisionFilter& filter);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработка столкновений объектов
///////////////////////////////////////////////////////////////////////////////////////////////////
    xtl::connection RegisterCollisionCallback (CollisionEventType event_type, const CollisionCallback& callback_handler);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отладочная отрисовка
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw (render::debug::PrimitiveRender&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение о коллизии
///////////////////////////////////////////////////////////////////////////////////////////////////
    void ColissionNotify (const CollisionEvent& event);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Драйвер физической системы
///////////////////////////////////////////////////////////////////////////////////////////////////
class Driver : public IDriver, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Driver ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание драйвера
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetDescription ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    Scene* CreateScene ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание материала
///////////////////////////////////////////////////////////////////////////////////////////////////
    Material* CreateMaterial ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание геометрических тел
///////////////////////////////////////////////////////////////////////////////////////////////////
    Shape* CreateBoxShape          (const math::vec3f& half_dimensions);
    Shape* CreateSphereShape       (float radius);
    Shape* CreateCapsuleShape      (float radius, float height);
    Shape* CreatePlaneShape        (const math::vec3f& normal, float d);
    Shape* CreateConvexShape       (size_t vertices_count, const math::vec3f* vertices);
    Shape* CreateTriangleMeshShape (size_t vertices_count, const math::vec3f* vertices, size_t triangles_count, size_t* triangles);
    Shape* CreateCompoundShape     (size_t shapes_count, IShape** shapes, Transform* local_transforms);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

//хранится в btRigidBody
struct RigidBodyInfo
{
  RigidBody* body;
  Scene*     scene;
};

//преобразование векторов
void vector_from_bullet_vector (const btVector3& bullet_vector, math::vec3f& target_vector);
void bullet_vector_from_vector (const math::vec3f& vector, btVector3& target_vector);

//преобразование кватернионов
void quaternion_from_bullet_quaternion (const btQuaternion& bullet_quaternion, math::quatf& target_quaternion);
void bullet_quaternion_from_quaternion (const math::quatf& quaternion, btQuaternion& target_quaternion);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Приведение типов объектов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class DstT, class SrcT>
DstT* cast_object (SrcT* ptr, const char* source, const char* argument_name);

#include "detail/object.inl"

}

}

}

#endif
