#ifndef PHYSICS_LOW_LEVEL_SCENE_HEADER
#define PHYSICS_LOW_LEVEL_SCENE_HEADER

#include <xtl/functional_fwd>

#include <math/matrix.h>
#include <math/vector.h>

#include <physics/low_level/joints.h>

namespace physics
{

namespace low_level
{

//forward declarations
class IDebugRenderable;
class IRigidBody;
class IShape;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Типы событий столкновений
///////////////////////////////////////////////////////////////////////////////////////////////////
enum CollisionEventType
{
  CollisionEventType_Begin,   //начало столкновения
  CollisionEventType_Process, //в процессе столкновения
  CollisionEventType_End      //конец столкновения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Событие столкновения
///////////////////////////////////////////////////////////////////////////////////////////////////
struct CollisionEvent
{
  CollisionEventType type;         //тип события
  IRigidBody*        body [2];     //столкнувшиеся тела
  size_t             points_count; //количество точек столкновения
  math::vec3f*       points;       //мировые координаты точек столкновения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим обработки столкновения тел
///////////////////////////////////////////////////////////////////////////////////////////////////
enum CollisionMode
{
  CollisionMode_Never,  //никогда не сталкиваются
  CollisionMode_Always, //всегда сталкиваются
  CollisionMode_Filter, //не сталкиваются, если фильтр вернул false
  
  CollisionMode_Default = CollisionMode_
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Физическая сцена
///////////////////////////////////////////////////////////////////////////////////////////////////
class IScene : virtual public IObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение данных для отладочной отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
//    virtual IDebugRenderable* DebugRenderable () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление гравитацией
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual const math::vec3f& Gravity    () = 0;
    virtual void               SetGravity (const math::vec3f& value) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Симуляция
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual float SimulationStep    () = 0;
    virtual void  SetSimulationStep (float step) = 0;

    virtual void  PerformSimulation (float dt) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание тел в сцене
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual IRigidBody* CreateRigidBody (IShape* shape, float mass) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание соединений между телами
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual IJoint* CreateSphericalJoint (IRigidBody* body1, IRigidBody* body2, const SphericalJointDesc& desc) = 0;
    virtual IJoint* CreateConeTwistJoint (IRigidBody* body1, IRigidBody* body2, const ConeTwistJointDesc& desc) = 0;
    virtual IJoint* CreateHingeJoint     (IRigidBody* body1, IRigidBody* body2, const HingeJointDesc& desc) = 0;
    virtual IJoint* CreatePrismaticJoint (IRigidBody* body1, IRigidBody* body2, const PrismaticJointDesc& desc) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Фильтрация столкновений объектов
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<bool (IRigidBody*, IRigidBody*)> BroadphaseCollisionFilter;

    virtual void SetCollisionFilter (size_t group1, size_t group2, bool collides, const BroadphaseCollisionFilter& filter = BroadphaseCollisionFilter ()) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработка столкновений объектов
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (const CollisionEvent& event)> CollisionCallback;

    virtual xtl::connection RegisterCollisionCallback (CollisionEventType event_type, const CollisionCallback& callback_handler) = 0;
};

}

}

#endif
