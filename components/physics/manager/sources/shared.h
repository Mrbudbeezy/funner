#ifndef PHYSICS_MANAGER_SHARED_HEADER
#define PHYSICS_MANAGER_SHARED_HEADER

#include <xtl/common_exceptions.h>
#include <xtl/connection.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/iterator.h>
#include <xtl/reference_counter.h>

#include <stl/vector>

#include <media/physics/physics_library.h>

#include <physics/low_level/driver.h>
#include <physics/low_level/joints.h>
#include <physics/low_level/material.h>
#include <physics/low_level/scene.h>
#include <physics/low_level/shape.h>

#include <physics/manager.h>

namespace physics
{

typedef xtl::com_ptr<physics::low_level::IJoint> JointPtr;
typedef xtl::com_ptr<physics::low_level::IScene> ScenePtr;
typedef xtl::com_ptr<physics::low_level::IShape> ShapePtr;
typedef stl::vector<RigidBody>                   RigidBodyArray;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Материал
///////////////////////////////////////////////////////////////////////////////////////////////////
class MaterialImpl : public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор / копирование (полное копирование)
///////////////////////////////////////////////////////////////////////////////////////////////////
    MaterialImpl (physics::low_level::IDriver* driver);
    MaterialImpl (const MaterialImpl&);
    ~MaterialImpl ();

    MaterialImpl& operator = (const MaterialImpl&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление линейной/угловой аммортизацией
///////////////////////////////////////////////////////////////////////////////////////////////////
    float LinearDamping     () const;
    float AngularDamping    () const;
    void  SetLinearDamping  (float value);
    void  SetAngularDamping (float value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление трением
///////////////////////////////////////////////////////////////////////////////////////////////////
    float              Friction               () const;
    const math::vec3f& AnisotropicFriction    () const;
    void               SetFriction            (float value);
    void               SetAnisotropicFriction (const math::vec3f& value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление упругостью
///////////////////////////////////////////////////////////////////////////////////////////////////
    float Restitution    () const;
    void  SetRestitution (float value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (MaterialImpl&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Материал
///////////////////////////////////////////////////////////////////////////////////////////////////
class MaterialInternal : public Material
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    MaterialInternal (MaterialImpl* impl);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Соединение тел
///////////////////////////////////////////////////////////////////////////////////////////////////
class JointImpl : public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор / копирование (подсчет ссылок)
///////////////////////////////////////////////////////////////////////////////////////////////////
    JointImpl (JointPtr joint, const RigidBodyArray& bodies);
    JointImpl (const JointImpl&);
    ~JointImpl ();

    JointImpl& operator = (const JointImpl&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение соединенных тел
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t BodiesCount () const;

    const RigidBody& Body (size_t index) const;
          RigidBody& Body (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (JointImpl&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Соединение тел
///////////////////////////////////////////////////////////////////////////////////////////////////
class JointInternal : public Joint
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    JointInternal (JointImpl* impl);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Физическая сцена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SceneImpl : public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор / копирование (подсчет ссылок)
///////////////////////////////////////////////////////////////////////////////////////////////////
    SceneImpl  (ScenePtr scene);
    SceneImpl  (const SceneImpl&);
    ~SceneImpl ();

    SceneImpl& operator = (const SceneImpl&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание тел
///////////////////////////////////////////////////////////////////////////////////////////////////
    RigidBody CreateBody (const char* name);
    RigidBody CreateBody (const Shape& shape, float mass);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание связей между телами
///////////////////////////////////////////////////////////////////////////////////////////////////
    Joint CreateSphericalJoint (const JointBind& bind1, const JointBind& bind2);
    Joint CreateConeTwistJoint (const JointBind& bind1, const JointBind& bind2, float swing_limit_in_degrees, float twist_limit);
    Joint CreateHingeJoint     (const JointBind& bind1, const JointBind& bind2);
    Joint CreatePrismaticJoint (const JointBind& bind1, const JointBind& bind2);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление гравитацией
///////////////////////////////////////////////////////////////////////////////////////////////////
    const math::vec3f& Gravity    () const;
    void               SetGravity (const math::vec3f& value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры симуляции
///////////////////////////////////////////////////////////////////////////////////////////////////
    float SimulationStep    () const;
    void  SetSimulationStep (float step);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Симуляция
///////////////////////////////////////////////////////////////////////////////////////////////////
    void PerformSimulation (float dt);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Фильтрация столкновений объектов. Объекты сталкиваются, если:
/// - не задан фильтр;
/// - задан дефолтный фильтр и collides = true;
/// - заданный фильтр возвращает true и collides = true;
/// - заданный фильтр возвращает false и collides = false.
///Приоритет фильтрации: чем позже добавлен фильтр, тем выше его приоритет
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t AddCollisionFilter        (const char* group1_mask, const char* group2_mask, bool collides, const Scene::BroadphaseCollisionFilter& filter);
    void   RemoveCollisionFilter     (size_t id);
    void   RemoveAllCollisionFilters ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработка столкновений объектов
///////////////////////////////////////////////////////////////////////////////////////////////////
    xtl::connection RegisterCollisionCallback (const char* group1_mask, const char* group2_mask, CollisionEventType event_type, const CollisionCallback& callback_handler);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отладочная отрисовка
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw (render::debug::PrimitiveRender&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (SceneImpl&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Физическая сцена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SceneInternal : public Scene
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SceneInternal (SceneImpl* impl);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Геометрическое тело
///////////////////////////////////////////////////////////////////////////////////////////////////
class ShapeImpl : public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор / копирование (подсчет ссылок)
///////////////////////////////////////////////////////////////////////////////////////////////////
    ShapeImpl (ShapePtr shape);
    ShapeImpl (const ShapeImpl&);
    ~ShapeImpl ();

    ShapeImpl& operator = (const ShapeImpl&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Толщина полей
///////////////////////////////////////////////////////////////////////////////////////////////////
    void  SetMargin (float value);
    float Margin    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (ShapeImpl&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Геометрическое тело
///////////////////////////////////////////////////////////////////////////////////////////////////
class ShapeInternal : public Shape
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ShapeInternal (ShapeImpl* impl);
};

}

#endif
