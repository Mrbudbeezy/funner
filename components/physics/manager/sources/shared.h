#ifndef PHYSICS_MANAGER_SHARED_HEADER
#define PHYSICS_MANAGER_SHARED_HEADER

#include <xtl/bind.h>
#include <xtl/common_exceptions.h>
#include <xtl/connection.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/iterator.h>
#include <xtl/reference_counter.h>
#include <xtl/trackable.h>

#include <stl/hash_map>
#include <stl/hash_set>
#include <stl/string>
#include <stl/vector>

#include <common/strlib.h>

#include <media/physics/basic_shapes.h>
#include <media/physics/compound.h>
#include <media/physics/physics_library.h>

#include <physics/low_level/driver.h>
#include <physics/low_level/joints.h>
#include <physics/low_level/material.h>
#include <physics/low_level/rigid_body.h>
#include <physics/low_level/scene.h>
#include <physics/low_level/shape.h>

#include <physics/manager.h>

namespace physics
{

typedef xtl::com_ptr<physics::low_level::IJoint>     JointPtr;
typedef xtl::com_ptr<physics::low_level::IRigidBody> RigidBodyPtr;
typedef xtl::com_ptr<physics::low_level::IScene>     ScenePtr;
typedef xtl::com_ptr<physics::low_level::IShape>     ShapePtr;
typedef stl::vector<RigidBody>                       RigidBodyArray;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к внутренним данным материала
///////////////////////////////////////////////////////////////////////////////////////////////////
class MaterialImplProvider
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание
///////////////////////////////////////////////////////////////////////////////////////////////////
    static Material CreateMaterial (physics::low_level::IDriver* driver);
    static Material CreateMaterial (physics::low_level::IDriver* driver, const media::physics::Material& material);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение низкоуровневого материала
///////////////////////////////////////////////////////////////////////////////////////////////////
    static physics::low_level::IMaterial* LowLevelMaterial (const Material& material);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к внутренним данным соединения тел
///////////////////////////////////////////////////////////////////////////////////////////////////
class JointImplProvider
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание
///////////////////////////////////////////////////////////////////////////////////////////////////
    static Joint CreateJoint (JointPtr joint, const RigidBodyArray& bodies);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к внутренним данным физической сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class SceneImplProvider
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание
///////////////////////////////////////////////////////////////////////////////////////////////////
    static Scene CreateScene (physics::low_level::IDriver* driver, ScenePtr scene, const media::physics::PhysicsLibrary::RigidBodyCollection& body_collection);
    static Scene CreateScene (Scene::Impl* impl);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение номера группы коллизий по имени
///////////////////////////////////////////////////////////////////////////////////////////////////
    static size_t CollisionGroupForName (const Scene& scene, const char* name);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к внутренним данным геометрического тела
///////////////////////////////////////////////////////////////////////////////////////////////////
class ShapeImplProvider
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание
///////////////////////////////////////////////////////////////////////////////////////////////////
    static Shape CreateShape (ShapePtr shape);
    static Shape CreateShape (ShapePtr shape, const ShapeList& shape_list);
    static Shape CreateShape (physics::low_level::IDriver* driver, const media::physics::Shape& shape, const math::vec3f& scale);
    static Shape CreateShape (physics::low_level::IDriver* driver, const ShapeList& shape_list);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение низкоуровневого тела
///////////////////////////////////////////////////////////////////////////////////////////////////
    static physics::low_level::IShape* LowLevelShape (const Shape& shape);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание
///////////////////////////////////////////////////////////////////////////////////////////////////
    static Shape CreateShapeCore (physics::low_level::IDriver* driver, const media::physics::Shape& shape, const math::vec3f& scale);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация твердого тела
///////////////////////////////////////////////////////////////////////////////////////////////////
class RigidBodyImpl : public xtl::reference_counter, public xtl::trackable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RigidBodyImpl (RigidBodyPtr in_body, const physics::Shape& in_shape, const physics::Material& in_material, const Scene& scene);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Согласование объекта с группой
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* CollisionGroup    ();
    void        SetCollisionGroup (const char*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение/установка текущей позиции
///////////////////////////////////////////////////////////////////////////////////////////////////
    const Transform& CurrentTransform  ();
    void             SetWorldTransform (const Transform& transform);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработка изменения позиции
///////////////////////////////////////////////////////////////////////////////////////////////////
    void OnTransformUpdate ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Геометрическое тело
///////////////////////////////////////////////////////////////////////////////////////////////////
    physics::Shape& Shape ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Материал
///////////////////////////////////////////////////////////////////////////////////////////////////
    physics::Material& Material    ();
    void               SetMaterial (const physics::Material& material);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение низкоуровневого тела
///////////////////////////////////////////////////////////////////////////////////////////////////
    physics::low_level::IRigidBody* LowLevelBody ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подписка на обновление положения тела
///////////////////////////////////////////////////////////////////////////////////////////////////
    xtl::connection RegisterTransformUpdateCallback (const RigidBody::TransformUpdateCallback& callback_handler);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подписка на столкновения тела
///////////////////////////////////////////////////////////////////////////////////////////////////
    xtl::connection RegisterCollisionCallback (const char* group_mask, CollisionEventType event_type, const CollisionCallback& callback_handler);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение о столкновения тела
///////////////////////////////////////////////////////////////////////////////////////////////////
    void OnCollision (CollisionEventType event_type, RigidBody& second_body, const math::vec3f& collision_point);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработка события о столкновения тела
///////////////////////////////////////////////////////////////////////////////////////////////////
    void ProcessCollisionWithMask (CollisionEventType event_type, RigidBody& this_body, RigidBody& second_body,
                                   const math::vec3f& collision_point, const stl::string& wanted_group_mask,
                                   const CollisionCallback& callback_handler);
    void ProcessCollisionWithHash (CollisionEventType event_type, RigidBody& this_body, RigidBody& second_body,
                                   const math::vec3f& collision_point, size_t wanted_group_hash,
                                   const CollisionCallback& callback_handler);

  private:
    typedef xtl::signal<void (const RigidBody& body)> TransformUpdateSignal;
    typedef xtl::signal<void (CollisionEventType event, RigidBody& first_body, RigidBody& second_body, const math::vec3f& collision_point)> CollisionSignal;

  private:
    Scene                 scene;
    stl::string           collision_group;
    RigidBodyPtr          body;
    physics::Shape        shape;
    physics::Material     material;
    Transform             current_transform;
    xtl::auto_connection  transform_update_connection;
    TransformUpdateSignal transform_update_signal;
    CollisionSignal       collision_signal [CollisionEventType_Num];
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к внутренним данным твердого тела
///////////////////////////////////////////////////////////////////////////////////////////////////
class RigidBodyImplProvider
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание
///////////////////////////////////////////////////////////////////////////////////////////////////
    static RigidBody CreateRigidBody (RigidBodyPtr body, const Shape& shape, const Material& material, const Scene& scene);
    static RigidBody CreateRigidBody (RigidBodyImpl* impl);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение реализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    static RigidBodyImpl* Impl (const RigidBody& body);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение низкоуровневого тела
///////////////////////////////////////////////////////////////////////////////////////////////////
    static physics::low_level::IRigidBody* LowLevelBody (const RigidBody& body);
};

}

#endif
