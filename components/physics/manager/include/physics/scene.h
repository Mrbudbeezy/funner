#ifndef PHYSICS_MANAGER_SCENE_HEADER
#define PHYSICS_MANAGER_SCENE_HEADER

#include <physics/common.h>
#include <physics/joint.h>

namespace render
{

namespace debug
{

///forward declaration
class PrimitiveRender;

}

}

namespace physics
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим ray-test
///////////////////////////////////////////////////////////////////////////////////////////////////
enum RayTestMode
{
  RayTestMode_Nearest,    //ближайшее пересечение
  RayTestMode_Farthest,   //самое дальнее пересечение
  RayTestMode_All,        //все пересечения

  RayTestMode_Num
};

///implementation forwards
class SceneImplProvider;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Физическая сцена
///////////////////////////////////////////////////////////////////////////////////////////////////
class Scene
{
  friend class SceneImplProvider;
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор / копирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    Scene  (const Scene&);
    ~Scene ();
    
    Scene& operator = (const Scene&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Идентификатор
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Id () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание тел
///////////////////////////////////////////////////////////////////////////////////////////////////
    RigidBody CreateRigidBody (const char* name, const math::vec3f& scale = 1.f);
    RigidBody CreateRigidBody (const Shape& shape, float mass);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание связей между телами
///////////////////////////////////////////////////////////////////////////////////////////////////
    Joint CreateSphericalJoint (const JointBind& bind1, const JointBind& bind2);
    Joint CreateConeTwistJoint (const JointBind& bind1, const JointBind& bind2, float swing_limit_in_degrees = 360.0f, float twist_limit_in_degrees = 360.0f);
    Joint CreateHingeJoint     (const JointBind& bind1, const JointBind& bind2);
    Joint CreatePrismaticJoint (const JointBind& bind1, const JointBind& bind2);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление гравитацией
///////////////////////////////////////////////////////////////////////////////////////////////////
    const math::vec3f& Gravity    () const;
    void               SetGravity (const math::vec3f& value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры симуляции
///////////////////////////////////////////////////////////////////////////////////////////////////
    float SimulationStep    () const;
    void  SetSimulationStep (float step);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Симуляция
///////////////////////////////////////////////////////////////////////////////////////////////////
    void PerformSimulation (float dt);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Фильтрация столкновений объектов. Объекты сталкиваются, если:
/// - не задан фильтр;
/// - задан дефолтный фильтр и collides = true;
/// - заданный фильтр возвращает true и collides = true;
/// - заданный фильтр возвращает false и collides = false.
///Приоритет фильтрации: чем позже добавлен фильтр, тем выше его приоритет
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<bool (const RigidBody&, const RigidBody&)> BroadphaseCollisionFilter;

    size_t AddCollisionFilter        (const char* group1_mask, const char* group2_mask, bool collides, const BroadphaseCollisionFilter& filter = BroadphaseCollisionFilter ());
    void   RemoveCollisionFilter     (size_t id);
    void   RemoveAllCollisionFilters ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработка столкновений объектов
///////////////////////////////////////////////////////////////////////////////////////////////////
    xtl::connection RegisterCollisionCallback (const char* group1_mask, const char* group2_mask, CollisionEventType event_type, const CollisionCallback& callback_handler); 

///////////////////////////////////////////////////////////////////////////////////////////////////
///Трассировка луча, порядок вызова не соответствует удаленности объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (RigidBody& body, const math::vec3f& position, const math::vec3f& normal)> RayTestCallback;

    void RayTest (const math::vec3f& ray_origin, const math::vec3f& ray_end, RayTestMode mode, const RayTestCallback& callback_handler);
    void RayTest (const math::vec3f& ray_origin, const math::vec3f& ray_end, size_t groups_count, const char** groups_masks, RayTestMode mode, const RayTestCallback& callback_handler);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отладочная отрисовка
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw (render::debug::PrimitiveRender&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (Scene&);
  
  private:
    struct Impl;

  private:
    Scene (Impl*);

  private:
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (Scene&, Scene&);

}

#endif
