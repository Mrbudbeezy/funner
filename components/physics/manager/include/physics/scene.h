#ifndef PHYSICS_MANAGER_SCENE_HEADER
#define PHYSICS_MANAGER_SCENE_HEADER

#include <physics/common.h>
#include <physics/joint.h>

namespace render
{

namespace debug
{

///forward declarations
class IPrimitiveRender;

}

}

namespace physics
{

///implementation forwards
class SceneImpl;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Физическая сцена
///////////////////////////////////////////////////////////////////////////////////////////////////
class Scene
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор / копирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    Scene  (const Scene&);
    ~Scene ();
    
    Scene& operator = (const Scene&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание тел
///////////////////////////////////////////////////////////////////////////////////////////////////
    RigidBody CreateBody (const char* name);
    RigidBody CreateBody (const Shape& shape, float mass);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание связей между телами
///////////////////////////////////////////////////////////////////////////////////////////////////
    Joint CreateSphericalJoint (const JointBind& bind1, const JointBind& bind2);
    Joint CreateConeTwistJoint (const JointBind& bind1, const JointBind& bind2, float swing_limit_in_degrees = 360.0f, float twist_limit = 360.0f);
    Joint CreateHingeJoint     (const JointBind& bind1, const JointBind& bind2);
    Joint CreatePrismaticJoint (const JointBind& bind1, const JointBind& bind2);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление гравитацией
///////////////////////////////////////////////////////////////////////////////////////////////////
    const math::vec3f& Gravity    () const;
    void               SetGravity (const math::vec3f& value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры симуляции
///////////////////////////////////////////////////////////////////////////////////////////////////
    float SimulationStep    () const;
    void  SetSimulationStep (float step);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Симуляция
///////////////////////////////////////////////////////////////////////////////////////////////////
    void PerformSimulation (float dt);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Фильтрация столкновений объектов. Объекты сталкиваются, если:
/// - не задан фильтр;
/// - задан дефолтный фильтр и collides = true;
/// - заданный фильтр возвращает true и collides = true;
/// - заданный фильтр возвращает false и collides = false.
///Приоритет фильтрации: чем позже добавлен фильтр, тем выше его приоритет
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<bool (const RigidBody&, const RigidBody&)> BroadphaseCollisionFilter;

    size_t AddCollisionFilter        (const char* group1_mask, const char* group2_mask, bool collides, const BroadphaseCollisionFilter& filter = BroadphaseCollisionFilter ());
    void   RemoveCollisionFilter     (size_t id);
    void   RemoveAllCollisionFilters ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработка столкновений объектов
///////////////////////////////////////////////////////////////////////////////////////////////////
    xtl::connection RegisterCollisionCallback (const char* group1_mask, const char* group2_mask, CollisionEventType event_type, const CollisionCallback& callback_handler); 
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Отладочная отрисовка
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw (render::debug::PrimitiveRender&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (Scene&);
  
  protected:
    Scene (SceneImpl*);

  private:
    SceneImpl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (Scene&, Scene&);

}

#endif
