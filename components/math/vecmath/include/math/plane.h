#ifndef MATHLIB_VECMATH_PLANE_HEADER
#define MATHLIB_VECMATH_PLANE_HEADER

#include <cmath>

#ifdef _MSC_VER
  #pragma pack (push, 1)
#endif

namespace math
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сторона плоскости
///////////////////////////////////////////////////////////////////////////////////////////////////
enum plane_side
{
  plane_side_none,         //сама плоскость
  plane_side_positive,     //полуплоскость, в которую направлена нормаль
  plane_side_negative,     //полуплоскость, в которую не направлена нормаль
  plane_side_both          //обе полуплоскости
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Плоскость
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
class plane
{
  public:
    typedef T                  value_type;
    typedef math::vector<T, 3> vec_type;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    plane ();
    plane (const vec_type& normal, const value_type& d);
    plane (const value_type& a, const value_type& b, const value_type& c, const value_type& d);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение параметров
///////////////////////////////////////////////////////////////////////////////////////////////////
    const vec_type& normal () const;
    vec_type&       normal ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Индексирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    value_type&       operator [] (unsigned int index);
    const value_type& operator [] (unsigned int index) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сравнение
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool operator == (const plane&) const;
    bool operator != (const plane&) const;

  public:
    value_type a, b, c, d;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Определения типов
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef plane<int>    planei;
typedef plane<float>  planef;
typedef plane<double> planed;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка эквивалентности
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
bool equal (const plane<T>&, const plane<T>&, const T& eps);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Возвращает нормированную плоскость
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
plane<T> normalize (const plane<T>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Возвращает дистанцию от точки до плоскости
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
typename plane<T>::value_type distance (const plane<T>&, const vector<T, 3>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Возвращает проекцию вектора на плоскость
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
vector<T, 3> project (const plane<T>&, const vector<T, 3>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Возвращает с какой стороны плоскости находится точка
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
plane_side side (const plane<T>&, const vector<T, 3>&, const T& eps = T (0));

///////////////////////////////////////////////////////////////////////////////////////////////////
///Возвращает точку пересечения луча с плоскостью
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
bool intersect (const plane<T>&, const vector<T, 3>& ray_start, const vector<T, 3>& ray_dir, float& scale, const T& eps = T (0));

#include <math/detail/plane.inl>

}

#ifdef _MSC_VER
  #pragma pack(pop)
#endif

#endif
