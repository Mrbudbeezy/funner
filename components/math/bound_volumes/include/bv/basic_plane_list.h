#ifndef BOUND_VOLUMES_BASIC_PLANE_LIST_HEADER
#define BOUND_VOLUMES_BASIC_PLANE_LIST_HEADER

#include <cmath>
#include <cstddef>

#ifndef MATH_BOUND_VOLUMES_PLANE_LIST_NO_DETAILS
  #include <stl/vector>
  #include <xtl/common_exceptions.h>
  #include <xtl/reference_counter.h>
  #include <bv/axis_aligned_box.h>
  #include <bv/sphere.h>
#endif

#include <math/matrix.h>
#include <math/plane.h>

namespace bound_volumes
{

//forward declarations
template <class T> class axis_aligned_box;
template <class T> class sphere;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ограничивающий набор плоскостей
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> class plane_list
{
  public:
    typedef math::plane<T> plane_type;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / копирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    plane_list ();
    plane_list (const plane_list&);
    ~plane_list ();

    plane_list& operator = (const plane_list&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Копирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    plane_list clone () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение количества плоскостей/проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t planes_count () const;
    bool   empty        () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Резервирование плоскостей
///////////////////////////////////////////////////////////////////////////////////////////////////
    void   reserve  (size_t planes_count);
    size_t capacity () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение плоскости
///////////////////////////////////////////////////////////////////////////////////////////////////
    const plane_type& operator [] (size_t index) const;  //no throw
          plane_type& operator [] (size_t index);        //no throw
    const plane_type& at          (size_t index) const;  //may throw exception
          plane_type& at          (size_t index);        //may throw exception

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление плоскости
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t add (size_t planes_count, const plane_type* planes);
    size_t add (const plane_type& plane);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление плоскостей
///////////////////////////////////////////////////////////////////////////////////////////////////
    void remove (size_t index, size_t count = 1);
    void clear  ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление примитивов в ограничивающий объём
///////////////////////////////////////////////////////////////////////////////////////////////////
    plane_list& operator += (const plane_list&);
    plane_list& operator += (const plane_type&);
    plane_list  operator +  (const plane_list&) const;
    plane_list  operator +  (const plane_type&) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сравнение
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool operator == (const plane_list&) const;
    bool operator != (const plane_list&) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void swap (plane_list&);

  private:
    struct implementation;

    plane_list (implementation*);

  private:
    implementation* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
void swap (plane_list<T>&, plane_list<T>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Определения типов
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef plane_list<float>  plane_listf;
typedef plane_list<double> plane_listd;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка пересечения ограничивающей сферы с различными примитивами
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> bool contains   (const plane_list<T>&, const math::vector<T, 3>&, const T& eps = T (0));
template <class T> bool contains   (const plane_list<T>&, const axis_aligned_box<T>&, const T& eps = T (0));
template <class T> bool contains   (const plane_list<T>&, const sphere<T>&, const T& eps = T (0));
template <class T> bool intersects (const plane_list<T>&, const axis_aligned_box<T>&, const T& eps = T (0));
template <class T> bool intersects (const plane_list<T>&, const sphere<T>&, const T& eps = T (0));

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка эквивалентности
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> bool equal (const plane_list<T>&, const plane_list<T>&, const T& eps);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание по матрице
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> plane_list<T> make_frustum (const math::matrix<T, 4>& view_projection);
template <class T> void          add_frustum  (const math::matrix<T, 4>& view_projection, plane_list<T>& planes);

#ifndef MATH_BOUND_VOLUMES_PLANE_LIST_NO_DETAILS
  #include <bv/detail/plane_list.inl>
#endif

}

#endif
