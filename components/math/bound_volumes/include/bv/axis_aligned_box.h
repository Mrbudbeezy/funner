#ifndef BOUND_VOLUMES_AABB_HEADER
#define BOUND_VOLUMES_AABB_HEADER

#include <cmath>

#include <math/matrix.h>
#include <math/quat.h>

namespace bound_volumes
{

//forward declarations
template <class T> class sphere;
template <class T> class plane_list;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Угол ограничивающего параллелипиппеда
///////////////////////////////////////////////////////////////////////////////////////////////////
enum box_corner
{
  box_corner_nxnynz,
  box_corner_pxnynz,
  box_corner_nxpynz,
  box_corner_pxpynz,
  box_corner_nxnypz,
  box_corner_pxnypz,
  box_corner_nxpypz,
  box_corner_pxpypz,
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ограничивающий параллелипиппед с ребрами параллельными осям координат
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> class axis_aligned_box
{
  public:
    typedef T                  element_type;
    typedef math::vector<T, 3> vec_type;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    axis_aligned_box () {}
    axis_aligned_box (const vec_type& vmin, const vec_type& vmax);
    axis_aligned_box (const element_type& min_x, const element_type& min_y, const element_type& min_z,
                      const element_type& max_x, const element_type& max_y, const element_type& max_z);
    axis_aligned_box (const sphere<T>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение экстент
///////////////////////////////////////////////////////////////////////////////////////////////////
    const vec_type& minimum () const;
    const vec_type& maximum () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка экстент
///////////////////////////////////////////////////////////////////////////////////////////////////
    void set_minimum (const vec_type&);
    void set_minimum (const element_type& x, const element_type& y, const element_type& z);
    void set_maximum (const vec_type&);
    void set_maximum (const element_type& x, const element_type& y, const element_type& z);
    void set_extents (const vec_type& vmin, const vec_type& vmax);
    void set_extents (const element_type& min_x, const element_type& min_y, const element_type& min_z,
                      const element_type& max_x, const element_type& max_y, const element_type& max_z);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс объёма
///////////////////////////////////////////////////////////////////////////////////////////////////
    void reset (const vec_type& = vec_type (element_type (0)));

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение статистик ограничивающего параллелипиппеда
///////////////////////////////////////////////////////////////////////////////////////////////////
    vec_type     center () const; //центр
    vec_type     size   () const; //размер параллелипиппеда
    element_type radius () const; //радиус (половина длины диагонали)
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool empty () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение координат углов параллелипиппеда
///////////////////////////////////////////////////////////////////////////////////////////////////
    vec_type corner      (box_corner) const;
    void     get_corners (vec_type corners [8]) const; //в порядке, перечисленном в box_corner    
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление точки в объём / объединение объёмов
///////////////////////////////////////////////////////////////////////////////////////////////////
    axis_aligned_box& operator += (const vec_type&);
    axis_aligned_box& operator += (const axis_aligned_box&);
    axis_aligned_box& operator += (const sphere<T>&);
    axis_aligned_box  operator +  (const vec_type&) const;
    axis_aligned_box  operator +  (const axis_aligned_box&) const;
    axis_aligned_box  operator +  (const sphere<T>&) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Преобразования ограничивающего параллелипиппеда
///////////////////////////////////////////////////////////////////////////////////////////////////
    axis_aligned_box& operator *= (const math::matrix<T, 4>&);
    axis_aligned_box& operator *= (const math::quat<T>&);
    axis_aligned_box  operator *  (const math::matrix<T, 4>&) const;
    axis_aligned_box  operator *  (const math::quat<T>&) const;    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сравнение
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool operator == (const axis_aligned_box&) const;
    bool operator != (const axis_aligned_box&) const;

  private:
    vec_type min_extent, max_extent;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Определения типов
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef axis_aligned_box<int>    aaboxi;
typedef axis_aligned_box<float>  aaboxf;
typedef axis_aligned_box<double> aaboxd;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение объёма
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> T volume (const axis_aligned_box<T>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Преобразования ограничивающего параллелипиппеда
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> axis_aligned_box<T> operator * (const math::matrix<T, 4>&, const axis_aligned_box<T>&);
template <class T> axis_aligned_box<T> operator * (const math::quat<T>&, const axis_aligned_box<T>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка эквивалентности
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> bool equal (const axis_aligned_box<T>&, const axis_aligned_box<T>&, const T& eps);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка пересечения ограничивающего параллелипиппеда с различными примитивами
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> bool intersects (const axis_aligned_box<T>&, const axis_aligned_box<T>&);
template <class T> bool intersects (const axis_aligned_box<T>&, const sphere<T>&);
template <class T> bool intersects (const axis_aligned_box<T>&, const plane_list<T>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка: содержит ли ограничивающий параллелипиппед различные примитивы
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> bool contains (const axis_aligned_box<T>&, const math::vector<T, 3>& point);
template <class T> bool contains (const axis_aligned_box<T>&, const axis_aligned_box<T>& box);
template <class T> bool contains (const axis_aligned_box<T>&, const sphere<T>& s);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Определение области перекрытия двух ограничивающих параллелипиппедов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> axis_aligned_box<T> intersection (const axis_aligned_box<T>&, const axis_aligned_box<T>&);

#include <bv/detail/axis_aligned_box.inl>

}

#endif
