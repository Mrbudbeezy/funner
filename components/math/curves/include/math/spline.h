#ifndef MATH_CURVES_SPLINE_HEADER
#define MATH_CURVES_SPLINE_HEADER

#include <cstddef>

#include <xtl/singleton_default.h>

namespace math
{

namespace detail
{

//implementation forwards
class spline_operations;

}

//forward declarations
template <class T, unsigned int Size> class vector;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип сплайна
///////////////////////////////////////////////////////////////////////////////////////////////////
enum spline_type
{
  spline_key_tcb,      //TCB сплайн
  spline_key_bezier,   //Безье сплайн
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поведение на границе сплайна
///////////////////////////////////////////////////////////////////////////////////////////////////
enum spline_wrap
{
  spline_wrap_clamp,  //обрезание
  spline_wrap_repeat, //повторение
  spline_wrap_mirror, //повторение с чередующимся отражением

  spline_wrap_default = spline_wrap_clamp
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый класс для сплайна
///////////////////////////////////////////////////////////////////////////////////////////////////
class basic_spline
{
  public:
    typedef float       scalar_type;
    typedef scalar_type time_type;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Поведение на границе
///////////////////////////////////////////////////////////////////////////////////////////////////
    void        wrap       (spline_wrap begin_wrap, spline_wrap end_wrap);
    spline_wrap begin_wrap () const;
    spline_wrap end_wrap   () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество ключей / проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t keys_count () const;
    bool   empty      () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Резервирование ключей
///////////////////////////////////////////////////////////////////////////////////////////////////
    void   reserve  (size_t keys_count);
    size_t capacity () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление ключей
///////////////////////////////////////////////////////////////////////////////////////////////////
    void remove_key (size_t key_index);
    void clear      ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сортировка ключей для ускорения поиска
///////////////////////////////////////////////////////////////////////////////////////////////////
    void sort ();        

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    basic_spline  (detail::spline_operations& operations, spline_type type, size_t key_size);
    basic_spline  (const basic_spline&);
    basic_spline  (const implementation*);
    ~basic_spline ();

    basic_spline& operator = (const basic_spline&);      

///////////////////////////////////////////////////////////////////////////////////////////////////
///Копирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    basic_spline clone () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение и обновление ключей
///////////////////////////////////////////////////////////////////////////////////////////////////
    const void* get_keys   () const;
          void* get_keys   ();
          void  update_key (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление ключа
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t add_keys (size_t keys_count, const void* source_data);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Расчёт значения в промежуточной точке
///////////////////////////////////////////////////////////////////////////////////////////////////
    void eval (const time_type& time, void* uninitialized_result) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void swap (basic_spline&);

  private:
    struct implementation;
    implementation* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый ключ сплайна
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> struct spline_key
{
  typedef T                         value_type;
  typedef basic_spline::time_type   time_type;
  typedef basic_spline::scalar_type scalar_type;

  time_type  time;      //время актуализации значения
  value_type value;     //значение
  value_type coefs [4]; //коэффициенты для расчёта сплайна

  spline_key ();
  spline_key (const time_type& time, const value_type& value);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ключ TCB сплайна
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> struct spline_tcb_key: public spline_key<T>
{
  typedef typename spline_key<T>::scalar_type scalar_type;

  scalar_type tension;    //напряженность кривой
  scalar_type bias;       //ассимметричность кривой
  scalar_type continuity; //пологость кривойывафыва

  spline_tcb_key ();
  spline_tcb_key (const time_type& time, const value_type& value);
  spline_tcb_key (const time_type& time, const value_type& value, const scalar_type& tension, const scalar_type& bias, const scalar_type& continuity);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ключ Безье сплайна
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> struct spline_bezier_key: public spline_key<T>
{
  typedef typename spline_key<T>::value_type value_type;

  value_type inner_value; //входящее значение
  value_type outer_value; //исходящее значение
  
  spline_bezier_key ();
  spline_bezier_key (const time_type& time, const value_type& value);
  spline_bezier_key (const time_type& time, const value_type& value, const value_type& inner, const value_type& outer);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение типа ключа по типу сплайна
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, spline_type type> struct spline_key_type;
template <class T>                   struct spline_key_type<spline_type_tcb>    { typedef spline_tcb_key<T>    type; };
template <class T>                   struct spline_key_type<spline_type_bezier> { typedef spline_bezier_key<T> type; };

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметризация сплайна
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, spline_type SplineType> class spline: public basic_spline
{
  public:
    enum { spline_type = SplineType };
  
    typedef typename spline_key_type<T, spline_type>::type key_type;
    typedef typename key_type::value_type                  value_type;
    typedef typename key_type::time_type                   time_type;
    typedef typename key_type::scalar_type                 scalar_type;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    spline  ();
    spline  (const spline&);
    ~spline ();

    spline& operator = (const spline&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Копирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    spline clone () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение / обновление ключа
///////////////////////////////////////////////////////////////////////////////////////////////////
    const key_type& get_key (size_t index) const;
    void            set_key (size_t index, const key_type& key);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление ключа
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t add_keys (size_t keys_count, const key_type* keys);
    size_t add_key  (const key_type& key);
    size_t add_key  (const time_type& time, const value_type& value);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Расчёт значения в промежуточной точке
///////////////////////////////////////////////////////////////////////////////////////////////////
    void       eval (const time_type& time, value_type& out_value) const;
    value_type eval (const time_type& time) const;

    value_type operator () (const time_type& time) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void swap (spline&);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, spline_type SplineType>
void swap (spline<T, SplineType>&, spline<T, SplineType>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Переопределения типов
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef spline<float>             splinef;
typedef spline<vector<float, 2> > spline2f;
typedef spline<vector<float, 3> > spline3f;
typedef spline<vector<float, 4> > spline4f;

#include <math/detail/spline.inl>

}

#endif
