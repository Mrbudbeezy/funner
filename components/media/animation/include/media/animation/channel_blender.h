#ifndef MEDIA_ANIMATION_CHANNEL_BLENDER_HEADER
#define MEDIA_ANIMATION_CHANNEL_BLENDER_HEADER

#include <xtl/type.h>

#include <media/animation/channel.h>

namespace math
{

//forward declaration
template <class T, size_t Size> class matrix;

}

namespace media
{

namespace animation
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый класс для блендера анимационных каналов
///////////////////////////////////////////////////////////////////////////////////////////////////
class ChannelBlenderBase
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    ChannelBlenderBase  (const ChannelBlenderBase&);
    ~ChannelBlenderBase ();
    
    ChannelBlenderBase& operator = (const ChannelBlenderBase&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип значений
///////////////////////////////////////////////////////////////////////////////////////////////////
    const std::type_info& ValueType () const;
    
    //TODO: изменить channel -> source

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество источников
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t ChannelsCount () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление и удаление источников
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddChannel        (const animation::AnimationState& state, const animation::Channel& channel);
    void RemoveChannels    (const animation::AnimationState& state);
    void RemoveChannels    (const animation::Channel& channel);    
    void RemoveAllChannels ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (ChannelBlenderBase&);

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ChannelBlenderBase (const std::type_info& value_type);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение массива каналов для смешивания
///////////////////////////////////////////////////////////////////////////////////////////////////    
    struct ChannelDesc
    {
      detail::IEvaluatorBase* evaluator; //ссылка на вычислитель состояния анимации
      IAnimationState*        state;     //состояние анимации
    };
    
    const ChannelDesc* Channels () const;
    
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (ChannelBlenderBase&, ChannelBlenderBase&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Блендер анимационных каналов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> class ChannelBlender: public ChannelBlenderBase
{
  public:
    typedef T ValueType;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ChannelBlender ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Расчёт значения
///////////////////////////////////////////////////////////////////////////////////////////////////
    ValueType operator () () const;
    void      operator () (ValueType&) const;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Начальное значение для смешивания
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>              T                     blend_init (xtl::type<T>);
template <class T, size_t Size> math::matrix<T, Size> blend_init (xtl::type<math::matrix<T, Size> >);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Смешивание
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> void blend (const T& src_value, float weight, T& result_value);

#include <media/animation/detail/channel_blender.inl>

}

}

#endif

