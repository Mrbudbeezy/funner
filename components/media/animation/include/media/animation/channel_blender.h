#ifndef MEDIA_ANIMATION_CHANNEL_BLENDER_HEADER
#define MEDIA_ANIMATION_CHANNEL_BLENDER_HEADER

#include <xtl/type.h>

#include <media/animation/animation_state.h>
#include <media/animation/channel.h>

namespace math
{

//forward declaration
template <class T, size_t Size> class matrix;

}

namespace media
{

namespace animation
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///События блендера каналов
///////////////////////////////////////////////////////////////////////////////////////////////////
enum ChannelBlenderEvent
{
  ChannelBlenderEvent_OnSourcesAdded,   //добавлены новые анимационные источники
  ChannelBlenderEvent_OnSourcesRemoved, //удалены анимационные источники
  
  ChannelBlenderEvent_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый класс для блендера анимационных каналов
///////////////////////////////////////////////////////////////////////////////////////////////////
class ChannelBlenderBase
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    ChannelBlenderBase  (const ChannelBlenderBase&);
    ~ChannelBlenderBase ();
    
    ChannelBlenderBase& operator = (const ChannelBlenderBase&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип значений
///////////////////////////////////////////////////////////////////////////////////////////////////
    const std::type_info& ValueType () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество источников
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t SourcesCount () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление и удаление источников
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddSource        (const animation::AnimationState& state, const animation::Channel& channel);
    void RemoveSources    (const animation::AnimationState& state);
    void RemoveSources    (const animation::Channel& channel);    
    void RemoveAllSources ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подписка на события блендера каналов
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (ChannelBlenderEvent event)> EventHandler;

    xtl::connection RegisterEventHandler (ChannelBlenderEvent event, const EventHandler& handler) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (ChannelBlenderBase&);

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ChannelBlenderBase (const std::type_info& value_type);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение массива каналов для смешивания
///////////////////////////////////////////////////////////////////////////////////////////////////    
    struct Source
    {
      detail::IEvaluatorBase* evaluator; //ссылка на вычислитель состояния анимации
      IAnimationState*        state;     //состояние анимации
    };
    
    const Source* Sources () const;
    
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (ChannelBlenderBase&, ChannelBlenderBase&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Блендер анимационных каналов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> class ChannelBlender: public ChannelBlenderBase
{
  public:
    typedef T ValueType;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ChannelBlender ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Расчёт значения
///////////////////////////////////////////////////////////////////////////////////////////////////
    ValueType operator () () const;
    void      operator () (ValueType&) const;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Начальное значение для смешивания
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>              T                     blend_init (xtl::type<T>);
template <class T, size_t Size> math::matrix<T, Size> blend_init (xtl::type<math::matrix<T, Size> >);
template <class T>              math::quat<T>         blend_init (xtl::type<math::quat<T> >);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Смешивание
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> void blend (const T& src_value, float weight, T& result_value);

#include <media/animation/detail/channel_blender.inl>

}

}

#endif

