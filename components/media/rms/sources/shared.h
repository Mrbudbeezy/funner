#ifndef MEDIA_RMS_SHARED_HEADER
#define MEDIA_RMS_SHARED_HEADER

#include <stl/algorithm>
#include <stl/hash_set>
#include <stl/hash_map>
#include <stl/vector>
#include <stl/auto_ptr.h>

#include <xtl/bind.h>
#include <xtl/common_exceptions.h>
#include <xtl/ref.h>
#include <xtl/reference_counter.h>
#include <xtl/trackable.h>
#include <xtl/trackable_ptr.h>

#include <common/action_queue.h>
#include <common/file.h>
#include <common/log.h>
#include <common/parser.h>
#include <common/singleton.h>
#include <common/string.h>
#include <common/strlib.h>

#include <media/rms/manager.h>

namespace media
{

namespace rms
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерфейс управления связыванием
///////////////////////////////////////////////////////////////////////////////////////////////////
class ICustomBinding
{
  public:
    virtual ~ICustomBinding () {}      
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Операции над связанными объектами
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void AsyncLoad   (AsyncOperation&) = 0;
    virtual void AsyncUnload (AsyncOperation&) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Возвращение объекта, оповещающего об удалении связывания
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual xtl::trackable* GetTrackable () = 0;    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Внутренний интерфейс группы серверов
///////////////////////////////////////////////////////////////////////////////////////////////////
class IServerGroupInstance
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя группы
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual const char* Name () = 0;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание связывания
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual Binding CreateBinding (const Group&) = 0;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение экземпляра
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual ServerGroup Instance () = 0;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Асинхронная выгрузка ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void AsyncFlushUnusedResources (AsyncOperation&) = 0;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void AddRef  () = 0;
    virtual void Release () = 0;

  protected:
    virtual ~IServerGroupInstance () {}
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация менеджера ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
class ResourceManagerImpl
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ResourceManagerImpl  ();
    ~ResourceManagerImpl ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание группы связывания
///////////////////////////////////////////////////////////////////////////////////////////////////
    Binding CreateBinding (const Group&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация группы ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RegisterServerGroup   (const char* name, IServerGroupInstance*);
    void UnregisterServerGroup (IServerGroupInstance*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск группы серверов
///////////////////////////////////////////////////////////////////////////////////////////////////
    IServerGroupInstance* FindServerGroup (const char* name) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перебор групп
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t                ServerGroupsCount () const;
    IServerGroupInstance* ServerGroup       (size_t index) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс групп ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void FlushUnusedResources ();

  private:
    ResourceManagerImpl (const ResourceManagerImpl&); //no impl
    ResourceManagerImpl& operator = (const ResourceManagerImpl&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

typedef common::Singleton<ResourceManagerImpl> ResourceManagerSingleton;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерфейс асинхронной операции
///////////////////////////////////////////////////////////////////////////////////////////////////
class AsyncOperation
{
  public:
    typedef xtl::function<bool (AsyncOperation&)>  TaskHandler;     //returns true, if task is finished
    typedef Binding::ProgressHandler               ProgressHandler;
    typedef xtl::com_ptr<AsyncOperation>           Pointer;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание операции
///////////////////////////////////////////////////////////////////////////////////////////////////      
    static Pointer Create (const ProgressHandler&);
    static Pointer Create ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление задач
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddTask (const TaskHandler&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние операции
///////////////////////////////////////////////////////////////////////////////////////////////////
    void          SetState (ProgressState);
    ProgressState State    ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оценка количества шагов выполнения операции
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddEstimateSteps (size_t steps_count);
    void AddFinishedSteps (size_t steps_count);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Прогресс выполнения операции
///////////////////////////////////////////////////////////////////////////////////////////////////
    float Value (); //[0;1]

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя текущего обрабатываемого ресурса
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Resource    ();    
    void        SetResource (const char* name);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя этапа обработки
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Stage    ();
    void        SetStage (const char* name);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об обновлении
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateProgress ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddRef  ();
    void Release ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Выполнение операции из очереди
///////////////////////////////////////////////////////////////////////////////////////////////////
    static bool DoStep ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    AsyncOperation  (const ProgressHandler&);
    ~AsyncOperation ();  

    AsyncOperation (const AsyncOperation&); //no impl
    AsyncOperation& operator = (const AsyncOperation&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

}

}

#endif
