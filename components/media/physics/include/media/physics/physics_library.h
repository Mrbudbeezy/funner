#ifndef MEDIA_PHYSICS_PHYSICS_LIBRARY_HEADER
#define MEDIA_PHYSICS_PHYSICS_LIBRARY_HEADER

#include <common/serializer_manager.h>

#include <media/physics/collision_filter.h>
#include <media/physics/material.h>
#include <media/physics/rigid_body.h>
#include <media/physics/shape.h>
#include <media/physics/triangle_mesh.h>

namespace xtl
{

//forward decalration
template <class T> class iterator;

}

namespace media
{

namespace physics
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Коллекция физической библиотеки 
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> class PhysicsLibraryCollection
{
  public:
    typedef T                         Item;
    typedef xtl::iterator<Item>       Iterator;
    typedef xtl::iterator<const Item> ConstIterator;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор/деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    PhysicsLibraryCollection ();
    PhysicsLibraryCollection (const PhysicsLibraryCollection&);
    ~PhysicsLibraryCollection ();

    PhysicsLibraryCollection& operator = (const PhysicsLibraryCollection&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество элементов в библиотеке / проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Size    () const;
    bool   IsEmpty () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перебор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Iterator      CreateIterator ();
    ConstIterator CreateIterator () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение идентификатора элемента библиотеки
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* ItemId (const ConstIterator&) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск элемента в библиотеке
///////////////////////////////////////////////////////////////////////////////////////////////////
          Item* Find (const char* name);
    const Item* Find (const char* name) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление / удаление элементов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Attach    (const char* id, const Item&);
    void Detach    (const char* id);
    void DetachAll ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (PhysicsLibraryCollection&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
void swap (PhysicsLibraryCollection<T>&, PhysicsLibraryCollection<T>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Упорядоченная коллекция
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> class PhysicsLibraryOrderedCollection
{
  public:
    typedef T                         Item;
    typedef xtl::iterator<Item>       Iterator;
    typedef xtl::iterator<const Item> ConstIterator;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор/деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    PhysicsLibraryOrderedCollection ();
    PhysicsLibraryOrderedCollection (const PhysicsLibraryOrderedCollection&);
    ~PhysicsLibraryOrderedCollection ();

    PhysicsLibraryOrderedCollection& operator = (const PhysicsLibraryOrderedCollection&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество элементов / проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Size    () const;
    bool   IsEmpty () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение итератора
///////////////////////////////////////////////////////////////////////////////////////////////////
    Iterator      CreateIterator ();
    ConstIterator CreateIterator () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к элементу по индексу
///////////////////////////////////////////////////////////////////////////////////////////////////
    const Item& operator [] (size_t index) const;
          Item& operator [] (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Резервирование элементов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Capacity () const;
    void   Reserve  (size_t count);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление элементов в коллекцию
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Add (const Item&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление элементов из коллекции
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Remove (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка коллекции
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Clear ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (PhysicsLibraryOrderedCollection&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
void swap (PhysicsLibraryOrderedCollection<T>&, PhysicsLibraryOrderedCollection<T>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Физическая библиотека
///////////////////////////////////////////////////////////////////////////////////////////////////
class PhysicsLibrary
{
  public:
    typedef PhysicsLibraryOrderedCollection<CollisionFilter> CollisionFilterCollection;
    typedef PhysicsLibraryCollection<Material>               MaterialCollection;
    typedef PhysicsLibraryCollection<RigidBody>              RigidBodyCollection;
    typedef PhysicsLibraryCollection<Shape>                  ShapeCollection;
    typedef PhysicsLibraryCollection<shapes::TriangleMesh>   TriangleMeshCollection;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    PhysicsLibrary  ();
    PhysicsLibrary  (const PhysicsLibrary&);
    PhysicsLibrary  (const char* file_name);
    ~PhysicsLibrary ();

    PhysicsLibrary& operator = (const PhysicsLibrary&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя библиотеки
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Name   () const;
    void        Rename (const char*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение коллекций
///////////////////////////////////////////////////////////////////////////////////////////////////
    const CollisionFilterCollection& CollisionFilters () const;
          CollisionFilterCollection& CollisionFilters ();
    const MaterialCollection&        Materials        () const;
          MaterialCollection&        Materials        ();
    const RigidBodyCollection&       RigidBodies      () const;
          RigidBodyCollection&       RigidBodies      ();
    const ShapeCollection&           Shapes           () const;
          ShapeCollection&           Shapes           ();
    const TriangleMeshCollection&    TriangleMeshes   () const;
          TriangleMeshCollection&    TriangleMeshes   ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка / сохранение
///////////////////////////////////////////////////////////////////////////////////////////////////
    struct SaveOptions
    {
      bool        separate_meshes_file;   //сохранять ли меши в отдельном файле
      const char* meshes_file_name;       //если separate_meshes_file == true - имя файла для сохранения мешей

      SaveOptions ();
    };

    void Load (const char* file_name);
    void Save (const char* file_name, const SaveOptions& options) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (PhysicsLibrary&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (PhysicsLibrary&, PhysicsLibrary&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер библиотек анимаций
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef common::ResourceSerializerManager
<
  void (const char* file_name, PhysicsLibrary& library),
  void (const char* file_name, const PhysicsLibrary::SaveOptions& options, const PhysicsLibrary& library)
> PhysicsLibraryManager;

}

}

#endif
