#ifndef MEDIA_PHYSICS_PHYSICS_LIBRARY_HEADER
#define MEDIA_PHYSICS_PHYSICS_LIBRARY_HEADER

#include <common/serializer_manager.h>

#include <media/physics/material.h>
#include <media/physics/rigid_body.h>
#include <media/physics/shape.h>
#include <media/physics/triangle_mesh.h>

namespace xtl
{

//forward decalration
template <class T> class iterator;

}

namespace media
{

namespace physics
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Коллекция физической библиотеки 
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> class PhysicsLibraryCollection
{
  public:
    typedef T                         Item;
    typedef xtl::iterator<Item>       Iterator;
    typedef xtl::iterator<const Item> ConstIterator;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор/деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    PhysicsLibraryCollection ();
    PhysicsLibraryCollection (const PhysicsLibraryCollection&);
    ~PhysicsLibraryCollection ();

    PhysicsLibraryCollection& operator = (const PhysicsLibraryCollection&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество элементов в библиотеке / проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Size    () const;
    bool   IsEmpty () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перебор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Iterator      CreateIterator ();
    ConstIterator CreateIterator () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение идентификатора элемента библиотеки
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* ItemId (const ConstIterator&) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск элемента в библиотеке
///////////////////////////////////////////////////////////////////////////////////////////////////
          Item* Find (const char* name);
    const Item* Find (const char* name) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление / удаление элементов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Attach    (const char* id, const Item&);
    void Detach    (const char* id);
    void DetachAll ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (PhysicsLibraryCollection&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
void swap (PhysicsLibraryCollection<T>&, PhysicsLibraryCollection<T>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Физическая библиотека
///////////////////////////////////////////////////////////////////////////////////////////////////
class PhysicsLibrary
{
  public:
    typedef PhysicsLibraryCollection<RigidBody>            RigidBodyCollection;
    typedef PhysicsLibraryCollection<Material>             MaterialCollection;
    typedef PhysicsLibraryCollection<Shape>                ShapeCollection;
    typedef PhysicsLibraryCollection<shapes::TriangleMesh> TriangleMeshCollection;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    PhysicsLibrary  ();
    PhysicsLibrary  (const PhysicsLibrary&);
    PhysicsLibrary  (const char* file_name);
    ~PhysicsLibrary ();

    PhysicsLibrary& operator = (const PhysicsLibrary&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя библиотеки
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Name   () const;
    void        Rename (const char*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение коллекций
///////////////////////////////////////////////////////////////////////////////////////////////////
    const RigidBodyCollection&    RigidBodies    () const;
          RigidBodyCollection&    RigidBodies    ();
    const MaterialCollection&     Materials      () const;
          MaterialCollection&     Materials      ();
    const ShapeCollection&        Shapes         () const;
          ShapeCollection&        Shapes         ();
    const TriangleMeshCollection& TriangleMeshes () const;
          TriangleMeshCollection& TriangleMeshes ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка / сохранение
///////////////////////////////////////////////////////////////////////////////////////////////////
    struct SaveOptions
    {
      bool        separate_meshes_file;   //сохранять ли меши в отдельном файле
      const char* meshes_file_name;       //если separate_meshes_file == true - имя файла для сохранения мешей

      SaveOptions ();
    };

    void Load (const char* file_name);
    void Save (const char* file_name, const SaveOptions& options) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (PhysicsLibrary&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (PhysicsLibrary&, PhysicsLibrary&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер библиотек анимаций
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef common::ResourceSerializerManager
<
  void (const char* file_name, PhysicsLibrary& library),
  void (const char* file_name, const PhysicsLibrary::SaveOptions& options, const PhysicsLibrary& library)
> PhysicsLibraryManager;

}

}

#endif
