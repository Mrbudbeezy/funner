#ifndef MEDIA_PHYSICS_COLLECTION_HEADER
#define MEDIA_PHYSICS_COLLECTION_HEADER

#include <cstddef>

namespace xtl
{

//forward decalration
template <class T> class iterator;

}

namespace media
{

namespace physics
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Коллекция физической библиотеки 
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> class PhysicsLibraryCollection
{
  public:
    typedef T                         Item;
    typedef xtl::iterator<Item>       Iterator;
    typedef xtl::iterator<const Item> ConstIterator;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор/деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    PhysicsLibraryCollection ();
    PhysicsLibraryCollection (const PhysicsLibraryCollection&);
    ~PhysicsLibraryCollection ();

    PhysicsLibraryCollection& operator = (const PhysicsLibraryCollection&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество элементов в библиотеке / проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Size    () const;
    bool   IsEmpty () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перебор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Iterator      CreateIterator ();
    ConstIterator CreateIterator () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение идентификатора элемента библиотеки
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* ItemId (const ConstIterator&) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск элемента в библиотеке
///////////////////////////////////////////////////////////////////////////////////////////////////
          Item* Find (const char* name);
    const Item* Find (const char* name) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление / удаление элементов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Attach    (const char* id, const Item&);
    void Detach    (const char* id);
    void DetachAll ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (PhysicsLibraryCollection&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
void swap (PhysicsLibraryCollection<T>&, PhysicsLibraryCollection<T>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Упорядоченная коллекция
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> class PhysicsLibraryOrderedCollection
{
  public:
    typedef T                         Item;
    typedef xtl::iterator<Item>       Iterator;
    typedef xtl::iterator<const Item> ConstIterator;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор/деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    PhysicsLibraryOrderedCollection ();
    PhysicsLibraryOrderedCollection (const PhysicsLibraryOrderedCollection&);
    ~PhysicsLibraryOrderedCollection ();

    PhysicsLibraryOrderedCollection& operator = (const PhysicsLibraryOrderedCollection&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество элементов / проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Size    () const;
    bool   IsEmpty () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение итератора
///////////////////////////////////////////////////////////////////////////////////////////////////
    Iterator      CreateIterator ();
    ConstIterator CreateIterator () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Доступ к элементу по индексу
///////////////////////////////////////////////////////////////////////////////////////////////////
    const Item& operator [] (size_t index) const;
          Item& operator [] (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Резервирование элементов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Capacity () const;
    void   Reserve  (size_t count);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление элементов в коллекцию
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Add (const Item&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление элементов из коллекции
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Remove (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка коллекции
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Clear ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (PhysicsLibraryOrderedCollection&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
void swap (PhysicsLibraryOrderedCollection<T>&, PhysicsLibraryOrderedCollection<T>&);

}

}

#endif
