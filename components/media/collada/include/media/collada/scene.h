#ifndef MEDIALIB_COLLADA_SCENE_HEADER
#define MEDIALIB_COLLADA_SCENE_HEADER

#include <media/collada/collection.h>
#include <xtl/intrusive_ptr.h>
#include <math/matrix.h>

namespace media
{

namespace collada
{

//forward declaration
class Surface;
class Texture;
class Model;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип источника света
///////////////////////////////////////////////////////////////////////////////////////////////////
enum LightType
{
  LightType_Ambient, //рассеянное освещение
  LightType_Point,   //точечный источник света
  LightType_Spot,    //направленный конусоидальный источник света
  LightType_Direct,  //направленный цилиндрический источник света
  
  LightType_Default = LightType_Point
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры источника света
///////////////////////////////////////////////////////////////////////////////////////////////////
enum LightParam
{
  LightParam_AttenuationConstant,  //постоянный коэффициент затухания на расстоянии
  LightParam_AttenuationLinear,    //линейный коэффициент затухания на расстоянии
  LightParam_AttenuationQuadratic, //квадратичный коэффициент затухания на расстоянии
  LightParam_FalloffAngle,         //угол затухания
  LightParam_FalloffExponent,      //экспоненциальный коэффициент затухания по углу

  LightParam_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип камеры
///////////////////////////////////////////////////////////////////////////////////////////////////
enum CameraType
{
  CameraType_Perspective, //перспективная камера
  CameraType_Orthographic //ортографическая камера
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры камеры
///////////////////////////////////////////////////////////////////////////////////////////////////
enum CameraParam
{
  CameraParam_ZNear,       //расстояниие до ближней плоскости отсечения
  CameraParam_ZFar,        //расстояниие до дальней плоскости отсечения
  CameraParam_AspectRatio, //коэффициент масштабирования по осям
  CameraParam_XFov,        //угол обзора по X
  CameraParam_YFov,        //угол обзора по Y
  CameraParam_XMagnitude,  //??
  CameraParam_YMagnitude,  //??  
  
  CameraParam_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Источник света
///////////////////////////////////////////////////////////////////////////////////////////////////
class Light
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    Light  ();
    Light  (const Light&);
    ~Light ();

    Light& operator = (const Light&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание копии
///////////////////////////////////////////////////////////////////////////////////////////////////
    Light Clone () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Идентификатор источника
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Id    () const;
    void        SetId (const char* id);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип источника
///////////////////////////////////////////////////////////////////////////////////////////////////
    LightType Type    () const;
    void      SetType (LightType type);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Цвет источника
///////////////////////////////////////////////////////////////////////////////////////////////////
    const math::vec3f& Color    () const;
    void               SetColor (const math::vec3f& color);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры источника
///////////////////////////////////////////////////////////////////////////////////////////////////
    void  SetParam (LightParam param, float value);
    float Param    (LightParam param) const;

  private:
    struct Impl;
    
    Light (Impl*);
    
  private:
    xtl::intrusive_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Камера
///////////////////////////////////////////////////////////////////////////////////////////////////
class Camera
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    Camera  ();
    Camera  (const Camera&);
    ~Camera ();
    
    Camera& operator = (const Camera&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание копии
///////////////////////////////////////////////////////////////////////////////////////////////////
    Camera Clone () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Идентификатор камеры
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Id    () const;
    void        SetId (const char* id);
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип камеры
///////////////////////////////////////////////////////////////////////////////////////////////////
    CameraType Type    () const;
    void       SetType (CameraType type);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры камеры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void  SetParam (CameraParam param, float value);
    float Param    (CameraParam param) const;

   private:
     struct Impl;
     
     Camera (Impl*);
     
   private:
     xtl::intrusive_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединённые материалы
///////////////////////////////////////////////////////////////////////////////////////////////////
class MaterialBinds
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    MaterialBinds  ();
    MaterialBinds  (const MaterialBinds&);
    ~MaterialBinds ();

    MaterialBinds& operator = (const MaterialBinds&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание копии
///////////////////////////////////////////////////////////////////////////////////////////////////
    MaterialBinds Clone () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск материала
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* FindMaterial (const char* symbol) const; //no throw
    const char* FindMaterial (const Surface&) const;     //no throw

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка материала / удаление материала
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetMaterial    (const char* symbol, const char* material_id);
    void RemoveMaterial (const char* symbol);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение имени канала текстурных координат поверхности
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* TexcoordChannelName       (const char* material, const char* texchannel) const; //no throw
    void        SetTexcoordChannelName    (const char* material, const char* texchannel, const char* surface_channel);
    void        RemoveTexcoordChannelName (const char* material, const char* texchannel);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение номера канала текстурных координат поверхности. -1 в случае неудачи
///////////////////////////////////////////////////////////////////////////////////////////////////
    int FindTexcoordChannel (const Surface&, const Texture&) const; //nothrow

///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Clear ();

  private:
    struct Impl;
    
    MaterialBinds (Impl*);
    
  private:
    xtl::intrusive_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Инстанцированный меш
///////////////////////////////////////////////////////////////////////////////////////////////////
class InstanceMesh
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    InstanceMesh  ();
    InstanceMesh  (const InstanceMesh&);
    ~InstanceMesh ();    

    InstanceMesh& operator = (const InstanceMesh&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание копии
///////////////////////////////////////////////////////////////////////////////////////////////////
    InstanceMesh Clone () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Меш
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Mesh    () const;
    void        SetMesh (const char* mesh_id);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединённые материалы
///////////////////////////////////////////////////////////////////////////////////////////////////
          collada::MaterialBinds& MaterialBinds ();
    const collada::MaterialBinds& MaterialBinds () const;

  private:
    struct Impl;
    
    InstanceMesh (Impl*);
    
  private:
    xtl::intrusive_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Инстанцированный контроллер
///////////////////////////////////////////////////////////////////////////////////////////////////
class InstanceController
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    InstanceController  ();
    InstanceController  (const InstanceController&);
    ~InstanceController ();    

    InstanceController& operator = (const InstanceController&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание копии
///////////////////////////////////////////////////////////////////////////////////////////////////
    InstanceController Clone () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контроллер
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Controller    () const;
    void        SetController (const char* controller_id);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Определение имени базового меша
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* FindBaseMesh (const Model&) const; //0 в случае неудачи

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединённые материалы
///////////////////////////////////////////////////////////////////////////////////////////////////
          collada::MaterialBinds& MaterialBinds ();
    const collada::MaterialBinds& MaterialBinds () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ссылки на корни поиска узлов для скининга
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t      JointSearchRootsCount     () const;
    const char* JointSearchRoot           (size_t root_index) const;
    size_t      InsertJointSearchRoot     (const char* node_id); //ret: joint_root index
    void        RemoveJointSearchRoot     (size_t root_index);
    void        RemoveAllJointSearchRoots ();

  private:
    struct Impl;
    
    InstanceController (Impl*);
    
  private:
    xtl::intrusive_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Узел сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class Node
{
  public:
    typedef ICollection<Node>               NodeList;
    typedef ICollection<Camera>             CameraList;
    typedef ICollection<Light>              LightList;
    typedef ICollection<InstanceMesh>       MeshList;
    typedef ICollection<InstanceController> ControllerList;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    Node  ();
    Node  (const Node&);
    ~Node ();

    Node& operator = (const Node&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание копии
///////////////////////////////////////////////////////////////////////////////////////////////////
    Node Clone () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Идентификатор узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Id    () const;
    void        SetId (const char* id);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Идентификатор узла в пределах родительского узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* SubId    () const;
    void        SetSubId (const char* sub_id);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Name    () const;
    void        SetName (const char* name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Преобразование узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    const math::mat4f& Transform    () const;    
    void               SetTransform (const math::mat4f&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Центры поворота и масштабирования
///////////////////////////////////////////////////////////////////////////////////////////////////
    const math::vec3f& RotationPivot    () const;
    const math::vec3f& ScalePivot       () const;
    void               SetRotationPivot (const math::vec3f&);
    void               SetScalePivot    (const math::vec3f&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Коллекции узла
///////////////////////////////////////////////////////////////////////////////////////////////////
          NodeList&       Nodes       ();       //узлы-потомки
    const NodeList&       Nodes       () const;
          LightList&      Lights      ();       //источники света
    const LightList&      Lights      () const;
          CameraList&     Cameras     ();       //камеры
    const CameraList&     Cameras     () const;
          MeshList&       Meshes      ();       //меши
    const MeshList&       Meshes      () const;
          ControllerList& Controllers ();       //контроллеры
    const ControllerList& Controllers () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск потомка по Sub-ID
///////////////////////////////////////////////////////////////////////////////////////////////////
          Node* FindChild (const char* sub_id);
    const Node* FindChild (const char* sub_id) const;

  private:
    struct Impl;
    
    Node (Impl*);
    
  private:
    xtl::intrusive_ptr<Impl> impl;
};

}

}

#endif
