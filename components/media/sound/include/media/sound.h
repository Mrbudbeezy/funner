#ifndef MEDIALIB_SOUND_HEADER
#define MEDIALIB_SOUND_HEADER

#include <stl/auto_ptr.h>

#include <xtl/functional_fwd>

#include <common/serializer_manager.h>

namespace media
{

//////////////////////////////////////////////////////////////////////////////////////////////////
///Пользовательский декодер звука
//////////////////////////////////////////////////////////////////////////////////////////////////
class ISoundInputStream
{
  public:
//////////////////////////////////////////////////////////////////////////////////////////////////
///Чтение декодированного звука количеством size сэмплов начиная с position сэмпла в data
//////////////////////////////////////////////////////////////////////////////////////////////////
    virtual size_t Read (size_t first_sample, size_t samples_count, void* data) = 0;

//////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
//////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void AddRef () = 0;
    virtual void Release () = 0;

  protected:
    virtual ~ISoundInputStream () {}
};

//////////////////////////////////////////////////////////////////////////////////////////////////
///Информация о звуке
//////////////////////////////////////////////////////////////////////////////////////////////////
struct SoundSampleInfo
{
  size_t samples_count;    //количество сэмплов в файле
  size_t frequency;        //частота дискретизации
  size_t channels;         //количество каналов
  size_t bits_per_sample;  //количество битов на один сэмпл
};

//////////////////////////////////////////////////////////////////////////////////////////////////
///Звук
//////////////////////////////////////////////////////////////////////////////////////////////////
class SoundSample
{
  public:
             SoundSample  ();
             SoundSample  (ISoundInputStream*);
             SoundSample  (const SoundSample& source);
    explicit SoundSample  (const char* file_name);
             ~SoundSample ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Load (const char* file_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    SoundSample& operator = (const SoundSample&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя сэмпла
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Name   () const;
    void        Rename (const char* new_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Функции расчёта одних характеристик через другие (всегда происходит округление в меньшую сторону)
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t SamplesToBytes   (size_t sample_count) const;   //перевод количества сэмплов в размер в байтах
    size_t BytesToSamples   (size_t byte_count)   const;   //перевод количества байт в размер в сэмплах
    double SamplesToSeconds (size_t sample_count) const;   //перевод количества сэмплов в размер в секундах
    size_t SecondsToSamples (double second_count) const;   //переводколичества секунд в размер в сэмплах

///////////////////////////////////////////////////////////////////////////////////////////////////
///Характеристики
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t SamplesCount  () const; //количество сэмплов
    size_t SizeInBytes   () const; //размер звука в байтах
    size_t Frequency     () const; //количество сэмплов в секунду (частота)
    size_t Channels      () const; //количество каналов
    size_t BitsPerSample () const; //количество битов на сэмпл
    double Duration      () const { return SamplesToSeconds (SamplesCount ()); } //продолжительность
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Read (size_t first_sample, size_t samples_count, void* data); //ret: прочитанное количество сэмплов

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сохранение
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Save (const char* file_name) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (SoundSample&);

  private:
    struct Impl;

    stl::auto_ptr<Impl> impl;
};

//////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
//////////////////////////////////////////////////////////////////////////////////////////////////
void swap (SoundSample&,SoundSample&);

//////////////////////////////////////////////////////////////////////////////////////////////////
///Система управления звуками
//////////////////////////////////////////////////////////////////////////////////////////////////
typedef common::ResourceSerializerManager<ISoundInputStream* (const char* file_name, SoundSampleInfo& sound_sample_info), 
                                          void (const char* file_name, const SoundSample& sound_sample)> SoundSampleManager;

}

#endif
