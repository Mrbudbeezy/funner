#ifndef MEDIALIB_SOUND_HEADER
#define MEDIALIB_SOUND_HEADER

#include <xtl/functional_fwd>

#include <common/serializer_manager.h>

namespace media
{

//////////////////////////////////////////////////////////////////////////////////////////////////
///Пользовательский декодер звука
//////////////////////////////////////////////////////////////////////////////////////////////////
class ISoundInputStream
{
  public:
//////////////////////////////////////////////////////////////////////////////////////////////////
///Чтение декодированного звука количеством size сэмплов начиная с position сэмпла в data
//////////////////////////////////////////////////////////////////////////////////////////////////
    virtual unsigned int Read (unsigned int first_sample, unsigned int samples_count, void* data) = 0;

//////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
//////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void AddRef () = 0;
    virtual void Release () = 0;

  protected:
    virtual ~ISoundInputStream () {}
};

//////////////////////////////////////////////////////////////////////////////////////////////////
///Информация о звуке
//////////////////////////////////////////////////////////////////////////////////////////////////
struct SoundSampleInfo
{
  unsigned int   samples_count;    //количество сэмплов в файле
  unsigned int   frequency;        //частота дискретизации
  unsigned short channels;         //количество каналов
  unsigned char  bits_per_sample;  //количество битов на один сэмпл
};

//////////////////////////////////////////////////////////////////////////////////////////////////
///Звук
//////////////////////////////////////////////////////////////////////////////////////////////////
class SoundSample
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
             SoundSample  ();
             SoundSample  (ISoundInputStream*);
             SoundSample  (const SoundSample& source);
    explicit SoundSample  (const char* file_name);
             ~SoundSample ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Load (const char* file_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    SoundSample& operator = (const SoundSample&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Клонирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    SoundSample Clone () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя сэмпла
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Name   () const;
    void        Rename (const char* new_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Функции расчёта одних характеристик через другие (всегда происходит округление в меньшую сторону)
///////////////////////////////////////////////////////////////////////////////////////////////////
    unsigned int SamplesToBytes   (unsigned int sample_count) const;   //перевод количества сэмплов в размер в байтах
    unsigned int BytesToSamples   (unsigned int byte_count)   const;   //перевод количества байт в размер в сэмплах
    double       SamplesToSeconds (unsigned int sample_count) const;   //перевод количества сэмплов в размер в секундах
    unsigned int SecondsToSamples (double second_count) const;   //переводколичества секунд в размер в сэмплах

///////////////////////////////////////////////////////////////////////////////////////////////////
///Характеристики
///////////////////////////////////////////////////////////////////////////////////////////////////
    unsigned int   SamplesCount  () const; //количество сэмплов
    unsigned int   SizeInBytes   () const; //размер звука в байтах
    unsigned int   Frequency     () const; //количество сэмплов в секунду (частота)
    unsigned short Channels      () const; //количество каналов
    unsigned char  BitsPerSample () const; //количество битов на сэмпл
    double         Duration      () const { return SamplesToSeconds (SamplesCount ()); } //продолжительность
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    unsigned int Read (unsigned int first_sample, unsigned int samples_count, void* data); //ret: прочитанное количество сэмплов

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сохранение
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Save (const char* file_name) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (SoundSample&);

  private:
    struct Impl;

  private:
    SoundSample (Impl* impl);

  private:
    Impl* impl;
};

//////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
//////////////////////////////////////////////////////////////////////////////////////////////////
void swap (SoundSample&,SoundSample&);

//////////////////////////////////////////////////////////////////////////////////////////////////
///Система управления звуками
//////////////////////////////////////////////////////////////////////////////////////////////////
typedef common::ResourceSerializerManager<ISoundInputStream* (const char* file_name, SoundSampleInfo& sound_sample_info), 
                                          void (const char* file_name, const SoundSample& sound_sample)> SoundSampleManager;

}

#endif
