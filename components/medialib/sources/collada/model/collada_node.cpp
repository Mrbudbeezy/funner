#include "shared.h"

using namespace media::collada;

/*
    Описание реализации узла
*/

typedef CollectionImpl<Node>         NodeListImpl;
typedef CollectionImpl<Light>        LightListImpl;
typedef CollectionImpl<Camera>       CameraListImpl;
typedef CollectionImpl<InstanceMesh> InstanceMeshListImpl;

struct Node::Impl: public xtl::reference_counter
{
  stl::string          id;      //идентификатор узла
  stl::string          sid;     //идентификатор узла в пределах родителя
  stl::string          name;    //имя узла
  math::mat4f          tm;      //матрица преобразований узла
  NodeListImpl         nodes;   //вложенные узлы
  LightListImpl        lights;  //источники света
  CameraListImpl       cameras; //камеры
  InstanceMeshListImpl meshes;  //меши
};

/*
    Конструкторы / деструктор / присваивание
*/

Node::Node ()
  : impl (new Impl, false)
  {}
  
Node::Node (const Node& node, media::CloneMode mode)
  : impl (media::clone (node.impl, mode, "media::collada::Node::Node"))
  {}

Node::~Node ()
{
}

Node& Node::operator = (const Node& node)
{
  impl = node.impl;

  return *this;
}

/*
    Идентификатор узла
*/

const char* Node::Id () const
{
  return impl->id.c_str ();
}

void Node::SetId (const char* id)
{
  if (!id)
    common::RaiseNullArgument ("media::collada::Node::SetId", "id");
    
  impl->id = id;
}

/*
    Идентификатор узла в пределах родительского узла
*/

const char* Node::SubId () const
{
  return impl->sid.c_str ();
}

void Node::SetSubId (const char* sid)
{
  if (!sid)
    common::RaiseNullArgument ("media::collada::Node::SetSubId", "sid");
    
  impl->sid = sid;
}

/*
    Имя узла
*/

const char* Node::Name () const
{
  return impl->name.c_str ();
}

void Node::SetName (const char* name)
{
  if (!name)
    common::RaiseNullArgument ("media::collada::Node::SetName", "name");
    
  impl->name = name;
}
  
/*
    Преобразование узла
*/

const math::mat4f& Node::Transform () const
{
  return impl->tm;
}

void Node::SetTransform (const math::mat4f& tm)
{
  impl->tm = tm;
}

/*
    Коллекции узла
*/

Node::NodeList& Node::Nodes ()
{
  return impl->nodes;
}

const Node::NodeList& Node::Nodes () const
{
  return impl->nodes;
}

Node::LightList& Node::Lights ()
{
  return impl->lights;
}

const Node::LightList& Node::Lights () const
{
  return impl->lights;
}

Node::CameraList& Node::Cameras ()
{
  return impl->cameras;
}

const Node::CameraList& Node::Cameras () const
{
  return impl->cameras;
}

Node::MeshList& Node::Meshes ()
{
  return impl->meshes;
}

const Node::MeshList& Node::Meshes () const
{
  return impl->meshes;
}
