#ifndef MEDIALIB_GEOMETRY_MESH_LIBRARY_HEADER
#define MEDIALIB_GEOMETRY_MESH_LIBRARY_HEADER

#include <media/geometry/mesh.h>
#include <xtl/functional_fwd>
#include <stl/auto_ptr.h>

namespace xtl
{

//forward declarations
template <class T> class iterator;

}

namespace media
{

namespace collada
{

//forward declarations
class Model;

}

namespace geometry
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Библиотека мешей
///////////////////////////////////////////////////////////////////////////////////////////////////
class MeshLibrary
{
  public:
    typedef xtl::iterator<Mesh>       Iterator;
    typedef xtl::iterator<const Mesh> ConstIterator;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    MeshLibrary  ();
    MeshLibrary  (const char* file_name);
    MeshLibrary  (const MeshLibrary&);
    ~MeshLibrary ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    MeshLibrary& operator = (const MeshLibrary&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя модели
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Name   () const;
    void        Rename (const char*);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество мешей / проверка на пустоту
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Size    () const;
    bool   IsEmpty () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение итератора
///////////////////////////////////////////////////////////////////////////////////////////////////
    Iterator      CreateIterator ();
    ConstIterator CreateIterator () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Идентификатор меша в библиотеке
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* ItemId (const ConstIterator&) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск мешей
///////////////////////////////////////////////////////////////////////////////////////////////////
          Mesh* Find (const char* name);
    const Mesh* Find (const char* name) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединение мешей
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Attach    (const char* name, Mesh& mesh, CloneMode mode = CloneMode_Instance);
    void Detach    (const char* name); //no throw
    void DetachAll ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Clear ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка (аддитивная) / сохранение
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Load (const char* file_name);
    void Save (const char* file_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (MeshLibrary&);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (MeshLibrary&, MeshLibrary&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Преобразование коллада-модели в библиотеку мешей
///////////////////////////////////////////////////////////////////////////////////////////////////
void convert (const collada::Model& source, MeshLibrary& destination);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер библиотек мешей
///////////////////////////////////////////////////////////////////////////////////////////////////
class MeshLibraryManager
{
  public:
    typedef xtl::function<void (const char*,       MeshLibrary&)> LoadHandler;
    typedef xtl::function<void (const char*, const MeshLibrary&)> SaveHandler;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с пользовательскими функциями загрузки и сохранения
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void RegisterLoader   (const char* extension, const LoadHandler& loader);
    static void RegisterSaver    (const char* extension, const SaveHandler& saver);
    static void UnregisterLoader (const char* extension);
    static void UnregisterSaver  (const char* extension);
    static void UnregisterAll    ();  
};

}

}

#endif
