#ifndef MEDIALIB_RFX_MATERIAL_LIBRARY_HEADER
#define MEDIALIB_RFX_MATERIAL_LIBRARY_HEADER

#include <media/rfx/material.h>

namespace media
{

namespace rfx
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Библиотека материалов
///////////////////////////////////////////////////////////////////////////////////////////////////
class MaterialLibrary
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    MaterialLibrary  ();
    MaterialLibrary  (const char* file_name);
    MaterialLibrary  (const MaterialLibrary&);
    ~MaterialLibrary ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    MaterialLibrary& operator = (const MaterialLibrary&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя библиотеки
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Name   () const;
    void        Rename (const char* name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество материалов в библиотеке
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t MaterialsCount () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение материалов
///////////////////////////////////////////////////////////////////////////////////////////////////
    const rfx::Material& Material (size_t index) const;
          rfx::Material& Material (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединение материалов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Attach    (rfx::Material& material, CloneMode mode = CloneMode_Instance);
    void   Detach    (size_t index); //no throw
    void   DetachAll ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка библиотеки
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Clear ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка / сохранение
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Load (const char* file_name);
    void Save (const char* file_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (MaterialLibrary&);
  
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (MaterialLibrary&, MaterialLibrary&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Система управления материалами
///////////////////////////////////////////////////////////////////////////////////////////////////
class MaterialSystem
{
  public:
    typedef xtl::function<void (const char*,       MaterialLibrary&)> LoadHandler;
    typedef xtl::function<void (const char*, const MaterialLibrary&)> SaveHandler;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с пользовательскими функциями загрузки и сохранения
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void RegisterLoader   (const char* extension, const LoadHandler& loader);
    static void RegisterSaver    (const char* extension, const SaveHandler& saver);
    static void UnregisterLoader (const char* extension);
    static void UnregisterSaver  (const char* extension);
    static void UnregisterAll    ();
};

}

}

#endif
