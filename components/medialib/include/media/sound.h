#ifndef MEDIALIB_SOUND_HEADER
#define MEDIALIB_SOUND_HEADER

#include <stl/memory> // в будущем design/pointer.h
#include <design/function.h>
#include <common/file.h>

namespace medialib
{

//implementation forwards
class SoundSampleImpl;

//////////////////////////////////////////////////////////////////////////////////////////////////
///Пользовательский декодер звука
//////////////////////////////////////////////////////////////////////////////////////////////////
class SoundCodec
{
  public:
    virtual ~SoundCodec () {}

//////////////////////////////////////////////////////////////////////////////////////////////////
///Чтение декодированного звука количеством size сэмплов начиная с position сэмпла в data
//////////////////////////////////////////////////////////////////////////////////////////////////
    virtual size_t Read (size_t first_sample, size_t samples_count, void* data) = 0;

//////////////////////////////////////////////////////////////////////////////////////////////////
///Функция клонирования, используется при копировании сэмпла
//////////////////////////////////////////////////////////////////////////////////////////////////
    virtual SoundCodec* Clone () = 0;
};

//////////////////////////////////////////////////////////////////////////////////////////////////
///Информация о звуке
//////////////////////////////////////////////////////////////////////////////////////////////////
struct SoundSampleInfo
{
  size_t samples_count;    //количество сэмплов в файле
  size_t frequency;        //частота дискретизации
  size_t channels;         //количество каналов
  size_t bits_per_sample;  //количество битов на один сэмпл
};

//////////////////////////////////////////////////////////////////////////////////////////////////
///Звук
//////////////////////////////////////////////////////////////////////////////////////////////////
class SoundSample
{
  public:
             SoundSample  ();
             SoundSample  (const SoundSample& source);
    explicit SoundSample  (const char* file_name);
             ~SoundSample ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Load (const char* file_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    SoundSample& operator = (const SoundSample&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя сэмпла
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Name   () const;
    void        Rename (const char* new_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Функции расчёта одних характеристик через другие (всегда происходит округление в меньшую сторону)
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t SamplesToBytes   (size_t sample_count) const;   //перевод количества сэмплов в размер в байтах
    size_t BytesToSamples   (size_t byte_count)   const;   //перевод количества байт в размер в сэмплах
    double SamplesToSeconds (size_t sample_count) const;   //перевод количества сэмплов в размер в секундах
    size_t SecondsToSamples (double second_count) const;   //переводколичества секунд в размер в сэмплах

///////////////////////////////////////////////////////////////////////////////////////////////////
///Характеристики
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t SamplesCount  () const; //количество сэмплов
    size_t SizeInBytes   () const; //размер звука в байтах
    size_t Frequency     () const; //количество сэмплов в секунду (частота)
    size_t Channels      () const; //количество каналов
    size_t BitsPerSample () const; //количество битов на сэмпл
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Read (size_t first_sample, size_t samples_count, void* data); //ret: прочитанное количество сэмплов

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (SoundSample&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработчик загрузки звука по умолчанию
///////////////////////////////////////////////////////////////////////////////////////////////////
    static SoundCodec* DefaultWavLoader (const char* file_name, SoundSampleInfo& sound_sample_info);    
    static SoundCodec* DefaultOggLoader (const char* file_name, SoundSampleInfo& sound_sample_info);    

  private:
    SoundSample (SoundSampleImpl*);

    stl::auto_ptr<SoundSampleImpl> impl;
};

//////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
//////////////////////////////////////////////////////////////////////////////////////////////////
void swap (SoundSample&,SoundSample&);

//////////////////////////////////////////////////////////////////////////////////////////////////
///Система управления звуками
//////////////////////////////////////////////////////////////////////////////////////////////////
class SoundSampleSystem
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка пользовательской функции лога дебаг-сообщений
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void SetDebugLog (const design::function<void (const char* message)>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация пользовательских функций загрузки
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef design::function<SoundCodec* (const char* file_name, SoundSampleInfo&)> CodecLoadFunc; //получение информации о файле и инициализация кодека

    static bool RegisterCodec       (const char* extension, const CodecLoadFunc& loader);  //возвращает true при успешной регистрации, и false, если такое расширение уже зарегестрировано
    static void UnregisterCodec     (const char* extension);
    static void UnregisterAllCodecs ();
};

}

#endif
