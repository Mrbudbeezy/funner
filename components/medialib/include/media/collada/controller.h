#ifndef MEDIALIB_COLLADA_CONTROLLER_HEADER
#define MEDIALIB_COLLADA_CONTROLLER_HEADER

#include <media/collada/utility.h>
#include <math/mathlib.h>

namespace medialib
{

namespace collada
{

//forward declarations
class Skin;
class Morph;
class Controller;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Библиотекa контроллеров
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef ILibrary<Skin>       SkinLibrary;
typedef ILibrary<Morph>      MorphLibrary;
typedef ILibrary<Controller> ControllerLibrary;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип контроллера
///////////////////////////////////////////////////////////////////////////////////////////////////
enum ControllerType
{
  ControllerType_Skin,  //скин контроллер
  ControllerType_Morph  //морф контроллер
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Метод морфинга
///////////////////////////////////////////////////////////////////////////////////////////////////
enum MorphMethod
{
  MorphMethod_Normalized, //(Target1, Target2, ...)*(w1, w2, ...) = (1-w1-w2-...)*BaseMesh + w1*Target1 + w2*Target2 + ...
  MorphMethod_Relative    //(Target1, Target2, ...) + (w1, w2, ...) = BaseMesh + w1*Target1 + w2*Target2 + ...
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вес соединения
///////////////////////////////////////////////////////////////////////////////////////////////////
struct JointWeight
{
  size_t joint;  //номер соединения
  float  weight; //вес соединения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Информация о соединениях действующих на вершину
///////////////////////////////////////////////////////////////////////////////////////////////////
struct VertexInfluence
{
  size_t first_weight;  //индекс первого веса соединения действиющего на вершину
  size_t weights_count; //количество весов соединений действующих на вершину
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Скин
///////////////////////////////////////////////////////////////////////////////////////////////////
class Skin: public Entity
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Библиотека
///////////////////////////////////////////////////////////////////////////////////////////////////
    SkinLibrary& Library () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый меш
///////////////////////////////////////////////////////////////////////////////////////////////////  
    const collada::Mesh& Mesh () const;
          collada::Mesh& Mesh ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Матрица фигуры 
///////////////////////////////////////////////////////////////////////////////////////////////////
    const math::mat4f& BindShapeMatrix () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с соединениями
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t             JointsCount    () const;
    const char*        JointName      (size_t joint_index) const;
    const math::mat4f& JointInvMatrix (size_t joint_index) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с весами
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t                 InfluencesCount () const; //совпадает с количеством вершин в меше
    size_t                 WeightsCount    () const; 
    const JointWeight*     Weights         () const;
    const VertexInfluence* Influences      () const;
    
  protected:
    Skin  (SkinLibrary& library, const char* id);
    ~Skin ();
    
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Морфирующая геометрия
///////////////////////////////////////////////////////////////////////////////////////////////////
class Morph: public Entity
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Библиотека
///////////////////////////////////////////////////////////////////////////////////////////////////
    MorphLibrary& Library () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый меш
///////////////////////////////////////////////////////////////////////////////////////////////////  
    const collada::Mesh& Mesh () const;
          collada::Mesh& Mesh ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Метод морфинга
///////////////////////////////////////////////////////////////////////////////////////////////////
    MorphMethod Method () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с целями морфинга
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t               TargetsCount () const;
    float                TargetWeight (size_t index) const;
    const collada::Mesh& TargetMesh   (size_t index) const;
          collada::Mesh& TargetMesh   (size_t index);

  protected:
    Morph  (MorphLibrary& library, const char* id);
    ~Morph ();
    
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контроллер
///////////////////////////////////////////////////////////////////////////////////////////////////
class Controller: public Entity
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Библиотека
///////////////////////////////////////////////////////////////////////////////////////////////////
    ControllerLibrary& Library () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип контроллера
///////////////////////////////////////////////////////////////////////////////////////////////////
    collada::ControllerType Type () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Морф / скин в зависимости от типа контроллера
///////////////////////////////////////////////////////////////////////////////////////////////////
    const collada::Morph& Morph () const;
          collada::Morph& Morph ();
    const collada::Skin&  Skin  () const;
          collada::Skin&  Skin  ();
    
  protected:
    Controller  (collada::ControllerType type, collada::Morph& morph, collada::Skin&  skin, ControllerLibrary& library, const char* id);
    ~Controller ();
    
  private:
    struct Impl;
    Impl* impl;
};

}

}

#endif
