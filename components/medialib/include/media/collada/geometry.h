#ifndef MEDIALIB_COLLADA_GEOMETRY_HEADER
#define MEDIALIB_COLLADA_GEOMETRY_HEADER

#include <media/collada/material.h>
#include <math/mathlib.h>

namespace medialib
{

namespace collada
{

//forward declarations
class Mesh;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ѕиблиотека мешей
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef ILibrary<Mesh> MeshLibrary;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ѕазовые атрибуты вершины
///////////////////////////////////////////////////////////////////////////////////////////////////
struct Vertex
{
  math::vec3f coord;    //координаты вершины
  math::vec3f normal;   //нормаль в вершине
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///јтрибуты текстурировани€ вершины
///////////////////////////////////////////////////////////////////////////////////////////////////
struct TexVertex
{
  math::vec3f coord;    //текстурные координаты вершины
  math::vec3f tangent;  //касательна€ в texture space
  math::vec3f binormal; //бинормаль в texture space
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///“ип примитивов
///////////////////////////////////////////////////////////////////////////////////////////////////
enum PrimitiveType
{
  PrimitiveType_LineList,      //список отрезков
  PrimitiveType_LineStrip,     //цепочка отрезков
  PrimitiveType_TriangleList,  //список треугольников
  PrimitiveType_TriangleStrip, //цепочка треугольников
  PrimitiveType_TriangleFan    //вейер треугольников
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///ѕоверхность
///////////////////////////////////////////////////////////////////////////////////////////////////
class Surface
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///ћатериал поверхности
///////////////////////////////////////////////////////////////////////////////////////////////////
          collada::Material& Material ();
    const collada::Material& Material () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///“ип примитивов
///////////////////////////////////////////////////////////////////////////////////////////////////
    collada::PrimitiveType PrimitiveType () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
/// оличество вершин и индексов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t VerticesCount () const;
    size_t IndicesCount  () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///–абота с вершинами
///////////////////////////////////////////////////////////////////////////////////////////////////
          Vertex* Vertices ();
    const Vertex* Vertices () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///–абота с вершинными цветами
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t      ColorChannelsCount     () const;                 //количество каналов вершинных цветов
    size_t      CreateColorChannel     (const char* name = 0);   //создание канала вершинных цветов
    void        RemoveColorChannel     (size_t channel);         //удаление канала вершинных цветов
    void        RemoveAllColorChannels ();                       //удаление всех каналов вершинных цветов
    const char* ColorChannelName       (size_t channel) const;   //им€ канала вершинных цветов    
    bool        HasColorChannel        (size_t channel) const;   //проверка наличи€ канала вершинных цветов    
    int         FindColorChannel       (const char* name) const; //возвращает индекс канала вершинных цветов или -1 в случае неудачи

          math::vec3f* Colors (size_t channel);
    const math::vec3f* Colors (size_t channel) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///–абота с текстурированными вершинами
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t      TextureChannelsCount     () const;                 //количество каналов текстурировани€
    size_t      CreateTextureChannel     (const char* name = 0);   //создание канала текстурировани€
    void        RemoveTextureChannel     (size_t channel);         //удаление канала текстурировани€
    void        RemoveAllTextureChannels ();                       //удаление всех канало текстурировани€
    const char* TextureChannelName       (size_t channel) const;   //им€ текстурированного канала    
    bool        HasTextureChannel        (size_t channel) const;   //проверка наличи€ канала текстурировани€
    int         FindTextureChannel       (const char* name) const; //возвращает индекс канала текстурировани€ или -1 в случае неудачи

      //текстурированные вершины
    const TexVertex* TextureVertices (size_t channel) const;    
          TexVertex* TextureVertices (size_t channel);

///////////////////////////////////////////////////////////////////////////////////////////////////
///»ндексы примитивов
///////////////////////////////////////////////////////////////////////////////////////////////////
          size_t* Indices ();
    const size_t* Indices () const;

  protected:
    Surface  (collada::Material& material, collada::PrimitiveType type, size_t verts_count, size_t indices_count);
    ~Surface ();

  private:
    Surface (const Surface&); //no impl
    Surface& operator = (const Surface&); //no impl

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
/// оллекци€ поверхностей
///////////////////////////////////////////////////////////////////////////////////////////////////
template <> class ICollection<Surface>: public IItemCollection<Surface>
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///—оздание
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual Surface& Create (Material& material, PrimitiveType type, size_t verts_count, size_t indices_count) = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///ћеш
///////////////////////////////////////////////////////////////////////////////////////////////////
class Mesh: public Entity
{
  public:
    typedef ICollection<Surface> SurfaceList;

///////////////////////////////////////////////////////////////////////////////////////////////////
///–абота с поверхност€ми
///////////////////////////////////////////////////////////////////////////////////////////////////
          SurfaceList& Surfaces ();
    const SurfaceList& Surfaces () const;

  protected:
    Mesh (MeshLibrary& library, const char* id);

  private:
    struct Impl;
    Impl* impl;
};

}

}

#endif
