#ifndef MEDIALIB_COLLADA_SCENE_HEADER
#define MEDIALIB_COLLADA_SCENE_HEADER

#include <media/collada/geometry.h>

namespace medialib
{

namespace collada
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип источника света
///////////////////////////////////////////////////////////////////////////////////////////////////
enum LightType
{
  LightType_Ambient, //рассеянное освещение
  LightType_Point,   //точечный источник света
  LightType_Spot,    //направленный конусоидальный источник света
  LightType_Direct,  //направленный цилиндрический источник света
  
  LightType_Default = LightType_Point
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры источника света
///////////////////////////////////////////////////////////////////////////////////////////////////
enum LightParam
{
  LightParam_AttenuationConstant,  //постоянный коэффициент затухания на расстоянии
  LightParam_AttenuationLinear,    //линейный коэффициент затухания на расстоянии
  LightParam_AttenuationQuadratic, //квадратичный коэффициент затухания на расстоянии
  LightParam_FalloffAngle,         //угол затухания
  LightParam_FalloffExponent,      //экспоненциальный коэффициент затухания по углу

  LightParam_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип камеры
///////////////////////////////////////////////////////////////////////////////////////////////////
enum CameraType
{
  CameraType_Perspective, //перспективная камера
  CameraType_Orthographic //ортографическая камера
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры камеры
///////////////////////////////////////////////////////////////////////////////////////////////////
enum CameraParam
{
  CameraParam_ZNear,       //расстояниие до ближней плоскости отсечения
  CameraParam_ZFar,        //расстояниие до дальней плоскости отсечения
  CameraParam_AspectRatio, //коэффициент масштабирования по осям
  CameraParam_XFov,        //угол обзора по X
  CameraParam_YFov,        //угол обзора по Y
  CameraParam_XMagnitude,  //??
  CameraParam_YMagnitude,  //??  
  
  CameraParam_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Источник света
///////////////////////////////////////////////////////////////////////////////////////////////////
class Light: public Entity
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип источника
///////////////////////////////////////////////////////////////////////////////////////////////////
    LightType Type    () const;
    void      SetType (LightType type);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Цвет источника
///////////////////////////////////////////////////////////////////////////////////////////////////
    const math::vec3f& Color    () const;
    void               SetColor (const math::vec3f& color);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры источника
///////////////////////////////////////////////////////////////////////////////////////////////////
    void  SetParam (LightParam param, float value);
    float Param    (LightParam param) const;

  protected:
    Light  (ModelImpl*, const char* id);
    ~Light ();
    
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Камера
///////////////////////////////////////////////////////////////////////////////////////////////////
class Camera: public Entity
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип камеры
///////////////////////////////////////////////////////////////////////////////////////////////////
    CameraType Type    () const;
    void       SetType (CameraType type);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры камеры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void  SetParam (CameraParam param, float value);
    float Param    (CameraParam param) const;

   protected:
     Camera  (ModelImpl*, const char* id);
     ~Camera ();

   private:
     struct Impl;
     Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединённые материалы
///////////////////////////////////////////////////////////////////////////////////////////////////
class MaterialBinds
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск материала
///////////////////////////////////////////////////////////////////////////////////////////////////
    const collada::Material* FindMaterial (const char* symbol) const; //no throw
          collada::Material* FindMaterial (const char* symbol);       //no throw
    const collada::Material* FindMaterial (const Surface&) const;     //no throw
          collada::Material* FindMaterial (const Surface&);           //no throw

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка материала / удаление материала
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetMaterial    (const char* symbol, Material&);
    void RemoveMaterial (const char* symbol);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение имени канала текстурных координат поверхности
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* TexcoordChannelName       (const char* material, const char* texchannel) const; //no throw
    void        SetTexcoordChannelName    (const char* material, const char* texchannel, const char* surface_channel);
    void        RemoveTexcoordChannelName (const char* material, const char* texchannel);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение номера канала текстурных координат поверхности. -1 в случае неудачи
///////////////////////////////////////////////////////////////////////////////////////////////////
    int FindTexcoordChannel (const Surface&, const Texture&) const; //nothrow

///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Clear ();

  protected:
    MaterialBinds  (Entity&);
    ~MaterialBinds ();
  
  private:
    MaterialBinds (const MaterialBinds&); //no impl
    MaterialBinds& operator = (const MaterialBinds&); //no impl
  
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Инстанцированный меш
///////////////////////////////////////////////////////////////////////////////////////////////////
class InstanceMesh
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Меш
///////////////////////////////////////////////////////////////////////////////////////////////////
          collada::Mesh& Mesh ();
    const collada::Mesh& Mesh () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединённые материалы
///////////////////////////////////////////////////////////////////////////////////////////////////
          collada::MaterialBinds& MaterialBinds ();
    const collada::MaterialBinds& MaterialBinds () const;

  protected:
    InstanceMesh  (collada::Mesh&);
    ~InstanceMesh ();
    
  private:
    InstanceMesh (const InstanceMesh&); //no impl
    InstanceMesh& operator = (const InstanceMesh&); //no impl
  
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Специализация коллекции инстанцированных мешей
///////////////////////////////////////////////////////////////////////////////////////////////////
template <> class ICollection<InstanceMesh>: public IItemCollection<InstanceMesh>
{
  public:
    virtual InstanceMesh& Create (Mesh&) = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Узел сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class Node: public Entity
{
  public:
    typedef ICollection<Node>         NodeList;
    typedef ICollection<Camera>       CameraList;
    typedef ICollection<Light>        LightList;
    typedef ICollection<InstanceMesh> MeshList;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Идентификатор узла в пределах родительского узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* SubId    () const;
    void        SetSubId (const char*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Name    () const;
    void        SetName (const char*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Преобразование узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    const math::mat4f& Transform    () const;
    void               SetTransform (const math::mat4f&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Коллекции узла
///////////////////////////////////////////////////////////////////////////////////////////////////
          NodeList&   Nodes   ();       //узлы-потомки
    const NodeList&   Nodes   () const;
          LightList&  Lights  ();       //источники света
    const LightList&  Lights  () const;
          CameraList& Cameras ();       //камеры
    const CameraList& Cameras () const;
          MeshList&   Meshes  ();       //меши
    const MeshList&   Meshes  () const;    

  protected:
    Node  (ModelImpl*, const char* id);
    ~Node ();

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сцена
///////////////////////////////////////////////////////////////////////////////////////////////////
class Scene: public Node
{
  protected:
    Scene (ModelImpl* owner, const char* id) : Node (owner, id) {}
};

}

}

#endif
