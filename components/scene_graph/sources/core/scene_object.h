#ifndef SCENE_GRAPH_SCENE_OBJECT_HEADER
#define SCENE_GRAPH_SCENE_OBJECT_HEADER

#include <sg/entity.h>

namespace scene_graph
{

//forward declarations
class SceneSpace;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Объект сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class SceneObject: public xtl::instance_counter<SceneObject>
{
  friend class SceneSpace;
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SceneObject  (scene_graph::Entity&);
    ~SceneObject ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с цепочкой объектов
///////////////////////////////////////////////////////////////////////////////////////////////////
          SceneObject* NextObject ()       { return next_object; }
    const SceneObject* NextObject () const { return next_object; }
          SceneObject* PrevObject ()       { return prev_object; }
    const SceneObject* PrevObject () const { return prev_object; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Возвращение entity
///////////////////////////////////////////////////////////////////////////////////////////////////
          scene_graph::Entity& Entity ()       { return entity; }
    const scene_graph::Entity& Entity () const { return entity; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Связывание объекта с пространством
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BindToSpace (SceneSpace*);

          SceneSpace* Space ()       { return space; }
    const SceneSpace* Space () const { return space; }

  private:
    SceneObject (const SceneObject&); //no impl
    SceneObject& operator = (const SceneObject&); //no impl

  private:
    scene_graph::Entity& entity;                      //entity, связанный с объектом
    SceneSpace*          space;                       //пространство, которому принадлжит объект
    SceneObject          *prev_object, *next_object;  //цепочка объектов пространства
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Пространство объектов
///////////////////////////////////////////////////////////////////////////////////////////////////
class SceneSpace: public xtl::instance_counter<SceneSpace>
{
  friend class SceneObject;
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////  
    SceneSpace  ();
    ~SceneSpace ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество объектов в сцене
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t ObjectsCount () const { return objects_count; }
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Первый объект в сцене
///////////////////////////////////////////////////////////////////////////////////////////////////
          SceneObject* FirstObject ()       { return first_object; }
    const SceneObject* FirstObject () const { return first_object; }

  private:
    SceneSpace (const SceneSpace&); //no impl
    SceneSpace& operator = (const SceneSpace&); //no impl

  private:
    SceneObject* first_object;  //первый объект в цепочке объектов сцены
    size_t       objects_count; //количество объектов в сцене
};

}

#endif
