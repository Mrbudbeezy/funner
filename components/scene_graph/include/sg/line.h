#ifndef SCENE_GRAPH_LINE_HEADER
#define SCENE_GRAPH_LINE_HEADER

#include <stl/auto_ptr.h>
#include <sg/visual_model.h>

namespace scene_graph
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об обновлении линий в модели
///////////////////////////////////////////////////////////////////////////////////////////////////
enum LineModelEvent
{
  LineModelEvent_AfterLineDescsUpdate,      //срабатывает после изменения данных линий
  LineModelEvent_AfterCreationParamsUpdate, //срабатывает после изменения Usage/Batch параметров

  LineModelEvent_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим использования линий
///////////////////////////////////////////////////////////////////////////////////////////////////
enum LineUsage
{
  LineUsage_Static,   //не обновляемая модель
  LineUsage_Dynamic,  //обновляемая модель
  LineUsage_Stream,   //часто обновляемая модель (каждый кадр)
  LineUsage_Batching, //пакетирование
  
  LineUsage_Default = LineUsage_Batching
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Точка линии
///////////////////////////////////////////////////////////////////////////////////////////////////
struct LinePoint
{
  math::vec3f position;   //положение точки в пространстве
  math::vec4f color;      //цвет точки
  math::vec2f tex_offset; //смещение точки в текстуре [0;1]
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Линия
///////////////////////////////////////////////////////////////////////////////////////////////////
struct LineDesc
{
  LinePoint point [2]; //концы линии
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Модель, состоящая из простейших примитивов
///////////////////////////////////////////////////////////////////////////////////////////////////
class LineModel: public VisualModel
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество линий / размер буфера линий / получение массива линий
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t          LineDescsCount    () const;
    size_t          LineDescsCapacity () const;
    const LineDesc* LineDescs         () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Материал
///////////////////////////////////////////////////////////////////////////////////////////////////
    void        SetMaterial  (const char* material);
    const char* Material     () const;
    size_t      MaterialHash () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Пакет
///////////////////////////////////////////////////////////////////////////////////////////////////
    void        SetBatch  (const char* name);
    const char* Batch     () const;
    size_t      BatchHash () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим использования линий
///////////////////////////////////////////////////////////////////////////////////////////////////
    void      SetUsage (LineUsage usage);
    LineUsage Usage    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подписка на события модели
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (LineModel& sender, LineModelEvent event_id)> EventHandler;

    xtl::connection RegisterEventHandler (LineModelEvent event_id, const EventHandler& event_handler);
    
    using VisualModel::RegisterEventHandler;

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    LineModel  ();
    ~LineModel ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Динамическая диспетчеризация
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AcceptCore (Visitor&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об изменении данных линий
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateLineDescsNotify ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Связывание свойств узла с методами узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BindProperties (common::PropertyBindingMap& bindings);    

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация получения количества линий и массива линий
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual size_t          LineDescsCountCore    () = 0;
    virtual size_t          LineDescsCapacityCore () = 0;
    virtual const LineDesc* LineDescsCore         () = 0;
    
  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Линия
///////////////////////////////////////////////////////////////////////////////////////////////////
class Line: public LineModel
{
  public:
    typedef xtl::com_ptr<Line>       Pointer;
    typedef xtl::com_ptr<const Line> ConstPointer;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание линий
///////////////////////////////////////////////////////////////////////////////////////////////////
    static Pointer Create ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Цвет линии
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetColor (size_t point_index, const math::vec4f& color);
    void               SetColor (size_t point_index, float red, float green, float blue);
    void               SetColor (size_t point_index, float red, float green, float blue, float alpha);
    void               SetAlpha (size_t point_index, float alpha);
    const math::vec4f& Color    (size_t point_index) const;
    float              Alpha    (size_t point_index) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текстурные координаты
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetTexOffset (size_t point_index, const math::vec2f&);
    const math::vec2f& TexOffset    (size_t point_index) const;

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Line  ();
    ~Line ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Динамическая диспетчеризация
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AcceptCore (Visitor&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Связывание свойств узла с методами узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BindProperties (common::PropertyBindingMap& bindings);    
    
  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация получения количества линий и массива линий
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t          LineDescsCountCore    ();
    size_t          LineDescsCapacityCore ();
    const LineDesc* LineDescsCore         ();        

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Список линий
///////////////////////////////////////////////////////////////////////////////////////////////////
class LineList: public LineModel
{
  public:
    typedef xtl::com_ptr<LineList>       Pointer;
    typedef xtl::com_ptr<const LineList> ConstPointer;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание списка линий
///////////////////////////////////////////////////////////////////////////////////////////////////
    static Pointer Create ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Размер массива линий
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t LinesCount () const;    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Изменение размера списка линий / резервирование места для хранения линий
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Resize  (size_t count);
    void Reserve (size_t count);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Массив линий
///////////////////////////////////////////////////////////////////////////////////////////////////
    const LineDesc* Lines () const;
          LineDesc* Lines ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление линий в массив
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Insert (const LineDesc& Line);
    void Insert (size_t Lines_count, const LineDesc* Lines);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка списка линий
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RemoveAll ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об обновлении данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Invalidate ();

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    LineList  ();
    ~LineList ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Динамическая диспетчеризация
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AcceptCore (Visitor&);
    
  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация получения количества линий и массива линий
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t          LineDescsCountCore    ();
    size_t          LineDescsCapacityCore ();
    const LineDesc* LineDescsCore         ();

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

}

#endif
