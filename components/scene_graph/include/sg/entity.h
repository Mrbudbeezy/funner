#ifndef SCENE_GRAPH_ENTITY_HEADER
#define SCENE_GRAPH_ENTITY_HEADER

#include <sg/node.h>
#include <bv/axis_aligned_box.h>

namespace scene_graph
{

//forward declaration
class NodeArray;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Объект, имеющий геометрическую интерпретацию в сцене
///////////////////////////////////////////////////////////////////////////////////////////////////
class Entity: public Node
{
  public:
    typedef xtl::com_ptr<Entity>       Pointer;
    typedef xtl::com_ptr<const Entity> ConstPointer;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Цвет проволочного представления объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetWireColor (const math::vec3f& color);
    void               SetWireColor (float red, float green, float blue);
    const math::vec3f& WireColor    () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Видимость объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetVisible (bool state);
    bool IsVisible  () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с ограничивающим объёмом
///Примечание: ограничивающие объёмы узлов-потомков не влияют на ограничивающий объём родительского узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    const bound_volumes::aaboxf& BoundBox          () const; //ограничивающий объём узла в локальной системе координат
    const bound_volumes::aaboxf& WorldBoundBox     () const; //ограничивающий объём узла в мировой системе координат
    size_t                       BoundBoxHash      () const;
    size_t                       WorldBoundBoxHash () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение о обновлении локального ограничивающего объёма
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateBoundsNotify ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка бесконечных ограничивающий объёмов
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsInfiniteBounds () const; //проверка: являются ли ограничивающие объёмы узла бесконечными

///////////////////////////////////////////////////////////////////////////////////////////////////
///Расчёт кумулятивных ограничивающих объёмов
///////////////////////////////////////////////////////////////////////////////////////////////////
    bound_volumes::aaboxf ChildrenBoundBox      () const; //ограничивающий объём потомков в локальной системе координат узла
    bound_volumes::aaboxf FullBoundBox          () const; //полный ограничивающий объём узла с потомками в локальной системе координат узла
    bound_volumes::aaboxf WorldChildrenBoundBox () const; //ограничивающий объём потомков в мировой системе координат
    bound_volumes::aaboxf WorldFullBoundBox     () const; //полный ограничивающий объём узла с потомками в мировой системе координат

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение пересечений
///////////////////////////////////////////////////////////////////////////////////////////////////
    void      GetIntersections (NodeArray&) const;
    NodeArray GetIntersections () const;

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Entity  ();
    ~Entity ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка ограничивающего объёма
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetBoundBox (const bound_volumes::aaboxf&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка бесконечного ограничивающего объёма
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetInfiniteBounds ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление локального ограничивающего объёма
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void UpdateBoundsCore ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Метод, вызываемый при посещении данного узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AcceptCore (Visitor&);    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещения
///////////////////////////////////////////////////////////////////////////////////////////////////    
    void AfterUpdateWorldTransformEvent ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Связывание свойств узла с методами узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BindProperties (common::PropertyBindingMap& bindings);

  private:
    void AfterSceneAttachEvent ();
    void BeforeSceneDetachEvent ();

  private:
    using Node::Create;

  private:
    void UpdateWorldBoundsNotify ();
    void UpdateWorldBounds () const;

  private:
    struct Impl;
    Impl* impl;
};

}

#endif
