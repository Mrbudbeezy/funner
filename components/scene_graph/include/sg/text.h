#ifndef SCENE_GRAPH_TEXT_HEADER
#define SCENE_GRAPH_TEXT_HEADER

#include <stl/auto_ptr.h>
#include <sg/visual_model.h>

namespace media
{

//forward declarations
class  Font;
class  FontLibrary;
struct FontCreationParams;

}

namespace scene_graph
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об обновлении текстовой модели
///////////////////////////////////////////////////////////////////////////////////////////////////
enum TextModelEvent
{
  TextModelEvent_AfterCharDescsUpdate, //срабатывает после изменения данных символов
  TextModelEvent_AfterFontsUpdate,     //срабатывает после обновления шрифтов

  TextModelEvent_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор символа
///////////////////////////////////////////////////////////////////////////////////////////////////
struct CharDesc
{
  unsigned int code;      //код символа
  media::Font* font;      //шрифт (может быть нулевым)
  math::vec3f  position;  //позиция символа
  math::vec2f  size;      //размер символа
  math::vec4f  color;     //цвет символа
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Разрешение, используемое для создания шрифтов. Эта структура может быть подключена к SceneContext
///////////////////////////////////////////////////////////////////////////////////////////////////
struct FontDpi
{
  unsigned int horizontal_dpi;  //горизонтальная плотность точек целевого устройства отображения
  unsigned int vertical_dpi;    //вертикальная плотность точек целевого устройства отображения
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текстовая модель
///////////////////////////////////////////////////////////////////////////////////////////////////
class TextModel: public VisualModel
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Материал
///////////////////////////////////////////////////////////////////////////////////////////////////
    void        SetMaterial  (const char* material);
    const char* Material     () const;
    size_t      MaterialHash () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Семантика текстуры-маски
///////////////////////////////////////////////////////////////////////////////////////////////////
    void        SetTextureSemantic  (const char* semantic);
    const char* TextureSemantic     () const;
    size_t      TextureSemanticHash () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение символов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t          CharsCount () const;
    const CharDesc* Chars      () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Резервирование символов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t CharsCapacity () const;
    void   ReserveChars  (size_t count);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подписка на события модели
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (TextModel& sender, TextModelEvent event_id)> EventHandler;

    xtl::connection RegisterEventHandler (TextModelEvent event_id, const EventHandler& event_handler);
    
    using VisualModel::RegisterEventHandler;

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextModel  (const media::FontLibrary& font_library);
    ~TextModel ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Библиотека шрифтов
///////////////////////////////////////////////////////////////////////////////////////////////////
    const media::FontLibrary& FontLibrary () const;
          media::FontLibrary& FontLibrary ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Изменение символов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void      ResizeChars       (size_t count);
    CharDesc* CharsForUpdate    ();
    void      UpdateCharsNotify ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Динамическая диспетчеризация
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AcceptCore (Visitor&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перестроение таблицы символов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RebuildChars ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение о необходимости перестроения шрифтов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateFontsNotify ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Перестроение таблицы символов
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void RebuildCharsCore () = 0;
    
  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим выравнивания
///////////////////////////////////////////////////////////////////////////////////////////////////
enum TextLineAlignment
{
  TextLineAlignment_Center = 0,   //по центру
  TextLineAlignment_Left = 1,     //по левому краю
  TextLineAlignment_Right = 2,    //по правому краю
  TextLineAlignment_Top = 1,      //по верхнему краю
  TextLineAlignment_Bottom = 2,   //по нижнему краю
  TextLineAlignment_BaseLine = 3, //по базовой линии

  TextLineAlignment_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Линия текста
///////////////////////////////////////////////////////////////////////////////////////////////////
class TextLine: public TextModel
{
  public:
    typedef xtl::com_ptr<TextLine>       Pointer;
    typedef xtl::com_ptr<const TextLine> ConstPointer;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание текстовой линии
///////////////////////////////////////////////////////////////////////////////////////////////////
    static Pointer Create (const media::FontLibrary&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Цвет текста
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetColor (const math::vec4f& color);
    void               SetColor (float red, float green, float blue);
    void               SetColor (float red, float green, float blue, float alpha);
    const math::vec4f& Color    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Цвет определенных символов текста
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetCharsColorFactors (size_t first, size_t count, const math::vec4f& color);
    const math::vec4f& CharColorFactor      (size_t index) const;
    void               CharsColorFactors    (size_t first, size_t count, math::vec4f* colors) const;
    const math::vec4f& CharColor            (size_t index) const;
    void               CharsColors          (size_t first, size_t count, math::vec4f* colors) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка/получение текста
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                SetTextUtf8   (const char* text_utf8);
    void                SetTextUtf32  (const unsigned int* text_utf32, size_t length);
    const char*         TextUtf8      () const;
    const unsigned int* TextUtf32     () const;
    size_t              TextLength    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Хэш текста
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t TextUtf8Hash  () const;
    size_t TextUtf32Hash () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка/получение шрифта
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                             SetFont               (const char* font_name);
    void                             SetFontCreationParams (const media::FontCreationParams&);
    const char*                      Font                  () const;
    const media::FontCreationParams& FontCreationParams    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка/получение межбуквенного интервала
///////////////////////////////////////////////////////////////////////////////////////////////////
    void  SetSpacingMultiplier (float spacing_multiplier);
    float SpacingMultiplier    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Выравнивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    void              SetAlignment           (TextLineAlignment horizontal, TextLineAlignment vertical);
    void              SetHorizontalAlignment (TextLineAlignment alignment);
    void              SetVerticalAlignment   (TextLineAlignment alignment);
    TextLineAlignment VerticalAlignment      () const;
    TextLineAlignment HorizontalAlignment    () const;

    using TextModel::RebuildChars;

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    TextLine  (const media::FontLibrary&);
    ~TextLine ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Динамическая диспетчеризация
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AcceptCore (Visitor&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Связывание свойств узла с методами узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BindProperties (common::PropertyBindingMap& bindings);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Перестроение таблицы символов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RebuildCharsCore ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рассчёт ограничивающего объёма
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateBoundsCore ();

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

}

#endif
