#ifndef SCENE_GRAPH_SCENE_MANAGER_HEADER
#define SCENE_GRAPH_SCENE_MANAGER_HEADER

#include <xtl/functional_fwd>

#include <sg/node.h>

namespace common
{

//forward declarations
class ParseNode;
class XmlWriter;

}

namespace media
{

namespace rms
{

//forward declaration
class Group;

}

}

namespace scene_graph
{

typedef media::rms::Group ResourceGroup;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контекст сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class SceneContext
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////  
    SceneContext  ();
    SceneContext  (const SceneContext&);
    ~SceneContext ();

    SceneContext& operator = (const SceneContext&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Клонирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    SceneContext Clone () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Свойства
///////////////////////////////////////////////////////////////////////////////////////////////////
    common::PropertyMap Properties    () const;
    void                SetProperties (const common::PropertyMap&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединенные данные
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> void     Attach     (T& value);
    template <class T> void     Detach     ();
    template <class T> T&       Attachment ();
    template <class T> const T& Attachment () const;    
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединенные именованные данные
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> void     Attach         (const char* name, T& value);
    template <class T> void     Detach         (const char* name);
    template <class T> T&       Attachment     (const char* name);
    template <class T> T*       FindAttachment (const char* name);
    template <class T> const T& Attachment     (const char* name) const;
    template <class T> const T* FindAttachment (const char* name) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработчик ошибок создания сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<bool (const char* error_message)> ExceptionHandler; //return true if exceptions has processed

    xtl::connection RegisterExceptionHandler (const char* error_wc_mask, const ExceptionHandler& handler);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (SceneContext&);
    
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (SceneContext&, SceneContext&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class SceneManager
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    SceneManager  ();
    SceneManager  (const SceneManager&);
    ~SceneManager ();

    SceneManager& operator = (const SceneManager&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadScene   (const char* file_name, const char* name_prefix = "");
    void UnloadScene (const char* file_name);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка наличия сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool HasScene (const char* scene_name) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание контекста сцены
///////////////////////////////////////////////////////////////////////////////////////////////////    
    typedef xtl::function<void (SceneContext&)> SceneContextCreator;
    
    SceneContext    CreateSceneContext          ();
    xtl::connection RegisterSceneContextCreator (const SceneContextCreator&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    Node::Pointer CreateScene (const char* scene_name); //ResourceList in each Node as controller
    Node::Pointer CreateScene (const char* scene_name, SceneContext& context); //ResourceList in each Node as controller

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (SceneManager&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (SceneManager&, SceneManager&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Фабрика сцен
///////////////////////////////////////////////////////////////////////////////////////////////////
class ISceneFactory
{
  public:
    virtual ~ISceneFactory () {}
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение информации о сцене
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual bool GetSceneInfo (const char* name, ResourceGroup* resources) = 0; //if resources != 0 && scene present -> fill resources needed for scene
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void CreateScene (const char* name, Node& parent, SceneContext& scene_context) = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер сериализации сцен
///////////////////////////////////////////////////////////////////////////////////////////////////
class SceneSerializationManager
{
  public:
    typedef xtl::function<ISceneFactory* (const char* file_name)>          SceneLoader;
    typedef xtl::function<void (const char* file_name, Node& node)>        SceneSaver;
    typedef xtl::function<ISceneFactory* (const common::ParseNode&)>       XmlSceneLoader;
    typedef xtl::function<bool (common::XmlWriter& xml_write, Node& node)> XmlSceneSaver;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация сериализаторов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RegisterLoader          (const char* file_type, const SceneLoader& loader);
    void RegisterSaver           (const char* file_type, const SceneSaver& saver);
    void RegisterXmlLoader       (const char* file_type, const char* node_type, const XmlSceneLoader& loader);
    void RegisterXmlSaver        (const char* file_type, const char* saver_name, const XmlSceneSaver& saver);
    void UnregisterLoader        (const char* file_type);
    void UnregisterSaver         (const char* file_type);
    void UnregisterXmlLoader     (const char* file_type, const char* node_type);
    void UnregisterXmlSaver      (const char* file_type, const char* saver_name);
    void UnregisterAllLoaders    ();
    void UnregisterAllSavers     ();
    void UnregisterAllXmlLoaders (const char* file_type);
    void UnregisterAllXmlLoaders ();
    void UnregisterAllXmlSavers  (const char* file_type);
    void UnregisterAllXmlSavers  ();
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Слушатель событий загрузки XML-сцены
///  используется в качестве именованного присоединенного объекта IXmlSceneLoadListener* к SceneContext)
///////////////////////////////////////////////////////////////////////////////////////////////////
class IXmlSceneLoadListener
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обозначение границ сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void OnBeginScene (const char* file_name, const char* name_prefix) {}
    virtual void OnEndScene   (const char* file_name, const char* name_prefix) {}
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обозначение границ узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void OnBeginSceneNode (const common::ParseNode& parse_node, Node& parent, SceneContext& scene_context) {}
    virtual void OnEndSceneNode   (const common::ParseNode& parse_node, Node& parent, SceneContext& scene_context) {}
    
  protected:
    virtual ~IXmlSceneLoadListener () {}
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация слушателя событий загрузки XML-сцены в контексте сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
void attach (SceneContext& scene_context, const char* xml_file_type, IXmlSceneLoadListener& listener);
void detach (SceneContext& scene_context, const char* xml_file_type);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение слушателя событий загрузки XML-сцены в контексте сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
IXmlSceneLoadListener* get_xml_scene_load_listener (SceneContext& scene_context, const char* xml_file_type);

}

#endif
