#ifndef SCENE_GRAPH_SCENE_MANAGER_HEADER
#define SCENE_GRAPH_SCENE_MANAGER_HEADER

#include <xtl/functional_fwd>

#include <sg/node.h>

namespace media
{

namespace rms
{

//forward declaration
class Group;

}

}

namespace scene_graph
{

typedef media::rms::Group ResourceGroup;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контекст сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class SceneContext
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////  
    SceneContext  ();
    SceneContext  (const SceneContext&);
    ~SceneContext ();

    SceneContext& operator = (const SceneContext&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Клонирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    SceneContext Clone () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Свойства
///////////////////////////////////////////////////////////////////////////////////////////////////
    common::PropertyMap Properties    () const;
    void                SetProperties (const common::PropertyMap&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединенные данные
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> void     Attach     (T& value);
    template <class T> void     Detach     ();
    template <class T> T&       Attachment ();
    template <class T> const T& Attachment () const;    
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединенные именованные данные
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> void     Attach         (const char* name, T& value);
    template <class T> void     Detach         (const char* name);
    template <class T> T&       Attachment     (const char* name);
    template <class T> T*       FindAttachment (const char* name);
    template <class T> const T& Attachment     (const char* name) const;
    template <class T> const T* FindAttachment (const char* name) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработчик ошибок создания сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<bool (const char* error_message)> ExceptionHandler; //return true if exceptions has processed

    xtl::connection RegisterExceptionHandler (const char* error_wc_mask, const ExceptionHandler& handler);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (SceneContext&);
    
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (SceneContext&, SceneContext&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class SceneManager
{
  public:
    typedef xtl::function<void (const char* message)> LogHandler;  
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    SceneManager  ();
    SceneManager  (const SceneManager&);
    ~SceneManager ();

    SceneManager& operator = (const SceneManager&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadScene   (const char* file_name, const char* name_prefix = "", const LogHandler& = LogHandler ());
    void UnloadScene (const char* file_name);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка наличия сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool HasScene (const char* scene_name) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание контекста сцены
///////////////////////////////////////////////////////////////////////////////////////////////////    
    typedef xtl::function<void (SceneContext&)> SceneContextCreator;
    
    SceneContext    CreateSceneContext          ();
    xtl::connection RegisterSceneContextCreator (const SceneContextCreator&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    Node::Pointer CreateScene (const char* scene_name); //ResourceList in each Node as controller
    Node::Pointer CreateScene (const char* scene_name, SceneContext& context); //ResourceList in each Node as controller

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (SceneManager&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (SceneManager&, SceneManager&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Фабрика сцен
///////////////////////////////////////////////////////////////////////////////////////////////////
class ISceneFactory
{
  public:
    virtual ~ISceneFactory () {}
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение информации о сцене
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual bool GetSceneInfo (const char* name, ResourceGroup* resources) = 0; //if resources != 0 && scene present -> fill resources needed for scene
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void CreateScene (const char* name, Node& parent, SceneContext& scene_context) = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер сериализации сцен
///////////////////////////////////////////////////////////////////////////////////////////////////
class SceneSerializationManager
{
  public:
    typedef xtl::function<ISceneFactory* (const char* file_name)>   SceneLoader;
    typedef xtl::function<void (const char* file_name, Node& node)> SceneSaver;
    typedef SceneManager::LogHandler                                LogHandler;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация сериализаторов
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void RegisterLoader       (const char* file_type, const SceneLoader& loader, const LogHandler& = LogHandler ());
    static void RegisterSaver        (const char* file_type, const SceneSaver& saver);
    static void UnregisterLoader     (const char* file_type);
    static void UnregisterSaver      (const char* file_type);
    static void UnregisterAllLoaders ();
    static void UnregisterAllSavers  ();
};

}

#endif
