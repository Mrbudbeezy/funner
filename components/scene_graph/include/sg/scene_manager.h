#ifndef SCENE_GRAPH_SCENE_MANAGER_HEADER
#define SCENE_GRAPH_SCENE_MANAGER_HEADER

#include <typeinfo>

#include <xtl/functional_fwd>

#include <sg/node.h>

namespace media
{

namespace rms
{

//forward declaration
class Group;

}

}

namespace scene_graph
{

namespace detail
{

//forward declaration
class ISceneAttachment;

}

typedef media::rms::Group ResourceGroup;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контекст сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class SceneContext
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////  
    SceneContext  ();
    SceneContext  (const SceneContext&);
    ~SceneContext ();

    SceneContext& operator = (const SceneContext&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Свойства
///////////////////////////////////////////////////////////////////////////////////////////////////
    common::PropertyMap Properties    () const;
    void                SetProperties (const common::PropertyMap&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединенные данные
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> void     Attach         (T& value);
    template <class T> void     Detach         ();
    template <class T> T&       Attachment     ();
    template <class T> const T& Attachment     () const;
    template <class T> T*       FindAttachment ();
    template <class T> const T* FindAttachment () const;        
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединенные именованные данные
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> void     Attach         (const char* name, T& value);
    template <class T> void     Detach         (const char* name);
    template <class T> T&       Attachment     (const char* name);
    template <class T> T*       FindAttachment (const char* name);
    template <class T> const T& Attachment     (const char* name) const;
    template <class T> const T* FindAttachment (const char* name) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Отсоединение всех данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> void DetachAll ();
                       void DetachAll ();
                       
///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Clear ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработчик ошибок создания сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<bool (const char* error_message)> ExceptionHandler; //returns true if exceptions has processed

    xtl::connection RegisterErrorHandler (const char* error_wc_mask, const ExceptionHandler& handler);
    bool            FilterError          (const char* error_message) const; //returns true if exception is filtered
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Поток протоколирования
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (const char* message)> LogFunction;
    
    void               SetLogHandler (const LogFunction& handler);
    const LogFunction& LogHandler    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (SceneContext&);

  private:
    void                      RaiseAttachmentError (const char*, const std::type_info&);
    void                      RaiseAttachmentError (const std::type_info&);
    void                      AttachCore           (detail::ISceneAttachment*);
    void                      AttachCore           (const char*, detail::ISceneAttachment*);
    void                      DetachCore           (const std::type_info&);
    void                      DetachCore           (const char*, const std::type_info&);
    detail::ISceneAttachment* FindAttachmentCore   (const std::type_info&) const;
    detail::ISceneAttachment* FindAttachmentCore   (const char*, const std::type_info&) const;
    void                      DetachAllCore        (const std::type_info&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (SceneContext&, SceneContext&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class SceneManager
{
  public:
    typedef SceneContext::LogFunction LogHandler;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    SceneManager  ();
    SceneManager  (const SceneManager&);
    ~SceneManager ();

    SceneManager& operator = (const SceneManager&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadScene   (const char* file_name, const char* name_prefix = "");
    void LoadScene   (const char* file_name, const char* name_prefix, const LogHandler& log_handler);    
    void UnloadScene (const char* file_name);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сохранение сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void SaveScene (const char* file_name, Node& node);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка наличия сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool HasScene (const char* scene_name) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение группы ресурсов сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    ResourceGroup SceneResources (const char* scene_name) const;
    ResourceGroup Resources      () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание контекста сцены
///////////////////////////////////////////////////////////////////////////////////////////////////    
    typedef xtl::function<void (SceneContext&)> SceneContextCreator;
    
    SceneContext    CreateSceneContext          () const;
    xtl::connection RegisterSceneContextCreator (const SceneContextCreator&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    Node::Pointer CreateScene (const char* scene_name) const; //ResourceList in each Node as controller
    Node::Pointer CreateScene (const char* scene_name, SceneContext& context) const; //ResourceList in each Node as controller

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (SceneManager&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (SceneManager&, SceneManager&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Фабрика сцен
///////////////////////////////////////////////////////////////////////////////////////////////////
class ISceneFactory
{
  public:
    virtual ~ISceneFactory () {}
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Перечисление сцен
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (const char*)> SceneEnumerator;

    virtual void EnumScenes (const SceneEnumerator& handler) = 0;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение информации о сцене
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual bool GetSceneInfo (const char* name, ResourceGroup* resources) = 0; //if resources != 0 && scene present -> fill resources needed for scene
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void CreateScene (const char* name, Node& parent, SceneContext& scene_context) = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер сериализации сцен
///////////////////////////////////////////////////////////////////////////////////////////////////
class SceneSerializationManager
{
  public:
    typedef SceneManager::LogHandler                                                             LogHandler;  
    typedef xtl::function<ISceneFactory* (const char* file_name, const LogHandler& log_handler)> SceneLoader;
    typedef xtl::function<void (const char* file_name, Node& node)>                              SceneSaver;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация сериализаторов
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void RegisterLoader       (const char* file_type, const SceneLoader& loader);
    static void RegisterSaver        (const char* file_type, const SceneSaver& saver);
    static void UnregisterLoader     (const char* file_type);
    static void UnregisterSaver      (const char* file_type);
    static void UnregisterAllLoaders ();
    static void UnregisterAllSavers  ();
};

#include <sg/detail/scene_manager.inl>

}

#endif
