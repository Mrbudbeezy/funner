#ifndef SCENE_GRAPH_SCENE_MANAGER_HEADER
#define SCENE_GRAPH_SCENE_MANAGER_HEADER

namespace scene_graph
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Порождающий функтор узла
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef xtl::function<Node::Pointer ()> NodeCreator; ///??????????

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контекст сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class SceneContext
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////  
    SceneContext  ();
    SceneContext  (const SceneContext&);
    ~SceneContext ();

    SceneContext& operator = (const SceneContext&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Клонирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    SceneContext Clone () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Свойства
///////////////////////////////////////////////////////////////////////////////////////////////////
    common::PropertyMap Properties    () const;
    void                SetProperties (const common::PropertyMap&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединенные данные
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> void Attach     (T& value);
    template <class T> void Detach     (T& value);
    template <class T> T&   Attachment ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединенные именованные данные
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> void Attach     (const char* name, T& value);
    template <class T> void Detach     (const char* name, T& value);
    template <class T> T&   Attachment (const char* name);
      
      //????добавление кастомных загрузчиков
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (SceneContext&);
    
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (SceneContext&, SceneContext&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Объект, порождающий узел
///////////////////////////////////////////////////////////////////////////////////////////////////
class NodeCreator
{
  public:
    media::rms::Group ResourceGroup () const;
    
    //create binding???
  
    void Create (Node& parent, SceneContext& scene_context);  
    
    void AddRef  ();
    void Release ();

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class SceneManager
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    SceneManager  ();
    SceneManager  (const SceneManager&);
    ~SceneManager ();

    SceneManager& operator = (const SceneManager&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadScene   (const char* name);
    void UnloadScene (const char* name);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание контекста сцены
///////////////////////////////////////////////////////////////////////////////////////////////////    
    typedef xtl::function<void (SceneContext&)> SceneContextCreator;
    
    SceneContext    CreateSceneContext          ();
    xtl::connection RegisterSceneContextCreator (const SceneContextCreator&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    Node::Pointer CreateScene (const char* name); //ResourceList in each Node
    Node::Pointer CreateScene (const char* name, SceneContext& context); //ResourceList in each Node
      //режимы обработки ошибок

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (SceneManager&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (SceneManager&, SceneManager&);

}

#endif
