#ifndef SCENE_GRAPH_SCENE_MANAGER_HEADER
#define SCENE_GRAPH_SCENE_MANAGER_HEADER

#include <xtl/functional_fwd>

#include <sg/node.h>

namespace common
{

//forward declarations
class ParseNode;
class XmlWriter;

}

namespace media
{

namespace rms
{

//forward declaration
class Group;

}

}

namespace scene_graph
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контекст сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class SceneContext
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////  
    SceneContext  ();
    SceneContext  (const SceneContext&);
    ~SceneContext ();

    SceneContext& operator = (const SceneContext&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Клонирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    SceneContext Clone () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Свойства
///////////////////////////////////////////////////////////////////////////////////////////////////
    common::PropertyMap Properties    () const;
    void                SetProperties (const common::PropertyMap&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединенные данные
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> void Attach     (T& value);
    template <class T> void Detach     (T& value);
    template <class T> T&   Attachment ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединенные именованные данные
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> void Attach     (const char* name, T& value);
    template <class T> void Detach     (const char* name, T& value);
    template <class T> T&   Attachment (const char* name);
      
      //????добавление кастомных загрузчиков
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработчик ошибок создания сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<bool (const char* error_message)> ExceptionHandler; //return true if exceptions has processed

    xtl::connection RegisterExceptionHandler (const char* error_wc_mask, const ExceptionHandler& handler);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (SceneContext&);
    
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (SceneContext&, SceneContext&);

typedef media::rms::Group ResourceGroup;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Прототип сцены, используемый для её создания
///////////////////////////////////////////////////////////////////////////////////////////////////
class ScenePrototype
{
  public:
    typedef xtl::function<void (Node& parent, SceneContext& scene_context)> CreateHandler;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////  
    ScenePrototype  (const CreateHandler& creator, const scene_graph::ResourceGroup& resources);
    ScenePrototype  (const ScenePrototype& prototype);
    ~ScenePrototype ();

    ScenePrototype& operator = (const ScenePrototype&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Группа ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    const scene_graph::ResourceGroup& Resources () const; //группа ресурсов данного прототипа
          scene_graph::ResourceGroup& Resources ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    void          CreateScene (Node& parent, SceneContext& scene_context);
    Node::Pointer CreateScene (SceneContext& scene_context);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (ScenePrototype&);

  private:
    struct Impl;
    Impl* impl;    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (ScenePrototype&, ScenePrototype&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Фабрика прототипов сцен
///////////////////////////////////////////////////////////////////////////////////////////////////
class IScenePrototypeFactory
{
  public:
    virtual ~IScenePrototypeFactory () {}
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск прототипа
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual bool           HasPrototype (const char* name) = 0;
    virtual ScenePrototype GetPrototype (const char* name) = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (ScenePrototype&, ScenePrototype&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class SceneManager
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    SceneManager  ();
    SceneManager  (const SceneManager&);
    ~SceneManager ();

    SceneManager& operator = (const SceneManager&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadScene   (const char* file_name, const char* name_prefix = "");
    void UnloadScene (const char* file_name);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание контекста сцены
///////////////////////////////////////////////////////////////////////////////////////////////////    
    typedef xtl::function<void (SceneContext&)> SceneContextCreator;
    
    SceneContext    CreateSceneContext          ();
    xtl::connection RegisterSceneContextCreator (const SceneContextCreator&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    Node::Pointer CreateScene (const char* name); //ResourceList in each Node as controller
    Node::Pointer CreateScene (const char* name, SceneContext& context); //ResourceList in each Node as controller

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (SceneManager&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (SceneManager&, SceneManager&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер сериализации сцен
///////////////////////////////////////////////////////////////////////////////////////////////////
class SceneSerializerManager
{
  public:
    typedef xtl::function<IScenePrototypeFactory* (const char* file_name)> SceneLoader;
    typedef xtl::function<void (const char* file_name, Node& node)>        SceneSaver;
    typedef xtl::function<IScenePrototypeFactory* (common::ParseNode&)>    XmlSceneLoader;
    typedef xtl::function<bool (common::XmlWriter& xml_write, Node& node)> XmlSceneSaver;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация сериализаторов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RegisterLoader          (const char* file_type, const SceneLoader& loader);
    void RegisterSaver           (const char* file_type, const SceneSaver& saver);
    void RegisterXmlLoader       (const char* file_type, const char* node_type, const XmlSceneLoader& loader);
    void RegisterXmlSaver        (const char* file_type, const char* saver_name, const XmlSceneSaver& saver);
    void UnregisterLoader        (const char* file_type);
    void UnregisterSaver         (const char* file_type);
    void UnregisterXmlLoader     (const char* file_type, const char* node_type);
    void UnregisterXmlSaver      (const char* file_type, const char* saver_name);
    void UnregisterAllLoaders    ();
    void UnregisterAllSavers     ();
    void UnregisterAllXmlLoaders (const char* file_type);
    void UnregisterAllXmlLoaders ();
    void UnregisterAllXmlSavers  (const char* file_type);
    void UnregisterAllXmlSavers  ();
};

}

#endif
