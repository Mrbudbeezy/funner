#ifndef SCENE_GRAPH_INPUT_HEADER
#define SCENE_GRAPH_INPUT_HEADER

#include <stl/auto_ptr.h>

#include <xtl/functional_fwd>

#include <sg/screen.h>
#include <sg/entity.h>

namespace scene_graph
{

//forward declarations
class Viewport;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об обновлении зон в модели
///////////////////////////////////////////////////////////////////////////////////////////////////
enum InputZoneEvent
{
  InputZoneEvent_AfterZoneDescsUpdate, //срабатывает после изменения данных зон
  InputZoneEvent_OnActivityChanged,    //срабатывает после изменения состояния активности зон

  InputZoneEvent_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Модель зоны ввода
///////////////////////////////////////////////////////////////////////////////////////////////////  
class InputZoneModel: public Entity
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор зоны
///////////////////////////////////////////////////////////////////////////////////////////////////
    struct ZoneDesc
    {
      math::vec3f position;
      math::vec3f axis_x;
      math::vec3f axis_y;
    };
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество зон / получение массива зон
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t          ZoneDescsCount () const;
    const ZoneDesc* ZoneDescs      () const;    
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим автоматического обновления ограничивающего объема
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetBoundsAutoUpdate     (bool state);
    bool BoundsAutoUpdate        () const;
    void EnableBoundsAutoUpdate  () { SetBoundsAutoUpdate (true); }
    void DisableBoundsAutoUpdate () { SetBoundsAutoUpdate (false); }
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Активность зоны
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsActive   () const;
    void SetActive  (bool state);
    void Activate   () { SetActive (true); }
    void Deactivate () { SetActive (false); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подписка на события модели
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (InputZoneModel& sender, InputZoneEvent event_id)>                                                                EventHandler;
    typedef xtl::function<void (InputZoneModel& sender, const Viewport& viewport, const char* notification_id, const char* notification_params)> NotificationHandler;

    xtl::connection RegisterEventHandler        (InputZoneEvent event_id, const EventHandler& event_handler) const;
    xtl::connection RegisterNotificationHandler (const char* notification_id, const NotificationHandler& handler) const;
    xtl::connection RegisterNotificationHandler (const NotificationHandler& handler) const;
    
    using Entity::RegisterEventHandler;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение о возникновении события ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Notify                 (const Viewport& viewport, const char* notification_id, const char* notification_params) const;
    bool HasNotificationHandler (const char* notification_id) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка пересечения луча с зонами
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsIntersected (NodeTransformSpace  transform_space,               //система координат луча
                        const math::vec3f&  ray_from,                      //начальная координата луча
                        const math::vec3f&  ray_to,                        //конечная координата луча
                        size_t&             out_zone_index,                //индекс зоны, с которой пересекся луч
                        float&              out_ray_intersection_distance, //результирующее расстояние от ray_from до точки пересечения
                        float&              out_ray_to_zone_distance,      //минимальное расстояние до зоны (0 в случае, если было пересечение)
                        math::vec2f&        out_zone_intersection_point) const;  //точка пересечения в относительных координатах зоны

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputZoneModel  ();
    ~InputZoneModel ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Динамическая диспетчеризация
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AcceptCore (Visitor&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об изменении данных зоны
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateZoneDescsNotify ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Связывание свойств узла с методами узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BindProperties (common::PropertyBindingMap& bindings);    

  private:    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация получения количества зон и массива зон
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual size_t          ZoneDescsCountCore () = 0;
    virtual const ZoneDesc* ZoneDescsCore      () = 0;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещения
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AfterUpdateWorldTransformEvent ();
    void UpdateZoneInternals ();
    void UpdateZoneBounds ();
  
  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Список зон
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputZoneList: public InputZoneModel
{
  public:
    typedef xtl::com_ptr<InputZoneList>       Pointer;
    typedef xtl::com_ptr<const InputZoneList> ConstPointer;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание списка зон
///////////////////////////////////////////////////////////////////////////////////////////////////
    static Pointer Create ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Размер массива зон
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t ZonesCount () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Изменение размера списка зон / резервирование места для хранения зон
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Resize  (size_t count);
    void Reserve (size_t count);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Массив спрайтов
///////////////////////////////////////////////////////////////////////////////////////////////////
    const ZoneDesc* Zones () const;
          ZoneDesc* Zones ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление зон в массив
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Insert (const ZoneDesc& Zone);
    void Insert (size_t zones_count, const ZoneDesc* Zones);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка списка зон
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RemoveAll ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об обновлении данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Invalidate ();

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputZoneList  ();
    ~InputZoneList ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Динамическая диспетчеризация
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AcceptCore (Visitor&);
    
  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация получения количества зон и массива зон
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t          ZoneDescsCountCore ();
    const ZoneDesc* ZoneDescsCore      ();

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Зона ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputZone: public InputZoneModel
{
  public:
    typedef xtl::com_ptr<InputZone>       Pointer;
    typedef xtl::com_ptr<const InputZone> ConstPointer;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание зоны
///////////////////////////////////////////////////////////////////////////////////////////////////
    static Pointer Create ();    

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputZone  ();
    ~InputZone ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Динамическая диспетчеризация
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AcceptCore (Visitor&);    
    
  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация получения количества зон и массива зон
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t          ZoneDescsCountCore ();
    const ZoneDesc* ZoneDescsCore      ();

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

}

#endif
