#ifndef SCENE_GRAPH_CONTROLLER_HEADER
#define SCENE_GRAPH_CONTROLLER_HEADER

#include <stl/auto_ptr.h>

#include <sg/node.h>

namespace scene_graph
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим владения
///////////////////////////////////////////////////////////////////////////////////////////////////
enum ControllerOwnerMode
{
  ControllerOwnerMode_None,               //раздельное время жизни контроллера и узла
  ControllerOwnerMode_ControllerOwnsNode, //контроллер владеет узлом
  ControllerOwnerMode_NodeOwnsController, //узел владеет контроллером
  
  ControllerOwnerMode_Default = ControllerOwnerMode_None
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контроллер
///////////////////////////////////////////////////////////////////////////////////////////////////
class Controller
{
  public:  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void   AddRef   () const;
    void   Release  () const;
    size_t UseCount () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Узел, с которым связан контроллер
///////////////////////////////////////////////////////////////////////////////////////////////////
          scene_graph::Node* AttachedNode ();
    const scene_graph::Node* AttachedNode () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим владения
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                SetOwnerMode (ControllerOwnerMode mode);
    ControllerOwnerMode OwnerMode    () const;
    void                ControllerOwnsNode () { SetOwnerMode (ControllerOwnerMode_ControllerOwnsNode); }
    void                NodeOwnsController () { SetOwnerMode (ControllerOwnerMode_NodeOwnsController); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отсоединение контроллера от узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Detach ();
    
  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
            Controller  (scene_graph::Node& node);
    virtual ~Controller ();
    
  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление состояния (переопределяется в потомках)
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Update (float dt);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Вспомогательные методы
///////////////////////////////////////////////////////////////////////////////////////////////////
    void OnUpdate      (float dt);
    void OnDestroyNode ();
    
  private:
    Controller (const Controller&); //no impl
    Controller& operator = (const Controller&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

}

#endif
