#ifndef SCENE_GRAPH_CONTROLLER_HEADER
#define SCENE_GRAPH_CONTROLLER_HEADER

#include <stl/auto_ptr.h>

#include <xtl/dynamic_cast_root.h>
#include <xtl/functional_fwd>
#include <xtl/intrusive_ptr.h>
#include <xtl/rational.h>

namespace scene_graph
{

//forward declaration
class Node;

//implementation forwards
struct ControllerEntry;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Значение времени, используемое при обновлениях
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef xtl::rational<size_t> TimeValue;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим владения
///////////////////////////////////////////////////////////////////////////////////////////////////
enum ControllerOwnerMode
{
  ControllerOwnerMode_None,               //раздельное время жизни контроллера и узла
  ControllerOwnerMode_ControllerOwnsNode, //контроллер владеет узлом
  ControllerOwnerMode_NodeOwnsController, //узел владеет контроллером
  
  ControllerOwnerMode_Default = ControllerOwnerMode_NodeOwnsController
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим управление временем
///////////////////////////////////////////////////////////////////////////////////////////////////
enum ControllerTimeMode
{
  ControllerTimeMode_Absolute, //получение абсолютного времени
  ControllerTimeMode_Delta,    //получение дельт от последнего обновления
  
  ControllerTimeMode_Default = ControllerTimeMode_Absolute
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контроллер
///////////////////////////////////////////////////////////////////////////////////////////////////
class Controller: public xtl::dynamic_cast_root
{
  public:  
    typedef xtl::com_ptr<Controller>       Pointer;
    typedef xtl::com_ptr<const Controller> ConstPointer;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void   AddRef   () const;
    void   Release  () const;
    size_t UseCount () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя
///////////////////////////////////////////////////////////////////////////////////////////////////
    void        SetName (const char* name);
    const char* Name    () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Узел, с которым связан контроллер
///////////////////////////////////////////////////////////////////////////////////////////////////
          scene_graph::Node* AttachedNode ();
    const scene_graph::Node* AttachedNode () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим владения
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                SetOwnerMode (ControllerOwnerMode mode);
    ControllerOwnerMode OwnerMode    () const;
    void                ControllerOwnsNode () { SetOwnerMode (ControllerOwnerMode_ControllerOwnsNode); }
    void                NodeOwnsController () { SetOwnerMode (ControllerOwnerMode_NodeOwnsController); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отсоединение контроллера от узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Detach ();    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление состояния
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateState (const TimeValue& time);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Перебор контроллеров
///////////////////////////////////////////////////////////////////////////////////////////////////
    Pointer      NextController ();
    Pointer      PrevController ();
    ConstPointer NextController () const;
    ConstPointer PrevController () const;

    template <class T> xtl::com_ptr<T>       NextController ();
    template <class T> xtl::com_ptr<T>       PrevController ();
    template <class T> xtl::com_ptr<const T> NextController () const;
    template <class T> xtl::com_ptr<const T> PrevController () const;

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
            Controller  (scene_graph::Node& node, bool updatable = true);
            Controller  (scene_graph::Node& node, ControllerTimeMode time_mode);
    virtual ~Controller ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние обновления контроллера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUpdatable   (bool state);
    void EnableUpdates  () { SetUpdatable (true); }
    void DisableUpdates () { SetUpdatable (false); }
    bool IsUpdatable    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим управления временем
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetTimeMode (ControllerTimeMode mode);
    ControllerTimeMode TimeMode    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Минимальная дельта (работает в обоих режимах управления временем)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void             SetMinDelta (const TimeValue& value);
    const TimeValue& MinDelta    () const;

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление состояния (переопределяется в потомках)
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Update (const TimeValue& value);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Узел был удалён (переопределяется в потомках)
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void OnNodeDetached ();    
    
  private:
    Controller (const Controller&); //no impl
    Controller& operator = (const Controller&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

namespace controllers
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контроллер по умолчанию
///////////////////////////////////////////////////////////////////////////////////////////////////
class DefaultController: public Controller
{
  public:
    typedef xtl::com_ptr<DefaultController>             Pointer;
    typedef xtl::com_ptr<const DefaultController>       ConstPointer;
    typedef xtl::function<void (const TimeValue& time)> UpdateFunction;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание контроллера
///////////////////////////////////////////////////////////////////////////////////////////////////
    static Pointer Create (Node& node);
    static Pointer Create (Node& node, const UpdateFunction& updater);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Функтор обновления
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                  SetUpdateHandler (const UpdateFunction&);
    const UpdateFunction& UpdateHandler () const;
    
  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    DefaultController  (Node&, const UpdateFunction&);
    ~DefaultController ();
    
  private:
    void Update (const TimeValue& time);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

}

#include <sg/detail/controller.inl>

}

#endif
