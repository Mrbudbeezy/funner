#ifndef SCENE_GRAPH_VISUAL_MODEL_HEADER
#define SCENE_GRAPH_VISUAL_MODEL_HEADER

#include <stl/auto_ptr.h>
#include <sg/entity.h>

namespace scene_graph
{

//forward declarations
class Scissor;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об обновлении модели
///////////////////////////////////////////////////////////////////////////////////////////////////
enum VisualModelEvent
{
  VisualModelEvent_AfterScissorUpdate, //срабатывает после изменения области отсечения

  VisualModelEvent_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отображаемая модель
///////////////////////////////////////////////////////////////////////////////////////////////////
class VisualModel: public Entity
{
  public:
    typedef xtl::com_ptr<VisualModel>       Pointer;
    typedef xtl::com_ptr<const VisualModel> ConstPointer;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Область отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                        SetScissor (scene_graph::Scissor* scissor, NodeBindMode bind_mode = NodeBindMode_Default);
    scene_graph::Scissor*       Scissor    ();
    const scene_graph::Scissor* Scissor    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Динамические свойства шейдера (могут быть NULL)
///////////////////////////////////////////////////////////////////////////////////////////////////
    common::PropertyMap*       DynamicShaderProperties    ();
    const common::PropertyMap* DynamicShaderProperties    () const;
    void                       SetDynamicShaderProperties (common::PropertyMap* properties);
    void                       SetDynamicShaderProperties (const common::PropertyMap& properties);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Статические свойства шейдера (могут быть NULL)
///////////////////////////////////////////////////////////////////////////////////////////////////
    common::PropertyMap*       StaticShaderProperties    ();
    const common::PropertyMap* StaticShaderProperties    () const;
    void                       SetStaticShaderProperties (common::PropertyMap* properties);
    void                       SetStaticShaderProperties (const common::PropertyMap& properties);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подписка на события модели
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (VisualModel& sender, VisualModelEvent event_id)> EventHandler;

    xtl::connection RegisterEventHandler (VisualModelEvent event_id, const EventHandler& event_handler);
    
    using Entity::RegisterEventHandler;

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    VisualModel  ();
    ~VisualModel ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Динамическая диспетчеризация
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AcceptCore (Visitor&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Связывание свойств узла с методами узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BindProperties (common::PropertyBindingMap& bindings);    

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

}

#endif
